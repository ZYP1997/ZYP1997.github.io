<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++ Lesson13 | 空之境界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="ZYP">
  
  
    <meta name="description" content="第七章 函数7.8 重载函数出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为重载函数。">
  
  <meta name="description" content="第七章 函数7.8 重载函数出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为重载函数。">
<meta name="keywords" content="C++ Primer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Lesson13">
<meta property="og:url" content="https://zypsola.com/2018/11/01/C++Primer13/index.html">
<meta property="og:site_name" content="空之境界">
<meta property="og:description" content="第七章 函数7.8 重载函数出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为重载函数。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-01T16:51:04.005Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Lesson13">
<meta name="twitter:description" content="第七章 函数7.8 重载函数出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为重载函数。">
  
  
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">空之境界</a></h1>
    <p><a href="/">ZYP&#39;s Blog</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags/C#">C#</a></li>
      
        <li><a href="/tags/C-Primer">C++</a></li>
      
        <li><a href="/tags/Unity">Unity</a></li>
      
        <li><a href="/tags/Z720">Z720</a></li>
      
        <li><a href="/tags/Others">Others</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2018/11/01/C++Primer13/">
  <time datetime="2018-11-01T15:49:11.000Z">
    2018-11-01
  </time>
</a>
    
    
  
    <h1 class="title">C++ Lesson13</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="7-8-重载函数"><a href="#7-8-重载函数" class="headerlink" title="7.8 重载函数"></a>7.8 重载函数</h2><p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为<strong>重载函数</strong>。 </p>
<a id="more"></a>
<p>任何程序都仅有一个 main 函数的实例。main 函数不能重载。 </p>
<p>如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。</p>
<p>有些看起来不相同的形参表本质上是相同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(const Account &amp;acct); </span><br><span class="line">   Record lookup(const Account&amp;);</span><br><span class="line"></span><br><span class="line">   typedef Phone Telno; </span><br><span class="line">   Record lookup(const Phone&amp;); </span><br><span class="line">   Record lookup(const Telno&amp;);</span><br><span class="line"></span><br><span class="line">   Record lookup(const Phone&amp;, const Name&amp;);</span><br><span class="line">   Record lookup(const Phone&amp;, const Name&amp; = &quot;&quot;); </span><br><span class="line"></span><br><span class="line">   Record lookup(Phone); </span><br><span class="line">   Record lookup(const Phone);</span><br></pre></td></tr></table></figure>
<h3 id="7-8-1-重载与作用域"><a href="#7-8-1-重载与作用域" class="headerlink" title="7.8.1 重载与作用域"></a>7.8.1 重载与作用域</h3><p>一般的作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。由此推论，每一个版本的重载函数都应在同一个作用域中声明。 </p>
<h3 id="7-8-2-函数匹配与实参转换"><a href="#7-8-2-函数匹配与实参转换" class="headerlink" title="7.8.2 函数匹配与实参转换"></a>7.8.2 函数匹配与实参转换</h3><p>函数<strong>重载确定</strong>，即<strong>函数匹配</strong>是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。匹配结果有三种可能： </p>
<ol>
<li><p>编译器找到与实参<strong>最佳匹配</strong>的函数，并生成调用该函数的代码。 </p>
</li>
<li><p>找不到形参与函数调用的实参匹配的函数，在这种情况下，编译器将给出编译错误信息。 </p>
</li>
<li><p>存在多个与实参匹配的函数，但没有一个是明显的最佳选择。这种情况也是，该调用具有<strong>二义性</strong>。 </p>
</li>
</ol>
<h3 id="7-8-3-重载确定的三个步骤"><a href="#7-8-3-重载确定的三个步骤" class="headerlink" title="7.8.3 重载确定的三个步骤"></a>7.8.3 重载确定的三个步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void f(); </span><br><span class="line">void f(int); </span><br><span class="line">void f(int, int); </span><br><span class="line">void f(double, double = 3.14); </span><br><span class="line">f(5.6);  // calls void f(double, double)</span><br></pre></td></tr></table></figure>
<p>函数重载确定的第一步是确定该调用所考虑的重载函数集合，该集合中的函数称为<strong>候选函数</strong>。</p>
<p>第二步是从候选函数中选择一个或多个函数，它们能够用该调用中指定的实参来调用。因此，选出来的函数称为<strong>可行函数</strong>。可行函数必须满足两个条件：第一，函数的形参个数与该调用的实参个数相同；第二，每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型。 </p>
<p>如果函数具有默认实参，则调用该函数时，所用的实参可能比实际需要的少。默认实参也是实参，在函数匹配过程中，它的处理方式与其他实参一样。 </p>
<p>函数重载确定的第三步是确定与函数调用中使用的实际参数匹配最佳的可行函数。这个过程考虑函数调用中的每一个实参，选择对应形参与之最匹配的一个或多个可行函数。其原则是实参类型与形参类型越接近则匹配越佳。因此，实参类型与形参类型之间的精确类型匹配比需要转换的匹配好。 </p>
<p>如果函数调用使用了两个或两个以上的显式实参，则函数匹配会更加复杂。假设有两样的名为 f 的函数，分析下面的函数调用： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(42, 2.56);</span><br></pre></td></tr></table></figure>
<p>在本例中，可行函数是 f(int, int) 和 f(double, double)。接下来，编译器通过依次检查每一个实参来决定哪个或哪些函数匹配最佳。如果有且仅有一个函数满足下列条件，则匹配成功： </p>
<ol>
<li><p>其每个实参的匹配都不劣于其他可行函数需要的匹配。 </p>
</li>
<li><p>至少有一个实参的匹配优于其他可行函数提供的匹配。 </p>
</li>
</ol>
<p>这个调用有二义性：每个可行函数都对函数调用的一个实参实现更好的匹配。编译器将产生错误。解决这样的二义性，可通过显式的强制类型转换强制函数匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(static_cast&lt;double&gt;(42), 2.56);  // calls f(double, double) </span><br><span class="line">f(42, static_cast&lt;int&gt;(2.56));     // calls f(int, int)</span><br></pre></td></tr></table></figure>
<h3 id="7-8-4-实参类型转换"><a href="#7-8-4-实参类型转换" class="headerlink" title="7.8.4 实参类型转换"></a>7.8.4 实参类型转换</h3><p>为了确定最佳匹配，编译器将实参类型到相应形参类型转换划分等级。转换等级以降序排列如下： </p>
<ol>
<li><p>精确匹配。实参与形参类型相同。 </p>
</li>
<li><p>通过类型提升实现的匹配。 </p>
</li>
<li><p>通过标准转换实现的匹配。 </p>
</li>
<li><p>通过类类型转换实现的匹配。 </p>
</li>
</ol>
<p>必须注意的一个重点是较小的整型提升为 int 型。假设有两个函数，一个的形参为 int 型，另一个的形参则是 short 型。对于任意整型的实参值，int 型版本都是优于 short 型版本的较佳匹配，即使从形式上看 short 型版本的匹配较佳:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ff(int); </span><br><span class="line">void ff(short); </span><br><span class="line">ff(&apos;a&apos;);    // char promotes to int, so matches ff(int)</span><br></pre></td></tr></table></figure>
<p>字面值常量 3.14 的类型为 double。这种类型既可转为 long 型也可转为 float 型。由于两者都是可行的标准转换，因此该调用具有二义性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern void manip(long); </span><br><span class="line">extern void manip(float); </span><br><span class="line">manip(3.14);  // error: ambiguous call</span><br></pre></td></tr></table></figure>
<p><strong>参数匹配和枚举类型</strong></p>
<p>回顾枚举类型enum，我们知道这种类型的对象只能用同一枚举类型的另一个对象或一个枚举成员进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Tokens &#123;INLINE = 128, VIRTUAL = 129&#125;; </span><br><span class="line">void ff(Tokens); </span><br><span class="line">void ff(int); </span><br><span class="line">int main() &#123; </span><br><span class="line">    Tokens curTok = INLINE; </span><br><span class="line">    ff(128);    // exactly matches ff(int) </span><br><span class="line">    ff(INLINE); // exactly matches ff(Tokens) </span><br><span class="line">    ff(curTok); // exactly matches ff(Tokens) </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整型形参。此时，枚举值被提升为 int 型或更大的整型。具体的提升类型取决于枚举成员的值。</p>
<p><strong>重载和const形参</strong></p>
<p>仅当形参是引用或指针时，形参是否为 const 才有影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun(int &amp;a)&#123;return ++a;&#125;</span><br><span class="line">int fun(const int &amp;a) &#123;return a;&#125;</span><br><span class="line"></span><br><span class="line">const int a(5);</span><br><span class="line">int b(5);</span><br><span class="line">cout &lt;&lt; fun(a) &lt;&lt; endl;   //5</span><br><span class="line">cout &lt;&lt; fun(b) &lt;&lt; endl;   //6</span><br></pre></td></tr></table></figure>
<p>不能基于指针本身是否为 const 来实现函数的重载： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *a)</span><br><span class="line">int fun(int *const a)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *a)&#123;return ++*a;&#125;</span><br><span class="line">int fun(const int *a) &#123;return *a;&#125;</span><br><span class="line"></span><br><span class="line">const int a(5);</span><br><span class="line">int b(5);</span><br><span class="line">cout &lt;&lt; fun(&amp;a) &lt;&lt; endl;   //5</span><br><span class="line">cout &lt;&lt; fun(&amp;b) &lt;&lt; endl;   //6</span><br></pre></td></tr></table></figure>
<h2 id="7-9-指向函数的指针"><a href="#7-9-指向函数的指针" class="headerlink" title="7.9 指向函数的指针"></a>7.9 指向函数的指针</h2>
    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C-Primer/">C++ Primer</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">ZYP</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
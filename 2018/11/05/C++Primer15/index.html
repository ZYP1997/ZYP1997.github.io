<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++ Lesson15 | 空之境界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="ZYP">
  
  
    <meta name="description" content="第九章 顺序容器容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是顺序容器。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。">
  
  <meta name="description" content="第九章 顺序容器容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是顺序容器。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。">
<meta name="keywords" content="C++ Primer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Lesson15">
<meta property="og:url" content="https://zypsola.com/2018/11/05/C++Primer15/index.html">
<meta property="og:site_name" content="空之境界">
<meta property="og:description" content="第九章 顺序容器容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是顺序容器。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-06T14:49:49.987Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Lesson15">
<meta name="twitter:description" content="第九章 顺序容器容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是顺序容器。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。">
  
  
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">空之境界</a></h1>
    <p><a href="/">ZYP&#39;s Blog</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags/C#">C#</a></li>
      
        <li><a href="/tags/C-Primer">C++</a></li>
      
        <li><a href="/tags/Unity">Unity</a></li>
      
        <li><a href="/tags/Z720">Z720</a></li>
      
        <li><a href="/tags/Others">Others</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2018/11/05/C++Primer15/">
  <time datetime="2018-11-05T15:43:41.000Z">
    2018-11-05
  </time>
</a>
    
    
  
    <h1 class="title">C++ Lesson15</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><p>容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是<strong>顺序容器</strong>。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。 </p>
<a id="more"></a>
<p>标准库定义了三种顺序容器类型：<strong>vector</strong>(支持快速随机访问)、<strong>list</strong>(支持快速插入/删除)和<strong>deque</strong>(双端队列)。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括<strong>stack</strong>(后进先出LIFO堆栈)、<strong>queue</strong>(先进先出FIFO队列)和<strong>priority_queue</strong>(有优先级管理的队列)类型。</p>
<h2 id="9-1-顺序容器的定义"><a href="#9-1-顺序容器的定义" class="headerlink" title="9.1 顺序容器的定义"></a>9.1 顺序容器的定义</h2><p>所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C&lt;T&gt; c;    创建一个的空容器，适用于所有容器。 </span><br><span class="line">C c(c2);   创建容器 c2 的副本；c 和 c2 必须具有相同的容器类型，相同类型的元素。适用于所有容器。 </span><br><span class="line">C c(b, e); 创建 c，其元素是迭代器 b 和 e 标示的范围内元素的副本。适用于所有容器。 </span><br><span class="line">C c(n, t); 用 n 个值为 t 的元素创建容器 c，其中值 t 必须是容器类型 C 的元素类型的值，或者是可转换为该类型的值。 只适用于顺序容器。 </span><br><span class="line">C c(n);    创建有 n 个值初始化元素的容器 c。 只适用于顺序容器。</span><br></pre></td></tr></table></figure>
<p><strong>初始化为一段元素的副本</strong></p>
<p>尽管不能直接将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要它们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *words[] = &#123; &quot;asd&quot;,&quot;gfd&quot;,&quot;qwe&quot; &#125;;</span><br><span class="line">vector&lt;string&gt; svec(words, words + sizeof(words) / sizeof(char*));</span><br><span class="line">vector&lt;string&gt;::iterator iter = svec.begin();</span><br><span class="line">list&lt;string&gt; slist(svec.begin(), svec.end());</span><br><span class="line">list&lt;string&gt;::iterator iter2 = slist.begin();</span><br><span class="line">while (iter != svec.end() &amp;&amp; iter2 != slist.end())&#123;</span><br><span class="line">	cout &lt;&lt; *iter++ &lt;&lt; *iter2++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>容器内元素的类型约束</strong></p>
<p>大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。除了引用类型外，所有内置<br>或复合类型都可用做元素类型。此外，关联容器的键类型还需满足其他的约束。IO 库类型不支持复制或赋值。因此，不能创建存放 IO 类型对象的容器。</p>
<h2 id="9-2-迭代器和迭代器范围"><a href="#9-2-迭代器和迭代器范围" class="headerlink" title="9.2 迭代器和迭代器范围"></a>9.2 迭代器和迭代器范围</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*iter       返回迭代器 iter 所指向的元素的引用 </span><br><span class="line">iter-&gt;mem   对 iter 进行解引用，等效于(*iter).mem</span><br><span class="line">iter++;++iter;iter--;--iter;==;!=</span><br></pre></td></tr></table></figure>
<p><strong>vector和deque容器的迭代器提供额外的运算</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iter + n;iter - n;</span><br><span class="line">iter += n;iter -= iter;</span><br><span class="line">iter1 - iter2;</span><br><span class="line">&gt;,&gt;=,&lt;,&lt;=;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-1-迭代器范围"><a href="#9-2-1-迭代器范围" class="headerlink" title="9.2.1 迭代器范围"></a>9.2.1 迭代器范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.begin();C.end();</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-使迭代器失效的容器操作"><a href="#9-2-2-使迭代器失效的容器操作" class="headerlink" title="9.2.2 使迭代器失效的容器操作"></a>9.2.2 使迭代器失效的容器操作</h3><p>一些容器操作会修改容器的内在状态或移动容器内的元素。这样的操作使所有指向被移动的元素的迭代器失效，也可能同时使其他迭代器失效。使用无效迭代器是没有定义的，可能会导致与悬垂指针相同的问题。 </p>
<h2 id="9-3-每种顺序容器都提供了一组有用的类型定义以及以下操作"><a href="#9-3-每种顺序容器都提供了一组有用的类型定义以及以下操作" class="headerlink" title="9.3 每种顺序容器都提供了一组有用的类型定义以及以下操作"></a>9.3 每种顺序容器都提供了一组有用的类型定义以及以下操作</h2><p>在容器中添加元素。<br>在容器中删除元素。<br>设置容器大小。<br>（如果有的话）获取容器内的第一个和最后一个元素。</p>
<h3 id="9-3-1-容器定义的类型别名"><a href="#9-3-1-容器定义的类型别名" class="headerlink" title="9.3.1 容器定义的类型别名"></a>9.3.1 容器定义的类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_type   无符号整型，足以存储此容器类型的最大可能容器长度 </span><br><span class="line">iterator    此容器类型的迭代器类型 </span><br><span class="line">const_iterator    元素的只读迭代器类型 </span><br><span class="line">reverse_iterator  按逆序寻址元素的迭代器 </span><br><span class="line">const_reverse_iterator  元素的只读（不能写）逆序迭代器 </span><br><span class="line">difference_type   足够存储两个迭代器差值的有符号整型，可为负数 </span><br><span class="line">value_type        元素类型 </span><br><span class="line">reference         元素的左值类型，是 value_type&amp; 的同义词 </span><br><span class="line">const_reference   元素的常量左值类型，等效于 const value_type&amp;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-2-begin和end成员"><a href="#9-3-2-begin和end成员" class="headerlink" title="9.3.2 begin和end成员"></a>9.3.2 begin和end成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.begin()   返回一个迭代器，指向 c 的第一个元素 </span><br><span class="line">c.end()     返回一个迭代器，指向 c 的最后一个元素的下一位置 </span><br><span class="line">c.rbegin()  返回一个逆序迭代器，指向 c 的最后一个元素 </span><br><span class="line">c.rend()    返回一个逆序迭代器，指向 c 的第一个元素前面的位置</span><br></pre></td></tr></table></figure>
<p>这些操作返回什么类型取决于容器是否为 const。如果容器不是 const，则这些操作返回 iterator 或 reverse_iterator 类型。如果容器是 const，则其返回类型要加上 const_ 前缀，也就是 const_iterator 和 const_reverse_iterator 类型。</p>
<h3 id="9-3-3-在顺序容器中添加元素"><a href="#9-3-3-在顺序容器中添加元素" class="headerlink" title="9.3.3 在顺序容器中添加元素"></a>9.3.3 在顺序容器中添加元素</h3><p>所有顺序容器都支持push_back操作，提供在容器尾部插入一个元素的功能。</p>
<p>除了 push_back 运算，list 和 deque 容器类型还提供了类似的操作：push_front。这个操作实现在容器首部插入新元素的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.push_back(t)   在容器 c 的尾部添加值为 t 的元素。返回 void 类型 </span><br><span class="line">c.push_front(t)  在容器 c 的前端添加值为 t 的元素。返回 void 类型，只适用于 list 和 deque 容器类型 </span><br><span class="line">c.insert(p,t)    在迭代器 p 所指向的元素前面插入值为 t 的新元素。返回指向新添加元素的迭代器</span><br><span class="line">c.insert(p,n,t)  在迭代器 p 所指向的元素前面插入 n 个值为 t 的新元素。返回 void 类型</span><br><span class="line">c.insert(p,b,e)  在迭代器 p 所指向的元素前面插入由迭代器 b 和 e 标记的范围内的元素。返回 void 类型</span><br></pre></td></tr></table></figure>
<h3 id="9-3-4-关系操作符"><a href="#9-3-4-关系操作符" class="headerlink" title="9.3.4 关系操作符"></a>9.3.4 关系操作符</h3><p>所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。容器的比较使用了元素类型定义的同<br>一个关系操作符：两个容器做 != 比较使用了其元素类型定义的 != 操作符。如果容器的元素类型不支持某种操作符，则该容器就不能做这种比较运算。 </p>
<p>如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。 </p>
<p>如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。 </p>
<p>如果两个容器都不是对文的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。 </p>
<h3 id="9-3-5-容器大小的操作"><a href="#9-3-5-容器大小的操作" class="headerlink" title="9.3.5 容器大小的操作"></a>9.3.5 容器大小的操作</h3><p>所有容器类型都提供四种与容器大小相关的操。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.size()       返回容器 c 中的元素个数。返回类型为 c::size_type </span><br><span class="line">c.max_size()   返回容器 c 可容纳的最多元素个数，返回类型为 c::size_type </span><br><span class="line">c.empty()      返回标记容器大小是否为 0 的布尔值 </span><br><span class="line">c.resize(n)    调整容器 c 的长度大小，使其能容纳 n 个元素，如果 n &lt; c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素 </span><br><span class="line">c.resize(n,t)  调整容器 c 的长度大小，使其能容纳 n 个元素。所有新添加的元素值都为 t</span><br></pre></td></tr></table></figure>
<h3 id="9-3-6-访问元素"><a href="#9-3-6-访问元素" class="headerlink" title="9.3.6 访问元素"></a>9.3.6 访问元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.back()   返回容器 c 的最后一个元素的引用。如果 c 为空，则该操作未定义 </span><br><span class="line">c.front()  返回容器 c 的第一个元素的引用。如果 c 为空，则该操作未定义</span><br><span class="line">c[n]       返回下标为 n 的元素的引用 如果 n &lt;0 或 n &gt;= c.size()，则该操作未定义，只适用于vector和deque</span><br><span class="line">c.at(n)    返回下标为 n 的元素的引用。如果下标越界，则该操作未定义，只适用于vector和deque</span><br></pre></td></tr></table></figure>
<h3 id="9-3-7-删除元素"><a href="#9-3-7-删除元素" class="headerlink" title="9.3.7 删除元素"></a>9.3.7 删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.erase(p)    删除p所指向的元素，返回一个迭代器，它指向被删除元素后面的元素。如果p指向容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置 </span><br><span class="line">c.erase(b,e)  删除b和e所标记的范围内所有的元素，返回一个迭代器，它指向被删除元素段后面的元素。如果e本身就是指向超出末端的下一位置的迭代器，则返回的迭代器也指向容器的超出末端的下一位置</span><br><span class="line">c.clear()     删除容器c内的所有元素。返回 void </span><br><span class="line">c.pop_back()  删除容器c的最后一个元素。返回 void。如果c为空容器，则该函数未定义 </span><br><span class="line">c.pop_front() 删除容器c的第一个元素。返回 void。如果c为空容器，则该函数未定义，只适用于 list 或 deque 容器</span><br></pre></td></tr></table></figure>
<h3 id="9-3-8-赋值与swap"><a href="#9-3-8-赋值与swap" class="headerlink" title="9.3.8 赋值与swap"></a>9.3.8 赋值与swap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2        删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和c2 的类型（包括容器类型和元素类型）必须相同 </span><br><span class="line">c1.swap(c2)    交换内容：c1 中存放的是 c2 原来的元素，c2 中存放的则是 c1 原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 复制到 c1 的操作快 </span><br><span class="line">c.assign(b,e)  重新设置 c 的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器 </span><br><span class="line">c.assign(n,t)  将容器 c 重新设置为存储 n 个值为 t 的元素</span><br></pre></td></tr></table></figure>
<p>swap操作不会删除或插入任何元素，而且保证在常量时间内实现交换。由于容器内没有移动任何元素，因此迭代器不会失效。 </p>
<h2 id="9-4-vector容器的自增长"><a href="#9-4-vector容器的自增长" class="headerlink" title="9.4 vector容器的自增长"></a>9.4 vector容器的自增长</h2><p>为了支持快速的随机访问，vector 容器的元素以连续的方式存放：每一个元素都紧挨着前一个元素存储。 </p>
<p>为了使 vector 容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些。vector 容器预留了这些额外的存储区，用于存放新添加的元素。</p>
<p>在实际应用中，比起 list 和 deque 容器，vector 的增长效率通常会更高。 </p>
<h3 id="9-4-1-capacity和reserve成员"><a href="#9-4-1-capacity和reserve成员" class="headerlink" title="9.4.1 capacity和reserve成员"></a>9.4.1 capacity和reserve成员</h3><p>vector容器处理内存分配的细节是其实现的一部分。然而，该实现部分是由vector的接口支持的。vector类提供了两个成员函数：capacity和reserve使程序员可与vector容器内存分配的实现部分交互工作。capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而reserve操作则告诉vector容器应该预留多少个元素的存储空间。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; svec(10);</span><br><span class="line">cout &lt;&lt; svec.capacity() &lt;&lt; endl;     //10</span><br><span class="line">svec.reserve(50);</span><br><span class="line">cout &lt;&lt; svec.capacity() &lt;&lt; endl;     //50</span><br></pre></td></tr></table></figure>
<h2 id="9-5-容器的选用"><a href="#9-5-容器的选用" class="headerlink" title="9.5 容器的选用"></a>9.5 容器的选用</h2><p>程序使用这些操作的程序将决定应该选择哪种类型的容器。vector和deque容器提供了对元素的快速随机访问，但付出的代价是，在容器的任意位置插入或删除元素，比在容器尾部插入和删除的开销更大。list类型在任何位置都能快速插入和删除，但付出的代价是元素的随机访问开销较大。 </p>
<p><strong>插入操作如何影响容器的选择</strong></p>
<p>list 容器表示不连续的内存区域，允许向前和向后逐个遍历元素。在任何位置都可高效地 insert 或 erase 一个元素。插入或删除 list 容器中的一个元素不需要移动任何其他元素。另一方面，list 容器不支持随机访问，访问某个元素要求遍历涉及的其他元素。 </p>
<p>对于 vector 容器，除了容器尾部外，其他任何位置上的插入（或删除）操作都要求移动被插入（或删除）元素右边所有的元素。</p>
<p>deque 容器拥有更加复杂的数据结构。从 deque 队列的两端插入和删除元素都非常快。在容器中间插入或删除付出的代价将更高。</p>
<p><strong>元素的访问如何影响容器的选择</strong></p>
<p>vector 和 deque 容器都支持对其元素实现高效的随机访问。由于 vector 容器的每次访问都是距离其起点的固定偏移，因此其随机访问非常有效率。在 list 容器中，上述跳跃访问会变得慢很多。在 list 容器的元素之间移动的唯一方法是顺序跟随指针。</p>
<h2 id="再谈string类型"><a href="#再谈string类型" class="headerlink" title="再谈string类型"></a>再谈string类型</h2><p>string 类型还支持大多数顺序容器操作。在某些方面，可将 string 类型视为字符容器。除了一些特殊操作，string 类型提供与 vector 容器相同的操作。string 类型与 vector 容器不同的是，它不支持以栈方式操纵容器：在 string 类型中不能使用 front、back 和 pop_back 操作。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;123&quot;;</span><br><span class="line">string::iterator iter = str.begin();</span><br><span class="line">while (iter != str.end()) &#123;</span><br><span class="line">	cout &lt;&lt; *iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只适用于string类型的操作"><a href="#只适用于string类型的操作" class="headerlink" title="只适用于string类型的操作"></a>只适用于string类型的操作</h3><p><strong>子串操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos, n) 返回一个 string 类型的字符串，它包含 s 中从下标 pos 开始的 n 个字符 </span><br><span class="line">s.substr(pos)    返回一个 string 类型的字符串，它包含从下标 pos 开始到 s 末尾的所有字符 </span><br><span class="line">s.substr()       返回 s 的副本</span><br></pre></td></tr></table></figure>
<p><strong>append和replace</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.append( args)           将 args 串接在 s 后面。返回 s 引用 </span><br><span class="line">s.replace(pos, len, args) 删除 s 中从下标 pos 开始的 len 个字符，用 args 指定的字符替换之。返回 s 的引用，在这个版本中，args 不能为 b2，e2 </span><br><span class="line">s.replace(b, e, args)     删除迭代器 b 和 e 标记范围内所有的字符，用 args 替换之。返回 s 的引用，在这个版本中，args 不能为 s2，pos2，len2</span><br></pre></td></tr></table></figure>
<p><strong>append和replace的args</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s2              string 类型的字符串 s2 </span><br><span class="line">s2, pos2, len2  字符串 s2 中从下标 pos2 开始的 len2 个字符 </span><br><span class="line">cp              指针 cp 指向的以空字符结束的数组 </span><br><span class="line">cp, len2        cp 指向的以空字符结束的数组中前 len2 个字符 </span><br><span class="line">n, c            字符 c 的 n 个副本 </span><br><span class="line">b2, e2          迭代器 b2 和 e2 标记的范围内所有字符</span><br></pre></td></tr></table></figure>
<p><strong>find</strong></p>
<p>string 类提供了6种查找函数，每种函数以不同形式的 find 命名。这些操作全都返回 string::size_type 类型的值，以下标形式标记查找匹配所发生的位置；或者返回一个名为 string::npos 的特殊值，说明查找没有匹配。string 类将 npos 定义为保证大于任何有效下标的值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.find( args)   在 s 中查找 args 的第一次出现 </span><br><span class="line">s.rfind( args)  在 s 中查找 args 的最后一次出现 </span><br><span class="line">s.find_first_of( args)   在 s 中查找 args 的任意字符的第一次出现 </span><br><span class="line">s.find_last_of( args)    在 s 中查找 args 的任意字符的最后一次出现</span><br><span class="line">s.find_first_not_of( args)  在 s 中查找第一个不属于 args 的字符 </span><br><span class="line">s.find_last_not_of( args)   在 s 中查找最后一个不属于 args 的字符</span><br></pre></td></tr></table></figure>
<p><strong>find的args</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c, pos      在 s 中，从下标 pos 标记的位置开始，查找字符 c。pos 的默认值为 0 </span><br><span class="line">s2, pos     在 s 中，从下标 pos 标记的位置开始，查找 string 对象 s2。pos 的默认值为 0 </span><br><span class="line">cp, pos     在 s 中，从下标 pos 标记的位置形参，查找指针 cp 所指向的 C 风格的以空字符结束的字符串。pos 的默认值为 0 </span><br><span class="line">cp, pos, n  在 s 中，从下标 pos 标记的位置开始，查找指针 cp 所指向数组的前 n 个字符。pos 和 n 都没有默认值</span><br></pre></td></tr></table></figure>
<p><strong>查找任意字符</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string numbers = &quot;0123456789&quot;;</span><br><span class="line">string str = &quot;ab5bz9&quot;;</span><br><span class="line">cout &lt;&lt; str.find_first_of(numbers);      //2</span><br></pre></td></tr></table></figure>
<p><strong>compare 函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.compare(s2)                        比较 s 和 s2 </span><br><span class="line">s.compare(pos1, n1, s2)              让 s 中从 pos 下标位置开始的 n1 个字符与 s2 做比较 </span><br><span class="line">s.compare(pos1, n1, s2, pos2, n2)    让 s 中从 pos1 下标位置开始的 n1 个字符与 s2 中从 pos2 下标位置开始的 n2 个字符做比较 </span><br><span class="line">s.compare(cp)               比较 s 和 cp 所指向的以空字符结束的字符串 </span><br><span class="line">s.compare(pos1, n1, cp)     让 s 中从 pos1 下标位置开始的 n1 个字符与 cp 所指向的字符串做比较 </span><br><span class="line">s.compare(pos1, n1, cp, n2) 让 s 中从 pos1 下标位置开始的 n1 个字符与 cp 所指向的字符串的前 n2 个字符做比较</span><br></pre></td></tr></table></figure>
<h2 id="9-7-容器适配器"><a href="#9-7-容器适配器" class="headerlink" title="9.7 容器适配器"></a>9.7 容器适配器</h2><p>除了顺序容器，标准库还提供了三种顺序容器适配器：<strong>queue</strong>、<strong>priority_queue</strong>和<strong>stack</strong>。适配器(adaptor)是标准库中通用的概念，包括容器适配器、迭代器适配器和函数适配器。本质上，适配器是使一事物的行为类似于另一事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;    // stack adaptor </span><br><span class="line">#include &lt;queue&gt;    // both queue and priority_queue adaptors</span><br></pre></td></tr></table></figure>
<p><strong>适配器的初始化</strong></p>
<p>所有适配器都定义了两个构造函数：默认构造函数用于创建空对象，而带一个容器参数的构造函数将参数容器的副本作为其基础值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deq(10);</span><br><span class="line">stack&lt;int&gt; mystack(deq);</span><br></pre></td></tr></table></figure>
<p><strong>覆盖基础容器类型</strong></p>
<p>默认的 stack 和 queue 都基于 deque 容器实现，而 priority_queue 则在 vector 容器上实现。在创建适配器时，通过将一个顺序容器指定为适配器的第二个类型实参，可覆盖其关联的基础容器类型： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec(10);</span><br><span class="line">stack&lt;int,vector&lt;int&gt;&gt; mystack(vec);</span><br></pre></td></tr></table></figure>
<p>对于给定的适配器，其关联的容器必须满足一定的约束条件。stack 适配器所关联的基础容器可以是任意一种顺序容器类型。因此，stack 栈可以建立在 vector、list 或者 deque 容器之上。而 queue 适配器要求其关联的基础容器必须提供 push_front 运算，因此只能建立在 list 容器上，而不能建立在 vector 容器上。priority_queue 适配器要求提供随机访问功能，因此可建立在 vector 或 deque 容器上，但不能建立在 list 容器上。 </p>
<h3 id="9-7-1-栈适配器"><a href="#9-7-1-栈适配器" class="headerlink" title="9.7.1 栈适配器"></a>9.7.1 栈适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.empty()     如果栈为空，则返回 true，否则返回 stack</span><br><span class="line">s.size()      返回栈中元素的个数 </span><br><span class="line">s.pop()       删除栈顶元素的值，但不返回其值 </span><br><span class="line">s.top()       返回栈顶元素的值，但不删除该元素</span><br><span class="line">s.push(item)  在栈顶压入新元素</span><br></pre></td></tr></table></figure>
<h3 id="9-7-2-队列和优先级队列"><a href="#9-7-2-队列和优先级队列" class="headerlink" title="9.7.2 队列和优先级队列"></a>9.7.2 队列和优先级队列</h3><p>priority_queue 允许用户为队列中存储的元素设置优先级。这种队列不是直接将新元素放置在队列尾部，而是放在比它优先级低的元素前面。标准库默认使用元素类型的 &lt; 操作符来确定它们之间的优先级关系。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.empty()     如果队列为空，则返回 true，否则返回 false </span><br><span class="line">q.size()      返回队列中元素的个数 </span><br><span class="line">q.pop()       删除队首元素，但不返回其值 </span><br><span class="line">q.front()     返回队首元素的值，但不删除该元素 该操作只适用于队列 </span><br><span class="line">q.back()      返回队尾元素的值，但不删除该元素 该操作只适用于队列 </span><br><span class="line">q.top()       返回具有最高优先级的元素值，但不删除该元素 该操作只适用于优先级队列 </span><br><span class="line">q.push(item)  对于 queue，在队尾压入一个新元素，对于 priority_quue，在基于优先级的适当位置插入新元素</span><br></pre></td></tr></table></figure>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C-Primer/">C++ Primer</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">ZYP</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
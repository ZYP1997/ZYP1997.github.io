<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++ Lesson10 | 空之境界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="ZYP">
  
  
    <meta name="description" content="第五章 表达式表达式由一个或多个操作数通过操作符组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。">
  
  <meta name="description" content="第五章 表达式表达式由一个或多个操作数通过操作符组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。">
<meta name="keywords" content="C++ Primer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Lesson10">
<meta property="og:url" content="https://zypsola.com/2018/10/24/C++Primer10/index.html">
<meta property="og:site_name" content="空之境界">
<meta property="og:description" content="第五章 表达式表达式由一个或多个操作数通过操作符组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-29T12:44:14.700Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Lesson10">
<meta name="twitter:description" content="第五章 表达式表达式由一个或多个操作数通过操作符组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。">
  
  
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">空之境界</a></h1>
    <p><a href="/">ZYP&#39;s Blog</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags/C#">C#</a></li>
      
        <li><a href="/tags/C-Primer">C++</a></li>
      
        <li><a href="/tags/Unity">Unity</a></li>
      
        <li><a href="/tags/Z720">Z720</a></li>
      
        <li><a href="/tags/Others">Others</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2018/10/24/C++Primer10/">
  <time datetime="2018-10-24T07:07:09.000Z">
    2018-10-24
  </time>
</a>
    
    
  
    <h1 class="title">C++ Lesson10</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="第五章-表达式"><a href="#第五章-表达式" class="headerlink" title="第五章 表达式"></a>第五章 表达式</h1><p>表达式由一个或多个<strong>操作数</strong>通过<strong>操作符</strong>组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。</p>
<a id="more"></a>
<p>除了特殊用法外，表达式的结果是右值，可以读取该结果值，但是不允许对它进行赋值。 </p>
<p>C++提供了一元操作符和二元操作符两种操作符。作用在一个操作数上的操作符称为一元操作符,如取地址操作符（&amp;）和解引用操作符（*）；而二元操作符则作用于两个操作数上。除此之外，C++ 还提供了一个使用三个操作数的三元操作符。</p>
<p>对于操作数为内置或复合类型的二元操作符，通常要求它的两个操作数具有相同的数据类型，或者其类型可以转换为同一种数据类型。</p>
<p>要理解由多个操作符组成的表达式，必须先理解操作符的<strong>优先级</strong>、<strong>结合性</strong>和操作数的<strong>求值顺序</strong>。</p>
<h2 id="5-1-算术操作符"><a href="#5-1-算术操作符" class="headerlink" title="5.1 算术操作符"></a>5.1 算术操作符</h2><p>按优先级来对操作符进行分组——一元操作符优先级最高，其次是乘、除操作，接着是二元的加、减法操作。高优先级的操作符要比低优先级的结合得更紧密。这些算术操作符都是左结合，这就意味着当操作符的优先级相同时，这些操作符从左向右依次与操作数结合。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+      一元正号    + expr </span><br><span class="line">-      一元负号    - expr </span><br><span class="line">*      乘法      expr * expr</span><br><span class="line">/      除法      expr / expr</span><br><span class="line">%      求余      expr % expr</span><br><span class="line">+      加法      expr + expr</span><br><span class="line">-      减法      expr - expr</span><br></pre></td></tr></table></figure>
<p>如果两个操作数为正，除法（/）和求模（%）操作的结果也是正数（或零）；如果两个操作数都是负数，除法操作的结果为正数（或零），而求模操作的结果则为负数（或零）；如果只有一个操作数为负数，这两种操作的结果取决于机器；求模结果的符号也取决于机器，而除法操作的值则是负数（或零）： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-21 % -8; //  ok: result is -5 </span><br><span class="line">21 % -5;  //  machine-dependent: result is 1 or -4 </span><br><span class="line">-21 / -8; //  ok: result is 2 </span><br><span class="line">21 / -5;  //  machine-dependent: result is -4 or -5</span><br></pre></td></tr></table></figure>
<h2 id="5-2-关系操作符和逻辑操作符"><a href="#5-2-关系操作符和逻辑操作符" class="headerlink" title="5.2 关系操作符和逻辑操作符"></a>5.2 关系操作符和逻辑操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!        逻辑非     !expr </span><br><span class="line">&lt;        小于       expr &lt; expr</span><br><span class="line">&lt;=       小于等于   expr &lt;= expr</span><br><span class="line">&gt;        大于       expr &gt; expr</span><br><span class="line">&gt;=       大于等于   expr &gt;= expr</span><br><span class="line">==       相等       expr == expr</span><br><span class="line">!=       不等       expr != expr</span><br><span class="line">&amp;&amp;       逻辑与     expr &amp;&amp; expr</span><br><span class="line">||       逻辑或     expr || expr</span><br></pre></td></tr></table></figure>
<p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们常常称这种求值策略为“短路求值（short-circuit evaluation）”。 </p>
<h2 id="5-3-位操作符"><a href="#5-3-位操作符" class="headerlink" title="5.3 位操作符"></a>5.3 位操作符</h2><p>位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能。另外，这类操作符还可用于 bitset 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~    bitwise NOT（位求反）  ~expr </span><br><span class="line">&lt;&lt;    left shift（左移）    expr1 &lt;&lt; expr2</span><br><span class="line">&gt;&gt;    right shift（右移）   expr1 &gt;&gt; expr2</span><br><span class="line">&amp;    bitwise AND（位与）    expr1 &amp; expr2</span><br><span class="line">^    bitwise XOR（位异或）  expr1 ^ expr2</span><br><span class="line">|    bitwise OR（位或）     expr1 | expr2</span><br></pre></td></tr></table></figure>
<p>位操作符操纵的整数的类型可以是有符号的也可以是无符号的。如果操作数为负数，则位操作符如何处理其操作数的符号位依赖于机器。</p>
<p>移位操作的右操作数不可以是负数，而且必须是严格小于左操作数位数的值。否则，操作的效果未定义。 </p>
<h2 id="5-4-赋值操作符"><a href="#5-4-赋值操作符" class="headerlink" title="5.4 赋值操作符"></a>5.4 赋值操作符</h2><p>赋值操作符的左操作数必须是非 const 的左值。</p>
<h3 id="5-4-1-赋值操作的右结合性"><a href="#5-4-1-赋值操作的右结合性" class="headerlink" title="5.4.1 赋值操作的右结合性"></a>5.4.1 赋值操作的右结合性</h3><p>C++语言允许将这多个赋值操作写在一个表达式中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">float b;</span><br><span class="line">a = b = 4.345;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;     //result: 4 4.345</span><br></pre></td></tr></table></figure>
<h3 id="5-4-2-赋值操作具有低优先级"><a href="#5-4-2-赋值操作具有低优先级" class="headerlink" title="5.4.2 赋值操作具有低优先级"></a>5.4.2 赋值操作具有低优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i; </span><br><span class="line">while ((i = get_value()) != 42) &#123; </span><br><span class="line">    // do something ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。 </p>
<h3 id="5-4-3-复合赋值操作符"><a href="#5-4-3-复合赋值操作符" class="headerlink" title="5.4.3 复合赋值操作符"></a>5.4.3 复合赋值操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+=   -=   *=   /=   %=   // arithmetic operators </span><br><span class="line">&lt;&lt;= &gt;&gt;=   &amp;=   ^=   |=   // bitwise operators</span><br></pre></td></tr></table></figure>
<h2 id="5-5-增和自减操作符"><a href="#5-5-增和自减操作符" class="headerlink" title="5.5 增和自减操作符"></a>5.5 增和自减操作符</h2><p>自增（++）和自减（–）操作符为对象加 1 或减 1 操作提供了方便简短的实现方式。它们有前置和后置两种使用形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, j; </span><br><span class="line">j = ++i; // j = 1, i = 1</span><br><span class="line">j = i++; // j = 1, i = 2</span><br></pre></td></tr></table></figure>
<p>前置操作返回加 1 后的值，所以返回对象本身，这是左值。而后置操作返回的则是右值。 </p>
<p><strong>在单个表达式中组合使用解引用和自增操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123; 10,20,30 &#125;,&#123; 40,50,60 &#125; &#125;;</span><br><span class="line">int(*p)[3] = a;</span><br><span class="line">cout &lt;&lt; **p &lt;&lt; endl;    //result: 10</span><br><span class="line">cout &lt;&lt; *((*p) + 1) &lt;&lt; endl;    //result: 20</span><br><span class="line">cout &lt;&lt; *((*++p) + 1) &lt;&lt; endl;  //result: 50</span><br></pre></td></tr></table></figure>
<h2 id="5-6-箭头操作符"><a href="#5-6-箭头操作符" class="headerlink" title="5.6 箭头操作符"></a>5.6 箭头操作符</h2><p>C++ 语言为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（-&gt;）。点操作符用于获取类类型对象的成员： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.same_isbn(item2);</span><br></pre></td></tr></table></figure>
<p>如果有一个指向 Sales_item 对象的指针（或迭代器），则在使用点操作符前，需对该指针（或迭代器）进行解引用： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item *sp = &amp;item1; </span><br><span class="line">(*sp).same_isbn(item2);</span><br></pre></td></tr></table></figure>
<p>必须用圆括号把解引用括起来，因为解引用的优先级低于点操作符。</p>
<p>C++ 为在点操作符后使用的解引用操作定义了一个同义词：箭头操作符（-&gt;）。假设有一个指向类类型对象的指针（或迭代器），下面的表达式相互等价： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p).foo;</span><br><span class="line">p-&gt;foo;</span><br></pre></td></tr></table></figure>
<h2 id="5-7-条件操作符"><a href="#5-7-条件操作符" class="headerlink" title="5.7 条件操作符"></a>5.7 条件操作符</h2><p>条件操作符是 C++ 中唯一的三元操作符，它允许将简单的 if-else 判断语句嵌入表达式中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<p>无论如何，cond 总是要被计算的。然后，条件为 true 时计算 expr1 ，否则计算 expr2 。expr1 和 expr2 中只有一个表达式被计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1, j = 2, k = 3;</span><br><span class="line">int maxij = i &gt; j ? i : j;</span><br><span class="line">int maxijk = i &gt; j ?</span><br><span class="line">	i &gt; k ? i : k :</span><br><span class="line">	j &gt; k ? j : k;</span><br></pre></td></tr></table></figure>
<h2 id="5-8-sizeof操作符"><a href="#5-8-sizeof操作符" class="headerlink" title="5.8 sizeof操作符"></a>5.8 sizeof操作符</h2><p>sizeof 操作符的作用是返回一个对象或类型名的长度，返回值的类型为 size_t，长度的单位是字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof (type name); </span><br><span class="line">sizeof (expr); </span><br><span class="line">sizeof expr;</span><br></pre></td></tr></table></figure>
<p>将 sizeof 应用在表达式 expr 上，将获得该表达式的结果的类型长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double a[10];</span><br><span class="line">double *p = a;</span><br><span class="line">cout &lt;&lt; sizeof(double) &lt;&lt; endl   //8</span><br><span class="line">	&lt;&lt; sizeof a &lt;&lt; endl          //80</span><br><span class="line">	&lt;&lt; sizeof *p &lt;&lt; endl         //8</span><br><span class="line">	&lt;&lt; sizeof(4 + 1.2) &lt;&lt; endl   //8</span><br><span class="line">	&lt;&lt; sizeof p &lt;&lt; endl;         //4</span><br></pre></td></tr></table></figure>
<h2 id="5-9-逗号操作符"><a href="#5-9-逗号操作符" class="headerlink" title="5.9 逗号操作符"></a>5.9 逗号操作符</h2><p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。如果最右边的操作数是左值，则逗号表达式的值也是左值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   int a = (222 + 333, 66);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;          //66</span><br><span class="line">int b = 55;</span><br><span class="line">(b++, a = 77)++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        //78 56</span><br></pre></td></tr></table></figure>
<h2 id="5-10-复合表达式的求值"><a href="#5-10-复合表达式的求值" class="headerlink" title="5.10 复合表达式的求值"></a>5.10 复合表达式的求值</h2><p>含有两个或更多操作符的表达式称为<strong>复合表达式</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (ia[index++] &lt; ia[index])</span><br></pre></td></tr></table></figure>
<p>此表达式的行为没有明确定义。问题在于：&lt; 操作符的左右操作数都使用了 index 变量，但是，左操作数更改了该变量的值。假设 index 初值为 0，编译器可以用下面两种方式之一求该表达式的值： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (ia[0] &lt; ia[0]) // execution if rhs is evaluated first </span><br><span class="line">if (ia[0] &lt; ia[1]) // execution if lhs is evaluated first</span><br></pre></td></tr></table></figure>
<h2 id="5-11-new-和-delete-表达式"><a href="#5-11-new-和-delete-表达式" class="headerlink" title="5.11 new 和 delete 表达式"></a>5.11 new 和 delete 表达式</h2><p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new 表达式返回指向新创建对象的指针，我们通过该指针来访问此对象： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pi = new int;</span><br></pre></td></tr></table></figure>
<p><strong>动态创建对象的初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *pi = new int(1024); </span><br><span class="line">string *ps = new string(10, &apos;9&apos;);</span><br></pre></td></tr></table></figure>
<p><strong>动态创建对象的默认初始化</strong></p>
<p>如果不提供显式初始化，动态创建的对象与在函数内定义的变量初始化方式相同。对于类类型的对象，用该类的默认构造函数初始化；而内置类型的对象则无初始化。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = new int();     //初始化为0</span><br><span class="line">int *p2 = new int;       //未初始化</span><br></pre></td></tr></table></figure>
<p><strong>撤销动态创建的对象</strong></p>
<p>动态创建的对象用完后，程序员必须显式地将该对象占用的内存返回给自由存储区。C++ 提供了 delete 表达式释放指针所指向的地址空间。 </p>
<p>如果指针指向不是用 new 分配的内存地址，则在该指针上使用 delete 是不合法的。 </p>
<p><strong>零值指针的删除</strong></p>
<p>如果指针的值为 0，则在其上做 delete 操作是合法的，但这样做没有任何意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ip = 0; </span><br><span class="line">delete ip;</span><br></pre></td></tr></table></figure>
<p>C++ 保证：删除 0 值的指针是安全的。</p>
<p><strong>在delete之后，重设指针的值</strong></p>
<p>执行语句delete p; 后，p 变成没有定义。在很多机器上，尽管 p 没有定义，但仍然存放了它之前所指向对象的地址，然而 p 所指向的内存已经被释放，因此 p 不再有效。 </p>
<p>删除指针后，该指针变成悬垂指针。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。 </p>
<p>一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清楚地表明指针不再指向任何对象。 </p>
<p><strong>const对象的动态分配和回收</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int *pci = new const int(1024)</span><br></pre></td></tr></table></figure>
<p>与其他常量一样，动态创建的 const 对象必须在创建时初始化，并且一经初始化，其值就不能再修改。</p>
<p>对于类类型的 const 动态对象，如果该类提供了默认的构造函数，则此对象可隐式初始化： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const string *pcs = new const string;</span><br></pre></td></tr></table></figure>
<h2 id="5-12-类型转换"><a href="#5-12-类型转换" class="headerlink" title="5.12 类型转换"></a>5.12 类型转换</h2><p>在 C++ 中，某些类型之间存在相关的依赖关系。若两种类型相关，则可在需要某种类型的操作数位置上，使用该类型的相关类型对象或值。如果两个类型之间可以相互转换，则称这两个类型相关。 </p>
<h3 id="5-12-1-何时发生隐式类型转换"><a href="#5-12-1-何时发生隐式类型转换" class="headerlink" title="5.12.1 何时发生隐式类型转换"></a>5.12.1 何时发生隐式类型转换</h3><ol>
<li>在混合类型的表达式中，其操作数被转换为相同的类型</li>
<li>用作条件的表达式被转换为 bool 类型</li>
<li>用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量的类型</li>
</ol>
<p>另外，在函数调用中也可能发生隐式类型转换。</p>
<h3 id="5-12-2-算术转换"><a href="#5-12-2-算术转换" class="headerlink" title="5.12.2 算术转换"></a>5.12.2 算术转换</h3><p>算术转换规则定义了一个类型转换层次，该层次规定了操作数应按什么次序转换为表达式中最宽的类型。</p>
<p>若表达式中使用了unsigned数值，所定义的转换规则需保护操作数的精度。unsigned 操作数的转换依赖于机器中整型的相对大小，因此，这类转换本质上依赖于机器。 </p>
<h3 id="5-12-3-其他隐式转换"><a href="#5-12-3-其他隐式转换" class="headerlink" title="5.12.3 其他隐式转换"></a>5.12.3 其他隐式转换</h3><p><strong>指针转换</strong></p>
<p>在使用数组时，大多数情况下数组都会自动转换为指向第一个元素的指针。</p>
<p>指向任意数据类型的指针都可转换为 void* 类型；整型数值常量 0 可转换为任意指针类型。 </p>
<p><strong>转换为bool类型</strong></p>
<p>算术值和指针值都可以转换为 bool 类型。如果指针或算术值为 0，则其 bool 值为 false ，而其他值则为 true。</p>
<p><strong>算术类型与bool类型的转换</strong></p>
<p>可将算术对象转换为 bool 类型，bool 对象也可转换为 int 型。将算术类型转换为 bool 型时，零转换为 false ，而其他值则转换为 true 。将 bool 对象转换为算术类型时，true 变成 1，而 false 则为 0。</p>
<p><strong>转换与枚举类型</strong></p>
<p>C++ 自动将枚举类型的对象或枚举成员转换为整型，其转换结果可用于任何要求使用整数值的地方。</p>
<h3 id="5-12-4-显式转换"><a href="#5-12-4-显式转换" class="headerlink" title="5.12.4 显式转换"></a>5.12.4 显式转换</h3><p>显式转换也称为强制类型转换（cast），包括以下列名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。 </p>
<h3 id="5-12-5-何时需要强制类型转换"><a href="#5-12-5-何时需要强制类型转换" class="headerlink" title="5.12.5 何时需要强制类型转换"></a>5.12.5 何时需要强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">double b = 3.99;</span><br><span class="line">cout &lt;&lt; a*static_cast&lt;int&gt;(b) &lt;&lt; endl;    //9</span><br><span class="line">cout &lt;&lt; a*b &lt;&lt; endl;           //11.97</span><br></pre></td></tr></table></figure>
<p>显式使用强制类型转换的另一个原因是：可能存在多种转换时，需要选择一种特定的类型转换。</p>
<h3 id="5-12-6-命名的强制类型转换"><a href="#5-12-6-命名的强制类型转换" class="headerlink" title="5.12.6 命名的强制类型转换"></a>5.12.6 命名的强制类型转换</h3><p><strong>dynamic_cast</strong>:支持运行时识别指针或引用所指向的对象。</p>
<p><strong>const_cast</strong>:转换掉表达式的 const 性质。例如，假设有函数 string_copy，只有唯一的参数，为 char<em> 类型，我们对该函数只读不写。在访问该函数时，最好的选择是修改它让它接受 const char</em> 类型的参数。如果不行，可通过 const_cast 用一个 const 值调用 string_copy 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char* sc(char *p1)</span><br><span class="line">&#123;</span><br><span class="line">	p1 = new char(&apos;c&apos;);</span><br><span class="line">	char *p2 = p1;</span><br><span class="line">	return p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	const char *p = new char(&apos;a&apos;);</span><br><span class="line">	char *p2 = sc(const_cast&lt;char*&gt;(p));</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *p2 &lt;&lt; endl;       //a c</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>static_cast</strong>:编译器隐式执行的任何类型转换都可以由 static_cast 显式完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a(1.23);</span><br><span class="line">void *p = &amp;a;</span><br><span class="line">cout &lt;&lt; *(static_cast&lt;double*&gt;(p)) &lt;&lt; endl;   //1.23</span><br></pre></td></tr></table></figure>
<p><strong>reinterpret_cast</strong>:reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *ip = new int(65);</span><br><span class="line">char *cp = reinterpret_cast&lt;char*&gt;(ip);</span><br><span class="line">cout &lt;&lt; *cp &lt;&lt; endl;    //A</span><br></pre></td></tr></table></figure>
<h3 id="5-12-7-旧式强制类型转换"><a href="#5-12-7-旧式强制类型转换" class="headerlink" title="5.12.7 旧式强制类型转换"></a>5.12.7 旧式强制类型转换</h3><p>在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现。</p>
<p>旧式强制转换符号有下列两种形式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (expr); // Function-style cast notation </span><br><span class="line">(type) expr; // C-language-style cast notation</span><br></pre></td></tr></table></figure>
<p>旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。</p>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C-Primer/">C++ Primer</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">ZYP</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++ Lesson6 | 空之境界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="ZYP">
  
  
    <meta name="description" content="第三章 标准库类型3.3 标准库 vector 类型vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。">
  
  <meta name="description" content="第三章 标准库类型3.3 标准库 vector 类型vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。">
<meta name="keywords" content="C++ Primer,vecter">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Lesson6">
<meta property="og:url" content="https://zypsola.com/2018/10/22/C++Primer6/index.html">
<meta property="og:site_name" content="空之境界">
<meta property="og:description" content="第三章 标准库类型3.3 标准库 vector 类型vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-02T11:53:54.227Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Lesson6">
<meta name="twitter:description" content="第三章 标准库类型3.3 标准库 vector 类型vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。">
  
  
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">空之境界</a></h1>
    <p><a href="/">ZYP&#39;s Blog</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags/C#">C#</a></li>
      
        <li><a href="/tags/C-Primer">C++</a></li>
      
        <li><a href="/tags/Unity">Unity</a></li>
      
        <li><a href="/tags/算法">算法</a></li>
      
        <li><a href="/tags/Others">Others</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2018/10/22/C++Primer6/">
  <time datetime="2018-10-22T13:22:19.000Z">
    2018-10-22
  </time>
</a>
    
    
  
    <h1 class="title">C++ Lesson6</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><h2 id="3-3-标准库-vector-类型"><a href="#3-3-标准库-vector-类型" class="headerlink" title="3.3 标准库 vector 类型"></a>3.3 标准库 vector 类型</h2><p><strong>vector</strong> 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为<strong>容器</strong>，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt; </span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure>
<p>vector 是一个<strong>类模板（class template）</strong>。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。因此，我们可以定义保存 string 对象的 vector，或保存 int 值的 vector，又或是保存自定义的类类型对象（如 Sales_items 对象）的 vector。</p>
<p>声明从类模板产生的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以 vector 为例，必须说明 vector 保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;               // ivec holds objects of type int </span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;   // holds Sales_items</span><br></pre></td></tr></table></figure>
<p>vector 不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，vector&lt;int&gt; 和 vector&lt;string&gt; 都是数据类型。</p>
<h3 id="3-3-1-vector对象的定义和初始化"><a href="#3-3-1-vector对象的定义和初始化" class="headerlink" title="3.3.1 vector对象的定义和初始化"></a>3.3.1 vector对象的定义和初始化</h3><p>vector 类定义了好几种构造函数，用来定义和初始化 vector 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;        \\vector 保存类型为 T 对象。 默认构造函数 v1 为空。 </span><br><span class="line">vector&lt;T&gt; v2(v1);    \\v2 是 v1 的一个副本。 </span><br><span class="line">vector&lt;T&gt; v3(n, i);  \\v3 包含 n 个值为 i 的元素。 </span><br><span class="line">vector&lt;T&gt; v4(n);     \\v4 含有值初始化的元素的 n 个副本。</span><br></pre></td></tr></table></figure>
<p><strong>创建确定个数的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec1;           // ivec1 holds objects of type int </span><br><span class="line">vector&lt;int&gt; ivec2(ivec1);    // ok: copy elements of ivec1 into ivec2 </span><br><span class="line">vector&lt;string&gt; svec(ivec1);  // error: svec holds strings, not ints </span><br><span class="line">vector&lt;int&gt; ivec4(10, -1);       // 10 elements, each initialized to -1 </span><br><span class="line">vector&lt;string&gt; svec(10, &quot;hi!&quot;);  // 10 strings, each initialized to &quot;hi!&quot;</span><br></pre></td></tr></table></figure>
<p>虽然可以对给定元素个数的 vector 对象预先分配内存，但更有效的方法是先初始化一个空 vector 对象，然后再动态地增加元素。</p>
<p><strong>值初始化</strong></p>
<p>如果没有指定元素的初始化式，那么标准库将自行提供一个元素初始值进行值初始化（value initializationd）。这个由库生成的初始值将用来初始化容器中的每个元素，具体值为何，取决于存储在 vector 中元素的数据类型。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fvec(10); // 10 elements, each initialized to 0 </span><br><span class="line">vector&lt;string&gt; svec(10); // 10 elements, each an empty string</span><br></pre></td></tr></table></figure>
<p>一些有自定义构造函数但没有默认构造函数的类，在初始化这种类型的 vector 对象时，程序员就不能仅提供元素个数，还需要提供元素初始值。 </p>
<h3 id="3-3-2-vector对象的操作"><a href="#3-3-2-vector对象的操作" class="headerlink" title="3.3.2 vector对象的操作"></a>3.3.2 vector对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v.empty()       如果 v 为空，则返回 true，否则返回 false。 </span><br><span class="line">v.size()        返回 v 中元素的个数。 </span><br><span class="line">v.push_back(t)  在 v 的末尾增加一个值为 t 的元素。 </span><br><span class="line">v[n]            返回 v 中位置为 n 的元素。 </span><br><span class="line">v1 = v2         把 v1 的元素替换为 v2 中元素的副本。 </span><br><span class="line">v1 == v2        如果 v1 与 v2 相等，则返回 true。 </span><br><span class="line">!=, &lt;, &lt;=,  &gt;, and &gt;=       保持这些操作符惯有的含义。</span><br></pre></td></tr></table></figure>
<p>成员函数 size 返回相应 vector 类定义的 size_type 的值。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::size_type       // ok </span><br><span class="line">vector::size_type            // error</span><br></pre></td></tr></table></figure>
<p><strong>下标操作不添加元素</strong></p>
<h2 id="3-4-迭代器简介"><a href="#3-4-迭代器简介" class="headerlink" title="3.4 迭代器简介"></a>3.4 迭代器简介</h2><p>除了使用下标来访问 vector 对象的元素外，标准库还提供了另一种访问元素的方法：使用<strong>迭代器（iterator）</strong>。迭代器是一种检查容器内元素并遍历元素的数据类型。 </p>
<p>标准库为每一种标准容器（包括 vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代 C++ 程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的 vector 类型也是这样。 </p>
<p><strong>容器的iterator类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator iter;</span><br></pre></td></tr></table></figure>
<p>这符语句定义了一个名为 iter 的变量，它的数据类型是 vector&lt;int&gt; 定义的 iterator 类型。每个标准库容器类型都定义了一个名为 iterator 的成员，这里的 iterator 与迭代器实际类型的含义相同。 </p>
<p><strong>begin和end操作</strong></p>
<p>由 begin 返回的迭代器指向第一个元素;由 end 操作返回的迭代器指向 vector 的“末端元素的下一个”。如果 vector 为空，begin 返回的迭代器与 end 返回的迭代器相同。 </p>
<p>由 end 操作返回的迭代器并不指向 vector 中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完 vector 中所有元素。 </p>
<p><strong>vector迭代器的自增和解引用运算</strong></p>
<p>迭代器类型可使用<strong>解引用操作符</strong>（dereference operator）（*）来访问迭代器所指向的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*iter = 0;</span><br></pre></td></tr></table></figure>
<p>由于 end 操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。 </p>
<p>另一对可执行于迭代器的操作就是比较：用 == 或 != , &gt; , &lt; , &lt;= , &gt;= 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。 </p>
<p><strong>const_iterator</strong></p>
<p>前面的程序用 vector::iterator 改变 vector 中的元素值。每种容器类型还定义了一种名为 const_iterator 的类型，该类型只能用于读取容器内元素，但不能改变其值。 </p>
<p>不要把 const_iterator 对象与 const 的 iterator 对象混淆起来。声明一个 const 迭代器时，必须初始化迭代器。一旦被初始化后，就不能改变它的值。</p>
<p>const_iterator 对象可以用于 const vector 或非 const vector，因为不能改写元素值。const 迭代器这种类型几乎没什么用处：一旦它被初始化后，只能用它来改写其指向的元素，但不能使它指向任何其他元素。 </p>
<h3 id="3-4-1-迭代器的算术操作"><a href="#3-4-1-迭代器的算术操作" class="headerlink" title="3.4.1 迭代器的算术操作"></a>3.4.1 迭代器的算术操作</h3><p>除了一次移动迭代器的一个元素的增量操作符外，vector 迭代器（其他标准库容器迭代器很少）也支持其他的算术操作。这些操作称为迭代器算术操作（iterator arithmetic）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter + n;</span><br><span class="line">iter - n;</span><br><span class="line">iter1 - iter2;</span><br></pre></td></tr></table></figure>
<p>该表达式用来计算两个迭代器对象的距离，该距离是名为 difference_type 的 signed 类型 size_type 的值，这里的 difference_type 是 signed 类型，因为减法运算可能产生负数的结果。该类型可以保证足够大以存储任何两个迭代器对象间的距离。两个迭代器相加的操作是未定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::difference_type dis;</span><br></pre></td></tr></table></figure>
<p>任何改变 vector 长度的操作都会使已存在的迭代器失效。例如，在调用 push_back 之后，就不能再信赖指向 vector 的迭代器的值了。 </p>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C-Primer/">C++ Primer</a>, <a class="tags-link" href="/tags/vecter/">vecter</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2019 <a href="/">ZYP</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
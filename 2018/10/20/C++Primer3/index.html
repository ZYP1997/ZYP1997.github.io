<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++ Lesson3 | 空之境界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="ZYP">
  
  
    <meta name="description" content="第二章 变量和基本类型2.3 变量C++ 是一门静态类型语言，在编译时会作类型检查。 
在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。">
  
  <meta name="description" content="第二章 变量和基本类型2.3 变量C++ 是一门静态类型语言，在编译时会作类型检查。  在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。">
<meta name="keywords" content="C++ Primer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Lesson3">
<meta property="og:url" content="https://zypsola.com/2018/10/20/C++Primer3/index.html">
<meta property="og:site_name" content="空之境界">
<meta property="og:description" content="第二章 变量和基本类型2.3 变量C++ 是一门静态类型语言，在编译时会作类型检查。  在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-31T16:35:23.805Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Lesson3">
<meta name="twitter:description" content="第二章 变量和基本类型2.3 变量C++ 是一门静态类型语言，在编译时会作类型检查。  在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。">
  
  
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">空之境界</a></h1>
    <p><a href="/">ZYP&#39;s Blog</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags/C#">C#</a></li>
      
        <li><a href="/tags/C-Primer">C++</a></li>
      
        <li><a href="/tags/Unity">Unity</a></li>
      
        <li><a href="/tags/Z720">Z720</a></li>
      
        <li><a href="/tags/Others">Others</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2018/10/20/C++Primer3/">
  <time datetime="2018-10-20T12:27:10.000Z">
    2018-10-20
  </time>
</a>
    
    
  
    <h1 class="title">C++ Lesson3</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>C++ 是一门静态类型语言，在编译时会作类型检查。 </p>
<p>在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。 </p>
<a id="more"></a>
<p>在 C++ 中，操作是否合法是在编译时检查的。当编写表达式时，编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话，那么编译器会提示错误，而不产生可执行文件。 </p>
<p>随着程序和使用的类型变得越来越复杂，我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此，程序中使用变量前必须先定义变量的类型 </p>
<h3 id="2-3-1-什么是变量"><a href="#2-3-1-什么是变量" class="headerlink" title="2.3.1 什么是变量"></a>2.3.1 什么是变量</h3><p>变量提供了程序可以操作的有名字的存储区。C++ 中的每一个变量都有特定的类型，该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。C++ 程序员常常把变量称为“变量”或“对象（object）”。 </p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a><strong>左值和右值</strong></h3><p><strong>左值（lvalue）</strong>：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。++i是左值。<br><strong>右值（rvalue）</strong>：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。i++是右值。</p>
<p><strong>什么是对象？</strong></p>
<p>C++ 程序员经常随意地使用术语对象。一般而言，对象就是内存中具有类型的区域。说得更具体一些，计算左值表达式就会产生对象。 </p>
<p>严格地说，有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象，当谈到有名字的对象时一般指变量。还有一些人区分对象和值，用术语对象描述可被程序改变的数据，用术语值描述只读数据。 </p>
<p>在本书中，我们遵循更为通用的用法，即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据，而不管这些数据是内置类型还是类类型，是有名字的还是没名字的，是可读的还是可写的。 </p>
<h3 id="2-3-2-变量名"><a href="#2-3-2-变量名" class="headerlink" title="2.3.2 变量名"></a>2.3.2 变量名</h3><p>变量名，即变量的<strong>标识符</strong>，可以由字母、数字和下划线组成。变量名必须以字母或下划线开头，并且区分大小写字母：C++ 中的标识符都是大小写敏感的。</p>
<p>C++ 保留了一组词用作该语言的关键字。关键字不能用作程序的标识符。</p>
<p>C++ 还保留了一些词用作各种操作符的替代名。这些替代名用于支持某些不支持标准 C++操作符号集的字符集。它们也不能用作标识符。</p>
<h3 id="2-3-3-定义对象"><a href="#2-3-3-定义对象" class="headerlink" title="2.3.3 定义对象"></a>2.3.3 定义对象</h3><p><strong>初始化</strong><br>变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时指定了初始值的对象被称为是<strong>已初始化的</strong>。C++ 支持两种初始化变量的形式：<strong>复制初始化</strong>和<strong>直接初始化</strong>。复制初始化语法用等号（=），直接初始化则是把初始化式放在括号中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival(1024);     // direct-initialization </span><br><span class="line">int ival = 1024;    // copy-initialization</span><br></pre></td></tr></table></figure>
<p>在 C++ 中理解“初始化不是赋值”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。 </p>
<p>当初始化类类型对象时，复制初始化和直接初始化之间的差别是很微妙的，直接初始化语法更灵活且效率更高。 </p>
<h3 id="2-3-4-变量初始化规则"><a href="#2-3-4-变量初始化规则" class="headerlink" title="2.3.4 变量初始化规则"></a>2.3.4 变量初始化规则</h3><p>内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，<strong>未初始化</strong>变量用作任何其他用途都是没有定义的。</p>
<h3 id="2-3-4-声明和定义"><a href="#2-3-4-声明和定义" class="headerlink" title="2.3.4 声明和定义"></a>2.3.4 声明和定义</h3><p>C++ 程序通常由许多文件组成。为了让多个文件访问相同的变量，C++ 区分了声明和定义。 </p>
<p>变量的<strong>定义</strong>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。 </p>
<p><strong>声明</strong>用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用 extern 关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字 extern：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i;   // declares but does not define i </span><br><span class="line">int i;          //  declares and defines i</span><br></pre></td></tr></table></figure>
<p>extern 声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。<strong>程序中变量可以声明多次，但只能定义一次。</strong></p>
<p>只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为 extern：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern double pi = 3.1416; // definition</span><br></pre></td></tr></table></figure>
<p>虽然使用了 extern ，但是这条语句还是定义了 pi，分配并初始化了存储空间。只有当 extern 声明位于函数外部时，才可以含有初始化式。 </p>
<p>任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。 </p>
<h3 id="2-3-6-名字的作用域"><a href="#2-3-6-名字的作用域" class="headerlink" title="2.3.6 名字的作用域"></a>2.3.6 名字的作用域</h3><p><strong>C++ 中作用域可嵌套</strong></p>
<h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>const 把一个对象转换成一个常量。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512; // input buffer size</span><br></pre></td></tr></table></figure>
<p>定义 bufSize 为常量并初始化为 512。变量 bufSize 仍然是一个左值，但是现在这个左值是不可修改的。任何修改 bufSize 的尝试都会导致编译错误。</p>
<p>因为常量在定义后就不能被修改，所以定义时必须初始化。</p>
<p><strong>const 对象默认为文件的局部变量</strong></p>
<p>在全局作用域里定义非 const 变量时，它在整个程序中都可以访问。与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。</p>
<p>通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// file_1.cc </span><br><span class="line">extern const int bufSize = fcn(); </span><br><span class="line">// file_2.cc </span><br><span class="line">extern const int bufSize;</span><br><span class="line">for (int index = 0; index != bufSize; ++index)</span><br></pre></td></tr></table></figure>
<p>非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须地指定它为 extern。 </p>
<h2 id="2-5-引用"><a href="#2-5-引用" class="headerlink" title="2.5 引用"></a>2.5 引用</h2><p><strong>引用</strong>就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。</p>
<p>引用是一种<strong>复合类型</strong>，通过在变量名前添加“&amp;”符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义任何其他类型的引用</p>
<p>引用必须用与该引用同类型的对象初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024; </span><br><span class="line">int &amp;refVal = ival; // ok: refVal refers to ival </span><br><span class="line">int &amp;refVal2;       // error: a reference must be initialized </span><br><span class="line">int &amp;refVal3 = 10;  // error: initializer must be an object</span><br></pre></td></tr></table></figure>
<p><strong>引用是别名</strong></p>
<p>因为引用只是它绑定的对象的另一名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。</p>
<p><strong>const 引用</strong>是指向 const 对象的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ival = 1024; </span><br><span class="line">const int &amp;refVal = ival;      // ok: both reference and object are const </span><br><span class="line">int &amp;ref2 = ival;              // error: non const reference to a const objec</span><br></pre></td></tr></table></figure>
<p>const 引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 42; </span><br><span class="line">//  legal for const references only </span><br><span class="line">const int &amp;r = 42; </span><br><span class="line">const int &amp;r2 = r + i;</span><br></pre></td></tr></table></figure>
<p>同样的初始化对于非 const 引用却是不合法的，而且会导致编译时错误。</p>
<p>观察将引用绑定到不同的类型时所发生的事情，最容易理解上述行为。假如我们编写： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14; </span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<p>编译器会把这些代码转换成如以下形式的编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int temp = dval;        // create temporary int from the double </span><br><span class="line">const int &amp;ri = temp;   // bind ri to that temporary</span><br></pre></td></tr></table></figure>
<p>如果 ri 不是 const，那么可以给 ri 赋一新值。这样做不会修改 dval，而是修改了 temp。期望对 ri 的赋值会修改 dval 的程序员会发现 dval 并没有被修改。仅允许 const 引用绑定到需要临时使用的值完全避免了这个问题，因为 const 引用是只读的。</p>
<p>非 const 引用只能绑定到与该引用同类型的对象。</p>
<p>const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</p>
<h2 id="2-6-typedef-名字"><a href="#2-6-typedef-名字" class="headerlink" title="2.6 typedef 名字"></a>2.6 typedef 名字</h2><p>typedef 可以用来定义类型的同义词：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;       //  wages is a synonym for double </span><br><span class="line">typedef int exam_score;     //  exam_score is a synonym for int </span><br><span class="line">typedef wages salary;       //  indirect synonym for double</span><br></pre></td></tr></table></figure>
<p>typedef 定义以关键字 typedef 开始，后面是数据类型和标识符。标识符或类型名并没有引入新的类型，而只是现有数据类型的同义词。typedef 名字可出现在程序中类型名可出现的任何位置。 </p>
<p>typedef 通常被用于以下三种目的：</p>
<ol>
<li>为了隐藏特定类型的实现，强调使用类型的目的。 </li>
<li>简化复杂的类型定义，使其更易理解。 </li>
<li>允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。</li>
</ol>
<h2 id="2-7-枚举"><a href="#2-7-枚举" class="headerlink" title="2.7 枚举"></a>2.7 枚举</h2><p>枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员列表。 </p>
<p>默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大 1。 </p>
<p><strong>枚举成员是常量</strong></p>
<p>可以为一个或多个枚举成员提供初始值，用来初始化枚举成员的值必须是一个常量表达式。常量表达式是编译器在编译时就能够计算出结果的整型表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Forms &#123;shape = 1, sphere, cylinder, polygon&#125;;</span><br></pre></td></tr></table></figure>
<p>在 枚举类型 Forms 中，显式将 shape 赋值为 1。其他枚举成员隐式初始化：sphere 初始化为 2，cylinder 初始化为 3，polygon 初始化为 4。 </p>
<p>枚举成员值可以是不唯一的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Points &#123; point2d = 2, point2w, point3d = 3, point3w &#125;;</span><br></pre></td></tr></table></figure>
<p>本例中，枚举成员 point2d 显式初始化为 2。下一个枚举成员 point2w 默认初始化，即它的值比前一枚举成员的值大 1。因此 point2w 初始化为 3。枚举成员 point3d 显式初始化为 3。一样，point3w 默认初始化，结果为 4。 </p>
<p>不能改变枚举成员的值。枚举成员本身就是一个常量表达式，所以也可用于需要常量表达式的任何地方。 </p>
<p><strong>每个 enum 都定义一种唯一的类型</strong></p>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C-Primer/">C++ Primer</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2018 <a href="/">ZYP</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>C++ Lesson21 | 空之境界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="ZYP">
  
  
    <meta name="description" content="第十五章 面向对象编程面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。">
  
  <meta name="description" content="第十五章 面向对象编程面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。">
<meta name="keywords" content="C++ Primer">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Lesson21">
<meta property="og:url" content="https://zypsola.com/2019/02/24/C++Primer21/index.html">
<meta property="og:site_name" content="空之境界">
<meta property="og:description" content="第十五章 面向对象编程面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-02-26T16:52:12.556Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Lesson21">
<meta name="twitter:description" content="第十五章 面向对象编程面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。">
  
  
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">空之境界</a></h1>
    <p><a href="/">ZYP&#39;s Blog</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/tags/C#">C#</a></li>
      
        <li><a href="/tags/C-Primer">C++</a></li>
      
        <li><a href="/tags/Unity">Unity</a></li>
      
        <li><a href="/tags/算法">算法</a></li>
      
        <li><a href="/tags/Others">Others</a></li>
      
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2019/02/24/C++Primer21/">
  <time datetime="2019-02-24T13:09:00.000Z">
    2019-02-24
  </time>
</a>
    
    
  
    <h1 class="title">C++ Lesson21</h1>
  

  </header>
  
  <div class="entry">
    
      <h1 id="第十五章-面向对象编程"><a href="#第十五章-面向对象编程" class="headerlink" title="第十五章 面向对象编程"></a>第十五章 面向对象编程</h1><p>面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。</p>
<a id="more"></a>
<h2 id="15-1-面向对象编程：概述"><a href="#15-1-面向对象编程：概述" class="headerlink" title="15.1 面向对象编程：概述"></a>15.1 面向对象编程：概述</h2><p><strong>继承</strong>：派生类（derived class）能够继承基类（base class）定义的成员，派生类可以无须改变而使用那些与派生类型具体特性不相关的操作，派生类可以重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。</p>
<p><strong>动态绑定</strong>：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。</p>
<h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>保留字 virtual 的目的是启用动态绑定。成员默认为非虚函数，对非虚函数的调用在编译时确定。为了指明函数为虚函数，在其返回类型前面加上保留字 virtual。除了构造函数之外，任意非 static 成员函数都可以是虚函数。保留字只在类内部的成员函数声明中出现，不能用在类定义体外部出现的函数定义上。</p>
<p>基类通常应将派生类需要重定义的任意函数定义为虚函数。</p>
<h3 id="15-2-2-protected成员"><a href="#15-2-2-protected成员" class="headerlink" title="15.2.2 protected成员"></a>15.2.2 protected成员</h3><p>派生类对基类的 public 和 private 成员的访问权限与程序中任意其他部分一样：它可以访问 public 成员而不能访问 private 成员。protected 成员可以被派生类对象访问但不能被该类型的普通用户访问。</p>
<h3 id="15-2-3-派生类"><a href="#15-2-3-派生类" class="headerlink" title="15.2.3 派生类"></a>15.2.3 派生类</h3><p>为了定义派生类，使用类派生列表指定基类。类派生列表指定了一个或多个基类。</p>
<p>派生类一般会重定义所继承的虚函数。派生类没有重定义某个虚函数，则使用基类中定义的版本。</p>
<p>派生类型必须对想要重定义的每个继承成员进行声明。</p>
<p>派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。 </p>
<p>派生类重定义虚函数时，可以使用 virtual 保留字，但不是必须这样做。</p>
<p>已定义的类才可以用作基类。</p>
<h3 id="15-2-4-virtual与其他成员函数"><a href="#15-2-4-virtual与其他成员函数" class="headerlink" title="15.2.4 virtual与其他成员函数"></a>15.2.4 virtual与其他成员函数</h3><p>C++ 中的函数调用默认不使用动态绑定。要触发动态绑定，满足两个条件：第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；第二，必须通过基类类型的引用或指针进行函数调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void a() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int b;</span><br><span class="line">protected:</span><br><span class="line">	void c() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">	void a() &#123;</span><br><span class="line">		c();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a, *p;</span><br><span class="line">	B b;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	p-&gt;a();       //a</span><br><span class="line">	p = &amp;b;</span><br><span class="line">	p-&gt;a();       //c</span><br><span class="line">	p-&gt;A::a();    //a</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-2-5-公用、私有和受保护的继承"><a href="#15-2-5-公用、私有和受保护的继承" class="headerlink" title="15.2.5 公用、私有和受保护的继承"></a>15.2.5 公用、私有和受保护的继承</h3><p><strong>公用继承:</strong>基类成员保持自己的访问级别。</p>
<p><strong>受保护继承:</strong>基类的public和protected成员在派生类中为protected成员。 </p>
<p><strong>私有继承:</strong>基类的的所有成员在派生类中为private成员。</p>
<p><strong>接口继承与实现继承</strong></p>
<p>public 派生类继承基类的接口，它具有与基类相同的接口。设计良好的类层次中，public 派生类的对象可以用在任何需要基类对象的地方。</p>
<p>使用 private 或 protected 派生的类不继承基类的接口，相反，这些派生通常被称为实现继承。</p>
<p>派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C :private A&#123;</span><br><span class="line">public:</span><br><span class="line">	using A::a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 class 保留字定义的派生默认具有 private 继承，而用 struct 保留字定义的类默认具有 public 继承。</p>
<h3 id="15-2-6-友元关系与继承"><a href="#15-2-6-友元关系与继承" class="headerlink" title="15.2.6 友元关系与继承"></a>15.2.6 友元关系与继承</h3><p>友元关系不能继承。</p>
<h3 id="15-2-7-继承与静态成员"><a href="#15-2-7-继承与静态成员" class="headerlink" title="15.2.7 继承与静态成员"></a>15.2.7 继承与静态成员</h3><p>如果基类定义 static 成员，则<strong>整个继承层次中只有一个这样的成员</strong>。无论从基类派生出多少个派生类，每个 static 成员只有一个实例。</p>
<h2 id="15-3-转换与继承"><a href="#15-3-转换与继承" class="headerlink" title="15.3 转换与继承"></a>15.3 转换与继承</h2><p>每个派生类对象包含一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行操作。因为派生类对象也是基类对象，所以存在从派生类型引用到基类类型引用的自动转换，即，可以将派生类对象的引用转换为基类子对象的引用，对指针也类似。 </p>
<p>基类类型对象既可以作为独立对象存在，也可以作为派生类对象的一部分而存在，因此，一个基类对象可能是也可能不是一个派生类对象的部分，结果，没有从基类引用（或基类指针）到派生类引用（或派生类指针）的（自动）转换。</p>
<p>相对于引用或指针而言，对象转换的情况更为复杂。虽然一般可以使用派生类型的对象对基类类型的对象进行初始化或赋值，但，没有从派生类型对象到基类类型对象的直接转换。</p>
<h2 id="15-4-构造函数与复制控制"><a href="#15-4-构造函数与复制控制" class="headerlink" title="15.4 构造函数与复制控制"></a>15.4 构造函数与复制控制</h2><p>构造函数和复制控制成员不能继承，每个类定义自己的构造函数和复制控制成员。</p>
<h3 id="15-4-2-派生类构造函数"><a href="#15-4-2-派生类构造函数" class="headerlink" title="15.4.2 派生类构造函数"></a>15.4.2 派生类构造函数</h3><p>派生类的合成默认构造函数与非派生的构造函数只有一点不同：除了初始化派生类的数据成员之外，它还初始化派生类对象的基类部分。基类部分由基类的默认构造函数初始化。</p>
<p>派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初始化继承成员。</p>
<p>构造函数初始化列表为类的基类和成员提供初始值，它并不指定初始化的执行次序。首先初始化基类，然后根据声明次序初始化派生类的成员。</p>
<h3 id="15-4-3-复制控制和继承"><a href="#15-4-3-复制控制和继承" class="headerlink" title="15.4.3 复制控制和继承"></a>15.4.3 复制控制和继承</h3><p>如果派生类定义了自己的复制构造函数，该复制构造函数一般应显式使用基类复制构造函数初始化对象的基类部分。</p>
<p>赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显式赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	A() :i(5) &#123;&#125;;</span><br><span class="line">	A(const A&amp; a) &#123;</span><br><span class="line">		i = 2 * a.i;</span><br><span class="line">	&#125;</span><br><span class="line">	int i;</span><br><span class="line">	virtual void out() &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A&amp; operator=(const A&amp; r) &#123;</span><br><span class="line">		i = 3 * r.i;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">	B() :j(3) &#123;&#125;;</span><br><span class="line">	B(const B&amp; b) :A(b) &#123;</span><br><span class="line">		j = 2 * b.j;</span><br><span class="line">	&#125;</span><br><span class="line">	int j;</span><br><span class="line">	void out() &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	B&amp; operator=(const B&amp; r) &#123;</span><br><span class="line">		A::operator=(r);</span><br><span class="line">		j = 3 * r.j;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a, b(a);</span><br><span class="line">	a.out();      //5</span><br><span class="line">	b.out();      //10</span><br><span class="line">	a = b;</span><br><span class="line">	a.out();      //30</span><br><span class="line">	B c, d(c);</span><br><span class="line">	c.out();      //5 3</span><br><span class="line">	d.out();      //10 6</span><br><span class="line">	c = d;</span><br><span class="line">	c.out();      //30 18</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数的工作与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员。编译器总是显式调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员。对象的撤销顺序与构造顺序相反：首先运行派生析构函数，然后按继承层次依次向上调用各基类析构函数。</p>
<h3 id="15-4-4-虚析构函数"><a href="#15-4-4-虚析构函数" class="headerlink" title="15.4.4 虚析构函数"></a>15.4.4 虚析构函数</h3><p>如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">	~B() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A *p = new A;</span><br><span class="line">	delete p;      //a</span><br><span class="line">	p = new B;</span><br><span class="line">	delete p;      //b</span><br><span class="line">                   //a</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p>
<h2 id="15-5-继承情况下的类作用域"><a href="#15-5-继承情况下的类作用域" class="headerlink" title="15.5 继承情况下的类作用域"></a>15.5 继承情况下的类作用域</h2><p>每个类都保持着自己的作用域，在该作用域中定义了成员的名字。在继承情况下，派生类的作用域嵌套在基类作用域中。如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。</p>
<p>与基类成员同名的派生类成员将屏蔽对基类成员的直接访问。可以使用作用域操作符访问被屏蔽的基类成员。</p>
<p>在基类和派生类中使用同一名字的成员函数，其行为与数据成员一样：在派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽。</p>
<h2 id="15-6-纯虚函数"><a href="#15-6-纯虚函数" class="headerlink" title="15.6 纯虚函数"></a>15.6 纯虚函数</h2><p>含有（或继承）一个或多个纯虚函数的类是<strong>抽象类类型</strong>。不能创建抽象类型的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void out() = 0;</span><br></pre></td></tr></table></figure>
<h2 id="15-7-容器与继承"><a href="#15-7-容器与继承" class="headerlink" title="15.7 容器与继承"></a>15.7 容器与继承</h2><p>如果定义容器保存基类类型的对象，则加入派生类型的对象时，只将对象的基类部分保存在容器中。</p>
<h2 id="15-8-句柄类与继承"><a href="#15-8-句柄类与继承" class="headerlink" title="15.8 句柄类与继承"></a>15.8 句柄类与继承</h2><p>C++ 中一个通用的技术是定义包装（cover）类或句柄类。句柄类存储和管理基类指针。指针所指对象的类型可以变化，它既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。因为句柄类使用指针执行操作，虚成员的行为将在运行时根据句柄实际绑定的对象的类型而变化。因此，句柄的用户可以获得动态行为但无须操心指针的管理。</p>

    
  </div>
  <footer>
    
      
      
  <div class="tags">
    <a class="tags-link" href="/tags/C-Primer/">C++ Primer</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2019 <a href="/">ZYP</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>
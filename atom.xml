<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空之境界</title>
  
  <subtitle>ZYP&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zypsola.com/"/>
  <updated>2019-03-11T14:21:25.575Z</updated>
  <id>https://zypsola.com/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法 Lesson10</title>
    <link href="https://zypsola.com/2019/03/11/%E7%AE%97%E6%B3%95Lesson10/"/>
    <id>https://zypsola.com/2019/03/11/算法Lesson10/</id>
    <published>2019-03-11T12:32:21.000Z</published>
    <updated>2019-03-11T14:21:25.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十八章-B树"><a href="#第十八章-B树" class="headerlink" title="第十八章 B树"></a>第十八章 B树</h1><p>B树是为磁盘或其他直接存取的辅助储存设备而设计的一种平衡搜索树。</p><a id="more"></a><h2 id="18-1-B树的定义"><a href="#18-1-B树的定义" class="headerlink" title="18.1 B树的定义"></a>18.1 B树的定义</h2><p>一棵m阶的B树，或为空，或为满足下列特征的m叉树：</p><ol><li>树中每个结点至多有m棵子树</li><li>若根结点不是叶结点，则至少有两棵子树</li><li>除根结点以外的所有非叶结点至少有⌈m/2⌉棵子树</li><li>非叶根结点有n(n &lt; m)个关键字k，k<sub>i</sub> &lt; k<sub>i+1</sub></li><li>所有叶子结点在同一层且不带信息</li></ol><h2 id="18-2-插入关键字"><a href="#18-2-插入关键字" class="headerlink" title="18.2 插入关键字"></a>18.2 插入关键字</h2><ol><li>插入后，该结点关键字个数n &lt; m，直接插入；</li><li>插入后，该结点关键字个数n = m，须结点分裂：令⌈m/2⌉插入父节点，右部分生成新结点，若父结点插入后也满，则继续结点分裂，若无父结点，则建立新的根结点；</li></ol><h2 id="18-3-删除关键字"><a href="#18-3-删除关键字" class="headerlink" title="18.3 删除关键字"></a>18.3 删除关键字</h2><ol><li>被删除关键字所在结点，关键字个数n&gt;=⌈m/2⌉，直接删去；</li><li>被删除关键字所在结点，关键字个数n=⌈m/2⌉-1，若相邻的左兄弟(右兄弟)的关键字个数n&gt;=⌈m/2⌉，将父结点中刚小于(大于)删除关键字的关键字下移到被删除关键字所在结点，将左兄弟(右兄弟)最大(最小)关键字上移到父结点；</li><li>被删除关键字所在结点和相邻的兄弟结点中的关键字个数均为n=⌈m/2⌉-1，删除后与兄弟结点合并；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十八章-B树&quot;&gt;&lt;a href=&quot;#第十八章-B树&quot; class=&quot;headerlink&quot; title=&quot;第十八章 B树&quot;&gt;&lt;/a&gt;第十八章 B树&lt;/h1&gt;&lt;p&gt;B树是为磁盘或其他直接存取的辅助储存设备而设计的一种平衡搜索树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson9</title>
    <link href="https://zypsola.com/2019/03/11/%E7%AE%97%E6%B3%95Lesson9/"/>
    <id>https://zypsola.com/2019/03/11/算法Lesson9/</id>
    <published>2019-03-11T08:33:46.000Z</published>
    <updated>2019-03-11T12:29:49.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-贪心算法"><a href="#第十六章-贪心算法" class="headerlink" title="第十六章 贪心算法"></a>第十六章 贪心算法</h1><p>贪心算法总是做出局部最优的选择。</p><a id="more"></a><h2 id="16-1-活动选择问题"><a href="#16-1-活动选择问题" class="headerlink" title="16.1 活动选择问题"></a>16.1 活动选择问题</h2><p>假设有一个活动的集合S={a<sub>1</sub>,…,a<sub>n</sub>}，这些活动使用同一个资源，而这个资源某个时空只能供一个活动使用，每个活动都有一个开始时间和结束时间。在活动选择问题中，我们希望选出一个最大兼容活动集。</p><p>反复选择最早结束的活动，保留兼容的活动。</p><h2 id="16-3-赫夫曼编码"><a href="#16-3-赫夫曼编码" class="headerlink" title="16.3 赫夫曼编码"></a>16.3 赫夫曼编码</h2><p>构造Huffman树</p><ol><li>根据给定的n个权值，构造n棵只有根结点的二叉树</li><li>在森林中取两棵根结点权值最小的树作左右子树，构造一棵二叉树，置根结点权值为左右子树根节点权值之和</li><li>重复上步直到只含一棵树，即哈夫曼树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十六章-贪心算法&quot;&gt;&lt;a href=&quot;#第十六章-贪心算法&quot; class=&quot;headerlink&quot; title=&quot;第十六章 贪心算法&quot;&gt;&lt;/a&gt;第十六章 贪心算法&lt;/h1&gt;&lt;p&gt;贪心算法总是做出局部最优的选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson8</title>
    <link href="https://zypsola.com/2019/03/09/%E7%AE%97%E6%B3%95Lesson8/"/>
    <id>https://zypsola.com/2019/03/09/算法Lesson8/</id>
    <published>2019-03-09T15:06:37.000Z</published>
    <updated>2019-03-10T13:33:35.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五章-动态规划"><a href="#第十五章-动态规划" class="headerlink" title="第十五章 动态规划"></a>第十五章 动态规划</h1><p>分治法将问题划分为互不相交的子问题，动态规划应用于子问题重叠的情况。</p><a id="more"></a><p>我们通常按以下4个步骤来设计一个动态规划算法：</p><ol><li>刻画一个最优解的结构特征</li><li>递归地定义最优解的值</li><li>计算最优解的值，通常采用自底向上的方法</li><li>利用计算出的信息构造一个最优解。</li></ol><h2 id="15-1-钢条切割"><a href="#15-1-钢条切割" class="headerlink" title="15.1 钢条切割"></a>15.1 钢条切割</h2><p><strong>钢条切割问题</strong>:给定一段长度为n英寸的钢条和一个价格表<strong>p<sub>i</sub>(i=1,2,…,n)</strong>,求切割方案使收益<strong>r<sub>n</sub></strong>最大。</p><p><strong>r<sub>n</sub> = max(p<sub>n</sub>, r<sub>1</sub>+r<sub>n-1</sub>,…,r<sub>n-1</sub>+r<sub>1</sub>)</strong></p><p>我们称钢条切割问题满足<strong>最优子结构</strong>性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p><p>钢条切割问题还存在另一种方法：</p><p><strong>r<sub>n</sub> = max(p<sub>1</sub>+r<sub>n-1</sub>,…,p<sub>n-1</sub>+r<sub>1, p<sub>n</sub>)</sub></strong></p><h2 id="15-2-矩阵链乘法"><a href="#15-2-矩阵链乘法" class="headerlink" title="15.2 矩阵链乘法"></a>15.2 矩阵链乘法</h2><p>我们称有如下性质的矩阵乘积链为<strong>完全括号化的</strong>：它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。</p><h2 id="15-4-最长公共子序列"><a href="#15-4-最长公共子序列" class="headerlink" title="15.4 最长公共子序列"></a>15.4 最长公共子序列</h2><p><strong>最长公共子序列问题</strong>：给定两个序列X={x1,x2,…,x<sub>m</sub>}h和Y={y1,y2,…,y<sub>n</sub>},求X和Y的最长公共子序列LCS。</p><p>我们定义c[i,j]表示X<sub>i</sub>和Y<sub>j</sub>的LCS长度。</p><ol><li>若i=0 或 j=0, c[i,j]=0;</li><li>若i,j&gt;0 且 x<sub>i</sub> = y<sub>j</sub>, c[i,j]=c[i-1,j-1]+1;</li><li>若i,j&gt;0 且 x<sub>i</sub> ！= y<sub>j</sub>, max(c[i,j-1],c[i-1,j]);</li></ol><h2 id="15-5-最优二叉搜索树"><a href="#15-5-最优二叉搜索树" class="headerlink" title="15.5 最优二叉搜索树"></a>15.5 最优二叉搜索树</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十五章-动态规划&quot;&gt;&lt;a href=&quot;#第十五章-动态规划&quot; class=&quot;headerlink&quot; title=&quot;第十五章 动态规划&quot;&gt;&lt;/a&gt;第十五章 动态规划&lt;/h1&gt;&lt;p&gt;分治法将问题划分为互不相交的子问题，动态规划应用于子问题重叠的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson7</title>
    <link href="https://zypsola.com/2019/03/05/%E7%AE%97%E6%B3%95Lesson7/"/>
    <id>https://zypsola.com/2019/03/05/算法Lesson7/</id>
    <published>2019-03-05T05:47:12.000Z</published>
    <updated>2019-03-10T08:25:26.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-二叉搜索树"><a href="#第十二章-二叉搜索树" class="headerlink" title="第十二章 二叉搜索树"></a>第十二章 二叉搜索树</h1><a id="more"></a><h2 id="12-1-二叉树搜索树"><a href="#12-1-二叉树搜索树" class="headerlink" title="12.1 二叉树搜索树"></a>12.1 二叉树搜索树</h2><p>对任何结点x，其左子树中的key值最大不超过x.key，右子树中的key值最小不低于x.key。</p><p><strong>先序遍历</strong>：(1)访问根结点(2)先序遍历左子树(3)先序遍历右子树<br><strong>中序遍历</strong>：(1)中序遍历左子树(2)访问根结点(3)中序遍历右子树<br><strong>后序遍历</strong>：(1)后序遍历左子树(2)后序遍历右子树(3)访问根结点</p><p>后继结点：一个结点在中序遍历序列中的后一个结点<br>前驱结点：一个结点在中序遍历序列中的前一个结点</p><h2 id="12-3-插入和删除"><a href="#12-3-插入和删除" class="headerlink" title="12.3 插入和删除"></a>12.3 插入和删除</h2><h1 id="十三章-红黑树"><a href="#十三章-红黑树" class="headerlink" title="十三章 红黑树"></a>十三章 红黑树</h1><h2 id="13-1-红黑树的性质"><a href="#13-1-红黑树的性质" class="headerlink" title="13.1 红黑树的性质"></a>13.1 红黑树的性质</h2><p>红黑树是一棵二叉搜索树，它为每个结点上增加了颜色。通过对任意一条从根结点到叶子结点的路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍。</p><ol><li>每个结点是红色的或黑色的</li><li>根结点是黑色的</li><li>叶结点(空结点)是黑色的</li><li>红色结点的子结点是黑色的</li><li>对每个结点，从该结点到所有叶子结点的路径上，黑色结点的数目相同。</li></ol><p>从某个结点(不包括本身)到其叶子结点路径上黑色结点的数量为该结点的<strong>黑高</strong>。</p><h2 id="13-3-插入"><a href="#13-3-插入" class="headerlink" title="13.3 插入"></a>13.3 插入</h2><p>将插入节点设为红色。先正常插入。</p><ol><li>插入位置是根结点：直接涂为黑色。</li><li>插入位置的父结点为黑色：不需要操作。</li><li>插入位置的父结点为红色：</li></ol><p>case1:叔叔结点为红色:1.将父结点设为黑色；2.祖父结点设为红色；3.叔叔结点设为黑色；4.以祖父结点为当前结点递归分析；<br>case2:叔叔结点为黑色且当前结点为右孩子:1.以父结点为当前结点；2.以当前结点为支点左旋；<br>case3:叔叔结点为黑色且当前结点为左孩子:1.父结点设为黑色；2.祖父结点设为红色；3.以祖父结点为支点右旋；</p><h2 id="13-4-删除"><a href="#13-4-删除" class="headerlink" title="13.4 删除"></a>13.4 删除</h2><ol><li>删除结点z没有孩子结点:直接删除。</li><li>删除结点z只有一个孩子:删除z将孩子提升至z的位置。</li><li>删除结点z有2给孩子:找到其后继结点替换。</li></ol><p>设当前位置的结点有一个额外黑色。</p><ol><li>红+黑：直接设为黑。</li><li>黑+黑，且为根结点：直接设为黑。</li><li>黑+黑，不为根结点：</li></ol><p>case1:兄弟结点为红色:1.父结点设为红色；2.兄弟结点设为黑；3.以父结点旋转；<br>case2:兄弟结点为黑色,兄弟结点的2个子结点为黑:1.兄弟结点设为红；2.设父结点为当前结点；<br>case3:兄弟结点为黑色,兄弟结点的2个子结点为右黑左红:1.兄弟结点设为红色；2.红色子结点设为黑；以兄弟结点右旋；<br>case4:兄弟结点为黑色,兄弟结点的2个子结点为右红左任意：1.将父结点颜色赋予兄弟结点；2.将父结点设为黑；3.将兄弟结点是右子结点设为黑；4.以父结点左旋；5.修正结束；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十二章-二叉搜索树&quot;&gt;&lt;a href=&quot;#第十二章-二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;第十二章 二叉搜索树&quot;&gt;&lt;/a&gt;第十二章 二叉搜索树&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson6</title>
    <link href="https://zypsola.com/2019/03/04/%E7%AE%97%E6%B3%95Lesson6/"/>
    <id>https://zypsola.com/2019/03/04/算法Lesson6/</id>
    <published>2019-03-04T09:03:53.000Z</published>
    <updated>2019-03-05T05:45:47.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-基本数据结构"><a href="#第十章-基本数据结构" class="headerlink" title="第十章 基本数据结构"></a>第十章 基本数据结构</h1><a id="more"></a><h2 id="10-1-栈和队列"><a href="#10-1-栈和队列" class="headerlink" title="10.1 栈和队列"></a>10.1 栈和队列</h2><p>栈：后进先出<br>队列：先进先出</p><h2 id="10-2-链表"><a href="#10-2-链表" class="headerlink" title="10.2 链表"></a>10.2 链表</h2><h2 id="10-4-有根树"><a href="#10-4-有根树" class="headerlink" title="10.4 有根树"></a>10.4 有根树</h2><p><strong>分支无限制的有根树</strong>：左孩子右兄弟</p><h1 id="第十一章-散列表"><a href="#第十一章-散列表" class="headerlink" title="第十一章 散列表"></a>第十一章 散列表</h1><p>在散列表中，不是直接把关键字作为数组下标，而是根据关键字计算出相应的下标。</p><h2 id="11-1-直接寻址法"><a href="#11-1-直接寻址法" class="headerlink" title="11.1 直接寻址法"></a>11.1 直接寻址法</h2><p>当关键字的全域比较小时，直接寻址简单而有效。</p><h2 id="11-2-散列表"><a href="#11-2-散列表" class="headerlink" title="11.2 散列表"></a>11.2 散列表</h2><p>在直接寻址方式下，关键字为k的元素放在槽k中。在散列方式下，该元素存放在槽h(k)中，即利用<strong>散列函数</strong>h，由关键字k计算出槽的位置。</p><p>两个关键字可能映射到同一个槽中。我们称之为冲突。</p><p><strong>链接法</strong>：把散列到同一槽中的元素都放在一个链表中。</p><h2 id="11-3-散列函数"><a href="#11-3-散列函数" class="headerlink" title="11.3 散列函数"></a>11.3 散列函数</h2><p><strong>将关键字转换为自然数</strong></p><h3 id="11-3-1-除法散列法"><a href="#11-3-1-除法散列法" class="headerlink" title="11.3.1 除法散列法"></a>11.3.1 除法散列法</h3><p>h(k) = k mod m</p><p>我们要避免选择m的某些值，例如2的幂。</p><h3 id="11-3-2-乘法散列表"><a href="#11-3-2-乘法散列表" class="headerlink" title="11.3.2 乘法散列表"></a>11.3.2 乘法散列表</h3><p>用关键字k乘常数A(0&lt;A&lt;1),并提取kA的小数部分，用m乘以这个这个值再向下取整。</p><p>h(k) = ⌊m(kA mod 1)⌋</p><h3 id="11-3-3-全域散列法"><a href="#11-3-3-全域散列法" class="headerlink" title="11.3.3 全域散列法"></a>11.3.3 全域散列法</h3><p>随机地选择散列函数，使之独立于关键字。</p><h2 id="11-4-开放寻址法"><a href="#11-4-开放寻址法" class="headerlink" title="11.4 开放寻址法"></a>11.4 开放寻址法</h2><p>为使开放寻址法插入一个元素，需要连续地检查散列表，或称为<strong>探查</strong>(probe)，直到找到一个空槽来放置。</p><p><strong>线性探查</strong></p><p>h(k,i) = (h’(k) + i) mod m, i=0,1,…,m-1</p><p><strong>二次探查</strong></p><p>h(k,i) = (h’(k) + c1i + c2i²) mod m, i=0,1,…,m-1</p><p><strong>双重散列</strong></p><p>h(k,i) = (h1(k) + ih2(k)) mod m, i=0,1,…,m-1</p><h2 id="11-5-完全散列"><a href="#11-5-完全散列" class="headerlink" title="11.5 完全散列"></a>11.5 完全散列</h2><p>采用两级散列方法设计完全散列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十章-基本数据结构&quot;&gt;&lt;a href=&quot;#第十章-基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;第十章 基本数据结构&quot;&gt;&lt;/a&gt;第十章 基本数据结构&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson5</title>
    <link href="https://zypsola.com/2019/03/03/%E7%AE%97%E6%B3%95Lesson5/"/>
    <id>https://zypsola.com/2019/03/03/算法Lesson5/</id>
    <published>2019-03-03T09:17:45.000Z</published>
    <updated>2019-03-04T09:02:22.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-线性时间排序"><a href="#第八章-线性时间排序" class="headerlink" title="第八章 线性时间排序"></a>第八章 线性时间排序</h1><p>在排序的最终结果中，各元素的次序依赖于它们之间的比较的排序算法，我们称之为<strong>比较排序</strong>。</p><a id="more"></a><h2 id="8-2-计数排序"><a href="#8-2-计数排序" class="headerlink" title="8.2 计数排序"></a>8.2 计数排序</h2><p>计数排序假定输入数据都属于一个小区间内的整数。计数排序是<strong>稳定的</strong>:具有相同值的元素在输出数组中的相对次序于它们在输入数组中的相对次序相同。计数排序经常会被用作基数排序算法的一个子过程，为了使基数排序正常运行，计数排序必须是稳定的。</p><h2 id="8-3-基数排序"><a href="#8-3-基数排序" class="headerlink" title="8.3 基数排序"></a>8.3 基数排序</h2><p>基数排序是按最低有效位进行排序的。</p><h2 id="8-4-桶排序"><a href="#8-4-桶排序" class="headerlink" title="8.4 桶排序"></a>8.4 桶排序</h2><p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上，桶排序将[0,1)区间划分为n个相同大小的子区间，或称为<strong>桶</strong>。我们先对每个桶中的数据进行排序，然后遍历每个桶，依次输出各个桶中的元素即可。</p><h1 id="第九章-中位数和顺序统计量"><a href="#第九章-中位数和顺序统计量" class="headerlink" title="第九章 中位数和顺序统计量"></a>第九章 中位数和顺序统计量</h1><p>在一个由n个元素组成的集合中，第i个<strong>顺序统计量</strong>是该集合中第i小的元素。</p><p>如果不考虑n的奇偶性，中位数总是出现在i=⌊(n+1)/2⌋处(下中位数)和i=⌈(n+2)/2⌉处(上中位数)。</p><h2 id="9-1-最大值和最小值"><a href="#9-1-最大值和最小值" class="headerlink" title="9.1 最大值和最小值"></a>9.1 最大值和最小值</h2><p><strong>同时找到最小值和最大值</strong></p><p>分别独立地找出最大值和最小值需要2n-2次比较。事实上，最多只需要3⌊n/2⌋次比较。具体方法是:记录已知的最大值最小值，取一对元素互相比较，较小的与最小值比较，较大的与最大值比较。</p><h2 id="9-2-期望为线性时间的选择算法"><a href="#9-2-期望为线性时间的选择算法" class="headerlink" title="9.2 期望为线性时间的选择算法"></a>9.2 期望为线性时间的选择算法</h2><p>选择问题：在A[p..r]中找到第i小的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOM-SELECT(A,p,r,i)</span><br><span class="line">if p==r</span><br><span class="line">return A[p]</span><br><span class="line">q = RANDOM-PARTITION(A,p,r)</span><br><span class="line">k = q - p + 1</span><br><span class="line">if i==k</span><br><span class="line">return A[q]</span><br><span class="line">else if i&lt;k</span><br><span class="line">return RANDOM-SELECT(A,p,q-1,i)</span><br><span class="line">else</span><br><span class="line">return RANDOM-SELECT(A,q+1,r,i-k)</span><br></pre></td></tr></table></figure><h2 id="9-3-最坏情况为线性时间的选择算法"><a href="#9-3-最坏情况为线性时间的选择算法" class="headerlink" title="9.3 最坏情况为线性时间的选择算法"></a>9.3 最坏情况为线性时间的选择算法</h2><ol><li><p>将数组划分为n/5组</p></li><li><p>对每组排序并找出中位数</p></li><li><p>递归调用找出中位数的中位数</p></li><li><p>使用中位数的中位数为主元调用PRATITION划分</p></li><li><p>递归调用</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第八章-线性时间排序&quot;&gt;&lt;a href=&quot;#第八章-线性时间排序&quot; class=&quot;headerlink&quot; title=&quot;第八章 线性时间排序&quot;&gt;&lt;/a&gt;第八章 线性时间排序&lt;/h1&gt;&lt;p&gt;在排序的最终结果中，各元素的次序依赖于它们之间的比较的排序算法，我们称之为&lt;strong&gt;比较排序&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson4</title>
    <link href="https://zypsola.com/2019/03/03/%E7%AE%97%E6%B3%95Lesson4/"/>
    <id>https://zypsola.com/2019/03/03/算法Lesson4/</id>
    <published>2019-03-03T08:24:31.000Z</published>
    <updated>2019-03-03T09:12:37.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-快速排序"><a href="#第七章-快速排序" class="headerlink" title="第七章 快速排序"></a>第七章 快速排序</h1><p>快速排序是一种最坏情况时间复杂度为Θ(n²)，期望时间复杂度为Θ(nlogn)的排序算法。</p><a id="more"></a><h2 id="7-1-快速排序的描述"><a href="#7-1-快速排序的描述" class="headerlink" title="7.1 快速排序的描述"></a>7.1 快速排序的描述</h2><p><strong>分解：</strong>将A[p..r]划分为A[p..q-1]和A[q+1..r],使得A[p..q-1]中的每个元素都小于等于A[q],A[q]小于等于A[q+1..r]中的每个元素。<br><strong>解决：</strong>递归调用，对A[p..q-1]和A[q+1..r]进行排序。<br><strong>合并：</strong>因为子数组都是原址排序，所以A[p..r]已经有序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSORT(A,p,r)</span><br><span class="line">q = PARTITION(A,p,r)</span><br><span class="line">QSORT(A,p,q-1)</span><br><span class="line">QSORT(A,p+1,r)</span><br></pre></td></tr></table></figure><p><strong>数组的划分</strong></p><p>算法的关键部分是<strong>PARTITION</strong>过程:PARTITION总是选择x=A[r]作为<strong>主元</strong>，并围绕它来划分子数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PARTITION(A,p,r)</span><br><span class="line">x = A[r]</span><br><span class="line">i = p -1</span><br><span class="line">for j = p to r-1</span><br><span class="line">if A[j]&lt;=x</span><br><span class="line">i++</span><br><span class="line">exchange A[i] with A[j]</span><br><span class="line">exchange A[i+1] with A[r]</span><br><span class="line">return i+1</span><br></pre></td></tr></table></figure><h2 id="7-2-快速排序的性能"><a href="#7-2-快速排序的性能" class="headerlink" title="7.2 快速排序的性能"></a>7.2 快速排序的性能</h2><p>快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素。如果划分是平衡的，那么快速排序的性能与归并排序一样，如果不平衡，则性能接近于插入排序。</p><h2 id="7-3-快速排序的随机化版本"><a href="#7-3-快速排序的随机化版本" class="headerlink" title="7.3 快速排序的随机化版本"></a>7.3 快速排序的随机化版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANDOM-PARTITION(A,p,r)</span><br><span class="line">i = RANDOM(p,r)</span><br><span class="line">exchange A[r] with A[i]</span><br><span class="line">return PARTITION(A,p,r)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第七章-快速排序&quot;&gt;&lt;a href=&quot;#第七章-快速排序&quot; class=&quot;headerlink&quot; title=&quot;第七章 快速排序&quot;&gt;&lt;/a&gt;第七章 快速排序&lt;/h1&gt;&lt;p&gt;快速排序是一种最坏情况时间复杂度为Θ(n²)，期望时间复杂度为Θ(nlogn)的排序算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson3</title>
    <link href="https://zypsola.com/2019/03/02/%E7%AE%97%E6%B3%95Lesson3/"/>
    <id>https://zypsola.com/2019/03/02/算法Lesson3/</id>
    <published>2019-03-02T06:34:42.000Z</published>
    <updated>2019-03-03T08:23:15.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-堆排序"><a href="#第六章-堆排序" class="headerlink" title="第六章 堆排序"></a>第六章 堆排序</h1><p>堆排序的时间复杂度O(nlgn)。而与插入排序相同，但不同于归并排序的是，堆排序具有空间原址性：任何时候都只需要常数个额外的元素空间储存临时数据。</p><a id="more"></a><h2 id="6-1-堆"><a href="#6-1-堆" class="headerlink" title="6.1 堆"></a>6.1 堆</h2><p><strong>堆</strong>是一个数组，可以被看成一个完全二叉树。树的根节点是A[1]，对给定的一个结点下标i，可以计算出它的父结点、左孩子和右孩子的下标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PARENT(i)</span><br><span class="line">    return ⌊i/2⌋</span><br><span class="line">LEFT(i)</span><br><span class="line">return 2i</span><br><span class="line">RIGHT(i)</span><br><span class="line">return 2i+1</span><br></pre></td></tr></table></figure><p>二叉堆可以分为最大堆和最小堆。</p><p><strong>最大堆</strong>：A[PARENT(i)]&gt;=A[i],即某个结点的值至多与其父结点一样大。</p><p><strong>最小堆</strong>：A[PARENT(i)]&lt;=A[i]。</p><h2 id="6-2-维护堆的性质"><a href="#6-2-维护堆的性质" class="headerlink" title="6.2 维护堆的性质"></a>6.2 维护堆的性质</h2><p>MAX-HEAPIFY用于维护最大堆性质，输入为数组A与下标i，在调用时假定以LEFT(i)与RIGHT(i)的二叉树都是最大堆，但A[i]可能小于孩子，通过让A[i]在最大堆中逐级下降来维护。需要递归调用MAX-HEAPIFY。</p><p>O(lgn)</p><h2 id="6-3-建堆"><a href="#6-3-建堆" class="headerlink" title="6.3 建堆"></a>6.3 建堆</h2><p>我们可以用自底向上的方法利用MAX-HEAPIFY把一个数组A[1..n]转换为最大堆。A[⌊n/2⌋+1..n]中的元素都是树的叶结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i = ⌊n/2⌋ to 1</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure><p>O(n)</p><h2 id="6-4-堆排序"><a href="#6-4-堆排序" class="headerlink" title="6.4 堆排序"></a>6.4 堆排序</h2><p>初始先建立最大堆，因为数组最大元素始终在A[1],将A[1]与A[heapsize]互换，heapsize-1，再调用MAX-HEAPIFY(A,1),不断重复。</p><p>O(nlgn)</p><h2 id="6-5-优先队列"><a href="#6-5-优先队列" class="headerlink" title="6.5 优先队列"></a>6.5 优先队列</h2><p><strong>优先队列</strong>是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个关键字key值。一个最大优先队列支持以下操作：</p><ol><li>INSERT(S,x):把元素x插入S中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEAP-INSERT(A,k)</span><br><span class="line">heapsize++</span><br><span class="line">A[heapsize] = k - 1</span><br><span class="line">HEAP-INCREASE-KEY(A,heapsize,k)</span><br></pre></td></tr></table></figure><ol start="2"><li>MAXIMUM(S):返回最大key值元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAP-MAXIMUM(A)</span><br><span class="line">return A[1]</span><br></pre></td></tr></table></figure><ol start="3"><li>EXTRACT-MAX(S):返回并去掉最大Key值元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAP-EXTRACT-MAX(S)</span><br><span class="line">max = A[1]</span><br><span class="line">A[1] = A[heapsize]</span><br><span class="line">heapsize--</span><br><span class="line">MAX-HEAPIFY(A,1)</span><br><span class="line">return max</span><br></pre></td></tr></table></figure><ol start="4"><li>INCREASE-KEY(S,x,k):将元素x的key值增加到k,k大于原值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HEAP-INCREASE-KEY(A,i,k)</span><br><span class="line">A[i] = k</span><br><span class="line">while i&gt;1 and A[PARENT(i)] &lt; A[i]</span><br><span class="line">exchange A[i] with A[PARENT[i]]</span><br><span class="line">i = PARENT[i]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六章-堆排序&quot;&gt;&lt;a href=&quot;#第六章-堆排序&quot; class=&quot;headerlink&quot; title=&quot;第六章 堆排序&quot;&gt;&lt;/a&gt;第六章 堆排序&lt;/h1&gt;&lt;p&gt;堆排序的时间复杂度O(nlgn)。而与插入排序相同，但不同于归并排序的是，堆排序具有空间原址性：任何时候都只需要常数个额外的元素空间储存临时数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson2</title>
    <link href="https://zypsola.com/2019/02/28/%E7%AE%97%E6%B3%95Lesson2/"/>
    <id>https://zypsola.com/2019/02/28/算法Lesson2/</id>
    <published>2019-02-28T08:58:22.000Z</published>
    <updated>2019-03-02T06:33:35.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-分治策略"><a href="#第四章-分治策略" class="headerlink" title="第四章 分治策略"></a>第四章 分治策略</h1><p>分解,解决,合并。</p><a id="more"></a><h2 id="4-1-最大子数组问题"><a href="#4-1-最大子数组问题" class="headerlink" title="4.1 最大子数组问题"></a>4.1 最大子数组问题</h2><p>只有当数组中包含负数时，最大子数组问题才有意义。</p><p>暴力求解时间复杂度O(n²)。</p><p><strong>使用分治策略的求解方法</strong></p><p>设数组A[low…mid…high],mid为中间位置。A的任何连续子数组A[i…j]必然是：low&lt;=i&lt;=j&lt;=mid; mid&lt;i&lt;=j&lt;=high; low&lt;=i&lt;=mid&lt;j&lt;=high。</p><p>我们可以在线性时间内求出跨越中点的最大子数组。</p><p>时间复杂度O(nlgn)。</p><p><strong>线性时间求解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int maxArray(vector&lt;int&gt; const &amp;num) &#123;</span><br><span class="line">int len = num.end() - num.begin();</span><br><span class="line">int i = 1, max = num[0], sum = num[0];</span><br><span class="line">while (i &lt; len) &#123;</span><br><span class="line">if (sum &lt; 0) &#123;</span><br><span class="line">sum = 0;</span><br><span class="line">&#125;</span><br><span class="line">sum = sum + num[i];</span><br><span class="line">i++;</span><br><span class="line">if (sum &gt; max) &#123;</span><br><span class="line">max = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-矩阵乘法的Strassen算法"><a href="#4-2-矩阵乘法的Strassen算法" class="headerlink" title="4.2 矩阵乘法的Strassen算法"></a>4.2 矩阵乘法的Strassen算法</h2><p>暴力求解O(n³)</p><p>Strassen算法(分治)O(n^lg7)</p><h1 id="第五章-概率分析和随机算法"><a href="#第五章-概率分析和随机算法" class="headerlink" title="第五章 概率分析和随机算法"></a>第五章 概率分析和随机算法</h1><p>如果一个算法的行为不仅由输入决定，而且也由随机数生成器产生的数值决定，则称这个算法是<strong>随机的</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-分治策略&quot;&gt;&lt;a href=&quot;#第四章-分治策略&quot; class=&quot;headerlink&quot; title=&quot;第四章 分治策略&quot;&gt;&lt;/a&gt;第四章 分治策略&lt;/h1&gt;&lt;p&gt;分解,解决,合并。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson1</title>
    <link href="https://zypsola.com/2019/02/27/%E7%AE%97%E6%B3%95Lesson1/"/>
    <id>https://zypsola.com/2019/02/27/算法Lesson1/</id>
    <published>2019-02-27T07:28:42.000Z</published>
    <updated>2019-02-28T08:42:33.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><p>非形式的说，<strong>算法(algorithm)</strong>就是任何良定义的计算过程，该过程取某个值或值的集合作为<strong>输入</strong>并产生某个值或值的集合作为<strong>输出</strong>。这样算法就是把输入转换成输出的计算步骤的一个序列。</p><a id="more"></a><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>Θ(n²)</p><h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>我们往往集中于最坏情况运行时间。</p><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解，然后合并子问题的解来建立原问题的解。</p><p><strong>归并排序</strong>:分解待排序的n个元素的序列成各具n/2个元素的两个子序列;使用归并排序递归地排序两个子序列;合并两个已排序的子序列。</p><p>Θ(nlgn)</p><h1 id="第三章-函数的增长"><a href="#第三章-函数的增长" class="headerlink" title="第三章 函数的增长"></a>第三章 函数的增长</h1><h2 id="3-1-渐进记号"><a href="#3-1-渐进记号" class="headerlink" title="3.1 渐进记号"></a>3.1 渐进记号</h2><p>我们主要使用渐进记号来描述算法的运行时间。然而，渐进记号实际上应用于函数。</p><p><strong>Θ记号</strong></p><p>Θ(g(n))={f(n):存在正常量c1,c2,n0,使得对所有n&gt;=n0,有0&lt;=c1g(n)&lt;=f(n)&lt;=c2g(n)}</p><p><strong>O记号</strong></p><p>Θ记号渐进地给出一个函数的上界和下界。当只有一个渐进上界时，使用O记号。</p><p>O(g(n))={f(n):存在正常量c,n0,使得对所有n&gt;=n0,有0&lt;=f(n)&lt;=cg(n)}</p><p><strong>Ω记号</strong></p><p>Ω记号提供了渐进下界。</p><p>Ω(g(n))={f(n):存在正常量c,n0,使得对所有n&gt;=n0,有0&lt;=cg(n)&lt;=f(n)}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-算法基础&quot;&gt;&lt;a href=&quot;#第二章-算法基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 算法基础&quot;&gt;&lt;/a&gt;第二章 算法基础&lt;/h1&gt;&lt;p&gt;非形式的说，&lt;strong&gt;算法(algorithm)&lt;/strong&gt;就是任何良定义的计算过程，该过程取某个值或值的集合作为&lt;strong&gt;输入&lt;/strong&gt;并产生某个值或值的集合作为&lt;strong&gt;输出&lt;/strong&gt;。这样算法就是把输入转换成输出的计算步骤的一个序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson22</title>
    <link href="https://zypsola.com/2019/02/27/C++Primer22/"/>
    <id>https://zypsola.com/2019/02/27/C++Primer22/</id>
    <published>2019-02-26T16:54:35.000Z</published>
    <updated>2019-02-26T16:56:27.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-模板和泛型编程"><a href="#第十六章-模板和泛型编程" class="headerlink" title="第十六章 模板和泛型编程"></a>第十六章 模板和泛型编程</h1><p>所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。第二部分中描述的标准库的容器、迭代器和算法都是泛型编程的例子。每种容器(如 vector)都有单一的定义，但可以定义许多不同种类的 vector，它们的区别在于所包含的元素类型。</p><a id="more"></a><h2 id="16-1-模板定义"><a href="#16-1-模板定义" class="headerlink" title="16.1 模板定义"></a>16.1 模板定义</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十六章-模板和泛型编程&quot;&gt;&lt;a href=&quot;#第十六章-模板和泛型编程&quot; class=&quot;headerlink&quot; title=&quot;第十六章 模板和泛型编程&quot;&gt;&lt;/a&gt;第十六章 模板和泛型编程&lt;/h1&gt;&lt;p&gt;所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。第二部分中描述的标准库的容器、迭代器和算法都是泛型编程的例子。每种容器(如 vector)都有单一的定义，但可以定义许多不同种类的 vector，它们的区别在于所包含的元素类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson21</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer21/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer21/</id>
    <published>2019-02-24T13:09:00.000Z</published>
    <updated>2019-02-26T16:52:12.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五章-面向对象编程"><a href="#第十五章-面向对象编程" class="headerlink" title="第十五章 面向对象编程"></a>第十五章 面向对象编程</h1><p>面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。</p><a id="more"></a><h2 id="15-1-面向对象编程：概述"><a href="#15-1-面向对象编程：概述" class="headerlink" title="15.1 面向对象编程：概述"></a>15.1 面向对象编程：概述</h2><p><strong>继承</strong>：派生类（derived class）能够继承基类（base class）定义的成员，派生类可以无须改变而使用那些与派生类型具体特性不相关的操作，派生类可以重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。</p><p><strong>动态绑定</strong>：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。</p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>保留字 virtual 的目的是启用动态绑定。成员默认为非虚函数，对非虚函数的调用在编译时确定。为了指明函数为虚函数，在其返回类型前面加上保留字 virtual。除了构造函数之外，任意非 static 成员函数都可以是虚函数。保留字只在类内部的成员函数声明中出现，不能用在类定义体外部出现的函数定义上。</p><p>基类通常应将派生类需要重定义的任意函数定义为虚函数。</p><h3 id="15-2-2-protected成员"><a href="#15-2-2-protected成员" class="headerlink" title="15.2.2 protected成员"></a>15.2.2 protected成员</h3><p>派生类对基类的 public 和 private 成员的访问权限与程序中任意其他部分一样：它可以访问 public 成员而不能访问 private 成员。protected 成员可以被派生类对象访问但不能被该类型的普通用户访问。</p><h3 id="15-2-3-派生类"><a href="#15-2-3-派生类" class="headerlink" title="15.2.3 派生类"></a>15.2.3 派生类</h3><p>为了定义派生类，使用类派生列表指定基类。类派生列表指定了一个或多个基类。</p><p>派生类一般会重定义所继承的虚函数。派生类没有重定义某个虚函数，则使用基类中定义的版本。</p><p>派生类型必须对想要重定义的每个继承成员进行声明。</p><p>派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。 </p><p>派生类重定义虚函数时，可以使用 virtual 保留字，但不是必须这样做。</p><p>已定义的类才可以用作基类。</p><h3 id="15-2-4-virtual与其他成员函数"><a href="#15-2-4-virtual与其他成员函数" class="headerlink" title="15.2.4 virtual与其他成员函数"></a>15.2.4 virtual与其他成员函数</h3><p>C++ 中的函数调用默认不使用动态绑定。要触发动态绑定，满足两个条件：第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；第二，必须通过基类类型的引用或指针进行函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">virtual void a() &#123;</span><br><span class="line">cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int b;</span><br><span class="line">protected:</span><br><span class="line">void c() &#123;</span><br><span class="line">cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">void a() &#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, *p;</span><br><span class="line">B b;</span><br><span class="line">p = &amp;a;</span><br><span class="line">p-&gt;a();       //a</span><br><span class="line">p = &amp;b;</span><br><span class="line">p-&gt;a();       //c</span><br><span class="line">p-&gt;A::a();    //a</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-2-5-公用、私有和受保护的继承"><a href="#15-2-5-公用、私有和受保护的继承" class="headerlink" title="15.2.5 公用、私有和受保护的继承"></a>15.2.5 公用、私有和受保护的继承</h3><p><strong>公用继承:</strong>基类成员保持自己的访问级别。</p><p><strong>受保护继承:</strong>基类的public和protected成员在派生类中为protected成员。 </p><p><strong>私有继承:</strong>基类的的所有成员在派生类中为private成员。</p><p><strong>接口继承与实现继承</strong></p><p>public 派生类继承基类的接口，它具有与基类相同的接口。设计良好的类层次中，public 派生类的对象可以用在任何需要基类对象的地方。</p><p>使用 private 或 protected 派生的类不继承基类的接口，相反，这些派生通常被称为实现继承。</p><p>派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C :private A&#123;</span><br><span class="line">public:</span><br><span class="line">using A::a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 class 保留字定义的派生默认具有 private 继承，而用 struct 保留字定义的类默认具有 public 继承。</p><h3 id="15-2-6-友元关系与继承"><a href="#15-2-6-友元关系与继承" class="headerlink" title="15.2.6 友元关系与继承"></a>15.2.6 友元关系与继承</h3><p>友元关系不能继承。</p><h3 id="15-2-7-继承与静态成员"><a href="#15-2-7-继承与静态成员" class="headerlink" title="15.2.7 继承与静态成员"></a>15.2.7 继承与静态成员</h3><p>如果基类定义 static 成员，则<strong>整个继承层次中只有一个这样的成员</strong>。无论从基类派生出多少个派生类，每个 static 成员只有一个实例。</p><h2 id="15-3-转换与继承"><a href="#15-3-转换与继承" class="headerlink" title="15.3 转换与继承"></a>15.3 转换与继承</h2><p>每个派生类对象包含一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行操作。因为派生类对象也是基类对象，所以存在从派生类型引用到基类类型引用的自动转换，即，可以将派生类对象的引用转换为基类子对象的引用，对指针也类似。 </p><p>基类类型对象既可以作为独立对象存在，也可以作为派生类对象的一部分而存在，因此，一个基类对象可能是也可能不是一个派生类对象的部分，结果，没有从基类引用（或基类指针）到派生类引用（或派生类指针）的（自动）转换。</p><p>相对于引用或指针而言，对象转换的情况更为复杂。虽然一般可以使用派生类型的对象对基类类型的对象进行初始化或赋值，但，没有从派生类型对象到基类类型对象的直接转换。</p><h2 id="15-4-构造函数与复制控制"><a href="#15-4-构造函数与复制控制" class="headerlink" title="15.4 构造函数与复制控制"></a>15.4 构造函数与复制控制</h2><p>构造函数和复制控制成员不能继承，每个类定义自己的构造函数和复制控制成员。</p><h3 id="15-4-2-派生类构造函数"><a href="#15-4-2-派生类构造函数" class="headerlink" title="15.4.2 派生类构造函数"></a>15.4.2 派生类构造函数</h3><p>派生类的合成默认构造函数与非派生的构造函数只有一点不同：除了初始化派生类的数据成员之外，它还初始化派生类对象的基类部分。基类部分由基类的默认构造函数初始化。</p><p>派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初始化继承成员。</p><p>构造函数初始化列表为类的基类和成员提供初始值，它并不指定初始化的执行次序。首先初始化基类，然后根据声明次序初始化派生类的成员。</p><h3 id="15-4-3-复制控制和继承"><a href="#15-4-3-复制控制和继承" class="headerlink" title="15.4.3 复制控制和继承"></a>15.4.3 复制控制和继承</h3><p>如果派生类定义了自己的复制构造函数，该复制构造函数一般应显式使用基类复制构造函数初始化对象的基类部分。</p><p>赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显式赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">A() :i(5) &#123;&#125;;</span><br><span class="line">A(const A&amp; a) &#123;</span><br><span class="line">i = 2 * a.i;</span><br><span class="line">&#125;</span><br><span class="line">int i;</span><br><span class="line">virtual void out() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; operator=(const A&amp; r) &#123;</span><br><span class="line">i = 3 * r.i;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">B() :j(3) &#123;&#125;;</span><br><span class="line">B(const B&amp; b) :A(b) &#123;</span><br><span class="line">j = 2 * b.j;</span><br><span class="line">&#125;</span><br><span class="line">int j;</span><br><span class="line">void out() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B&amp; operator=(const B&amp; r) &#123;</span><br><span class="line">A::operator=(r);</span><br><span class="line">j = 3 * r.j;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, b(a);</span><br><span class="line">a.out();      //5</span><br><span class="line">b.out();      //10</span><br><span class="line">a = b;</span><br><span class="line">a.out();      //30</span><br><span class="line">B c, d(c);</span><br><span class="line">c.out();      //5 3</span><br><span class="line">d.out();      //10 6</span><br><span class="line">c = d;</span><br><span class="line">c.out();      //30 18</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数的工作与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员。编译器总是显式调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员。对象的撤销顺序与构造顺序相反：首先运行派生析构函数，然后按继承层次依次向上调用各基类析构函数。</p><h3 id="15-4-4-虚析构函数"><a href="#15-4-4-虚析构函数" class="headerlink" title="15.4.4 虚析构函数"></a>15.4.4 虚析构函数</h3><p>如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~A() &#123;</span><br><span class="line">cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">~B() &#123;</span><br><span class="line">cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A *p = new A;</span><br><span class="line">delete p;      //a</span><br><span class="line">p = new B;</span><br><span class="line">delete p;      //b</span><br><span class="line">                   //a</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p><h2 id="15-5-继承情况下的类作用域"><a href="#15-5-继承情况下的类作用域" class="headerlink" title="15.5 继承情况下的类作用域"></a>15.5 继承情况下的类作用域</h2><p>每个类都保持着自己的作用域，在该作用域中定义了成员的名字。在继承情况下，派生类的作用域嵌套在基类作用域中。如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。</p><p>与基类成员同名的派生类成员将屏蔽对基类成员的直接访问。可以使用作用域操作符访问被屏蔽的基类成员。</p><p>在基类和派生类中使用同一名字的成员函数，其行为与数据成员一样：在派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽。</p><h2 id="15-6-纯虚函数"><a href="#15-6-纯虚函数" class="headerlink" title="15.6 纯虚函数"></a>15.6 纯虚函数</h2><p>含有（或继承）一个或多个纯虚函数的类是<strong>抽象类类型</strong>。不能创建抽象类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void out() = 0;</span><br></pre></td></tr></table></figure><h2 id="15-7-容器与继承"><a href="#15-7-容器与继承" class="headerlink" title="15.7 容器与继承"></a>15.7 容器与继承</h2><p>如果定义容器保存基类类型的对象，则加入派生类型的对象时，只将对象的基类部分保存在容器中。</p><h2 id="15-8-句柄类与继承"><a href="#15-8-句柄类与继承" class="headerlink" title="15.8 句柄类与继承"></a>15.8 句柄类与继承</h2><p>C++ 中一个通用的技术是定义包装（cover）类或句柄类。句柄类存储和管理基类指针。指针所指对象的类型可以变化，它既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。因为句柄类使用指针执行操作，虚成员的行为将在运行时根据句柄实际绑定的对象的类型而变化。因此，句柄的用户可以获得动态行为但无须操心指针的管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十五章-面向对象编程&quot;&gt;&lt;a href=&quot;#第十五章-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;第十五章 面向对象编程&quot;&gt;&lt;/a&gt;第十五章 面向对象编程&lt;/h1&gt;&lt;p&gt;面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson20</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer20/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer20/</id>
    <published>2019-02-24T08:09:00.000Z</published>
    <updated>2019-02-24T13:08:47.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-重载操作符与转换"><a href="#第十四章-重载操作符与转换" class="headerlink" title="第十四章 重载操作符与转换"></a>第十四章 重载操作符与转换</h1><p>C++ 允许我们重定义操作符用于类类型对象时的含义。如果需要，可以像内置转换那样使用类类型转换，将一个类型的对象隐式转换到另一类型。</p><a id="more"></a><h2 id="14-1-重载操作符的定义"><a href="#14-1-重载操作符的定义" class="headerlink" title="14.1 重载操作符的定义"></a>14.1 重载操作符的定义</h2><p>重载操作符是具有特殊名称的函数：保留字 operator 后接需定义的操作符号。像任意其他函数一样，重载操作符具有返回类型和形参表。</p><p>用于内置类型的操作符，其含义不能改变。重载操作符必须具有至少一个类类型或枚举类型的操作数。这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。</p><p>操作符的优先级、结合性或操作数目不能改变。不管操作数的类型和操作符的功能定义如何。</p><p>大多数重载操作符可以定义为普通非成员函数或类的成员函数。作为类成员的重载函数，其形参看起来比操作数数目少 1。作为成员函数的操作符有一个隐含的 this 形参，限定为第一个操作数。 </p><p>操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元。</p><h2 id="14-2-输入和输出操作符"><a href="#14-2-输入和输出操作符" class="headerlink" title="14.2 输入和输出操作符"></a>14.2 输入和输出操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">void outstr() &#123;cout &lt;&lt; str1 &lt;&lt; endl;&#125;</span><br><span class="line">friend istream&amp; operator&gt;&gt;(istream&amp;, Myclass&amp;);</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Myclass&amp;);</span><br><span class="line">friend Myclass&amp; operator+(const Myclass&amp;, const Myclass&amp;);</span><br><span class="line">Myclass&amp; operator+=(Myclass&amp;);</span><br><span class="line">private:</span><br><span class="line">string str1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline istream&amp; operator&gt;&gt;(istream&amp; in, Myclass&amp; m) &#123;</span><br><span class="line">in &gt;&gt; m.str1;</span><br><span class="line">return in;</span><br><span class="line">&#125;</span><br><span class="line">inline ostream&amp; operator&lt;&lt;(ostream&amp; out, const Myclass&amp; m) &#123;</span><br><span class="line">out &lt;&lt; m.str1;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-3-算术操作符和关系操作符"><a href="#14-3-算术操作符和关系操作符" class="headerlink" title="14.3 算术操作符和关系操作符"></a>14.3 算术操作符和关系操作符</h2><p>一般而言，将算术和关系操作符定义为非成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline Myclass&amp; Myclass::operator+=(Myclass&amp; r) &#123;</span><br><span class="line">this-&gt;str1 = this-&gt;str1 + r.str1;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Myclass&amp; operator+(const Myclass&amp; l, const Myclass&amp; r) &#123;</span><br><span class="line">Myclass tem;</span><br><span class="line">tem.str1 = l.str1 + r.str1;</span><br><span class="line">return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-5-下标操作符"><a href="#14-5-下标操作符" class="headerlink" title="14.5 下标操作符"></a>14.5 下标操作符</h2><p>下标操作符必须定义为类成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">Myclass() &#123; num = &#123; 1,2,3,4 &#125;; &#125;;</span><br><span class="line">int&amp; operator[](int);</span><br><span class="line">private:</span><br><span class="line">vector&lt;int&gt; num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int&amp; Myclass::operator[](int i) &#123;</span><br><span class="line">return num[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-8-调用操作符和函数对象"><a href="#14-8-调用操作符和函数对象" class="headerlink" title="14.8 调用操作符和函数对象"></a>14.8 调用操作符和函数对象</h2><p>函数调用操作符必须声明为成员函数。定义了调用操作符的类，其对象常称为函数对象，即它们是行为类似函数的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">int operator() (int val)&#123;</span><br><span class="line">return val*val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a;</span><br><span class="line">cout &lt;&lt; a(5);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十四章-重载操作符与转换&quot;&gt;&lt;a href=&quot;#第十四章-重载操作符与转换&quot; class=&quot;headerlink&quot; title=&quot;第十四章 重载操作符与转换&quot;&gt;&lt;/a&gt;第十四章 重载操作符与转换&lt;/h1&gt;&lt;p&gt;C++ 允许我们重定义操作符用于类类型对象时的含义。如果需要，可以像内置转换那样使用类类型转换，将一个类型的对象隐式转换到另一类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson19</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer19/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer19/</id>
    <published>2019-02-24T06:19:00.000Z</published>
    <updated>2019-02-26T14:56:18.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章-复制控制"><a href="#第十三章-复制控制" class="headerlink" title="第十三章 复制控制"></a>第十三章 复制控制</h1><p>当定义一个新类型的时候，需要显式或隐式地指定复制、赋值和撤销该类型的对象时会发生什么——这是通过定义特殊成员：复制构造函数、赋值操作符和析构函数来达到的。如果没有显式定义复制构造函数或赋值操作符，编译器（通常）会为我们定义。</p><a id="more"></a><p><strong>复制构造函数</strong>是一种特殊构造函数，具有单个形参，该形参（常用 const 修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。当将该类型的对象传递给函数或函数返回该类型的对象时，将隐式使用复制构造函数。</p><p><strong>析构函数</strong>是构造函数的互补：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非 static 数据成员的析构函数。</p><p>复制构造函数、赋值操作符和析构函数总称为<strong>复制控制</strong>。</p><h2 id="13-1-复制构造函数"><a href="#13-1-复制构造函数" class="headerlink" title="13.1 复制构造函数"></a>13.1 复制构造函数</h2><p>只有单个形参，而且该形参是对本类类型对象的引用（常用 const 修饰），这样的构造函数称为复制构造函数。与默认构造函数一样，复制构造函数可由编译器隐式调用。复制构造函数可用于：</p><ol><li>根据另一个同类型的对象显式或隐式初始化一个对象。</li><li>复制一个对象，将它作为实参传给一个函数。</li><li>从函数返回时复制一个对象。</li><li>初始化顺序容器中的元素。</li><li>根据元素初始化式列表初始化数组元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">A() :i(5) &#123;&#125;;</span><br><span class="line">A(const A&amp;);</span><br><span class="line">int i;</span><br><span class="line">void outA() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A(const A&amp; a) &#123;</span><br><span class="line">i = 2 * a.i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, b(a);</span><br><span class="line">a.outA();</span><br><span class="line">b.outA();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-1-1-合成的复制构造函数"><a href="#13-1-1-合成的复制构造函数" class="headerlink" title="13.1.1 合成的复制构造函数"></a>13.1.1 合成的复制构造函数</h3><p>如果我们没有定义复制构造函数，编译器就会为我们合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本。</p><h3 id="13-1-3-禁止复制"><a href="#13-1-3-禁止复制" class="headerlink" title="13.1.3 禁止复制"></a>13.1.3 禁止复制</h3><p>有些类需要完全禁止复制。例如，iostream 类就不允许复制。为了防止复制，类必须显式声明其复制构造函数为 private。然而，类的友元和成员仍可以进行复制。如果想要连友元和成员中的复制也禁止，就可以声明一个（private）复制构造函数但不对其定义。</p><h2 id="13-2-赋值操作符"><a href="#13-2-赋值操作符" class="headerlink" title="13.2 赋值操作符"></a>13.2 赋值操作符</h2><p>与复制构造函数一样，如果类没有定义自己的赋值操作符，则编译器会合成一个。</p><p>大多数操作符可以定义为成员函数或非成员函数。当操作符为成员函数时，它的第一个操作数隐式绑定到 this 指针。有些操作符（包括赋值操作符）必须是定义自己的类的成员。因为赋值必须是类的成员，所以 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为 const 引用传递。 </p><p>合成赋值操作符与合成复制构造函数的操作类似。它会执行逐个成员赋值：右操作数对象的每个成员赋值给左操作数对象的对应成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">Myclass(string);</span><br><span class="line">Myclass(Myclass&amp;);</span><br><span class="line">void outstr() &#123;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Myclass&amp; operator=(const Myclass&amp;);</span><br><span class="line">private:</span><br><span class="line">string str1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Myclass&amp; Myclass::operator=(const Myclass&amp; myc1) &#123;</span><br><span class="line">str1 = myc1.str1 + myc1.str1 + myc1.str1;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Myclass::Myclass(string str):str1(str) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Myclass::Myclass(Myclass&amp; myc1) &#123;</span><br><span class="line">str1 = myc1.str1 + myc1.str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a(&quot;123&quot;);</span><br><span class="line">a.outstr();           //123</span><br><span class="line">Myclass&amp; c = a;</span><br><span class="line">Myclass b(c);</span><br><span class="line">b.outstr();           //123123</span><br><span class="line">b = a;</span><br><span class="line">b.outstr();           //123123123</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-3-析构函数"><a href="#13-3-析构函数" class="headerlink" title="13.3 析构函数"></a>13.3 析构函数</h2><p>析构函数通常用于释放在构造函数或在对象生命期内获取的资源。</p><p>与复制构造函数或赋值操作符不同，编译器总是会为我们合成一个析构函数。<strong>合成析构函数</strong>按对象创建时的逆序撤销每个非 static 成员，因此，它按成员在类中声明次序的逆序撤销成员。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。 </p><p>析构函数与复制构造函数或赋值操作符之间的一个重要区别是，即使我们编写了自己的析构函数，合成析构函数仍然运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十三章-复制控制&quot;&gt;&lt;a href=&quot;#第十三章-复制控制&quot; class=&quot;headerlink&quot; title=&quot;第十三章 复制控制&quot;&gt;&lt;/a&gt;第十三章 复制控制&lt;/h1&gt;&lt;p&gt;当定义一个新类型的时候，需要显式或隐式地指定复制、赋值和撤销该类型的对象时会发生什么——这是通过定义特殊成员：复制构造函数、赋值操作符和析构函数来达到的。如果没有显式定义复制构造函数或赋值操作符，编译器（通常）会为我们定义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson18</title>
    <link href="https://zypsola.com/2018/11/10/C++Primer18/"/>
    <id>https://zypsola.com/2018/11/10/C++Primer18/</id>
    <published>2018-11-09T16:03:18.000Z</published>
    <updated>2019-02-23T16:04:02.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-类"><a href="#第十二章-类" class="headerlink" title="第十二章 类"></a>第十二章 类</h1><p>在 C++ 中，用类来定义自己的抽象数据类型（abstract data types）。通过定义类型来对应所要解决的问题中的各种概念，可以使我们更容易编写、调试和修改程序。</p><a id="more"></a><p>类类型常被称为抽象数据类型。抽象数据类型将数据（即状态）和作用于状态的操作视为一个单元。我们可以抽象地考虑类该做什么，而无须知道类如何去完成这些操作。抽象数据类型是面向对象编程和泛型编程的基础。 </p><h2 id="12-1-类的定义和声明"><a href="#12-1-类的定义和声明" class="headerlink" title="12.1 类的定义和声明"></a>12.1 类的定义和声明</h2><h3 id="12-1-1-类定义"><a href="#12-1-1-类定义" class="headerlink" title="12.1.1 类定义"></a>12.1.1 类定义</h3><p>最简单地说，类就是定义了一个新的类型和一个新作用域。</p><p><strong>类成员</strong>:每个类可以没有成员，也可以定义多个成员，成员可以是数据、函数或类型别名。 所有成员必须在类的内部声明，一旦类定义完成后，就没有任何方式可以增加成员了。 </p><p><strong>构造函数</strong>:构造函数是一个特殊的、与类同名的成员函数，用于给每个数据成员设置适当的初始值。 构造函数一般就使用一个构造函数初始化列表，来初始化对象的数据成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong>:在类内部定义的函数默认为inline。 成员函数有一个附加的隐含实参，将函数绑定到调用函数的对象；将关键字 const 加在形参表之后，就可以将成员函数声明为常量。const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声明和定义中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double avg_price() const;</span><br></pre></td></tr></table></figure><h3 id="12-1-2-数据抽象和封装"><a href="#12-1-2-数据抽象和封装" class="headerlink" title="12.1.2 数据抽象和封装"></a>12.1.2 数据抽象和封装</h3><p>类背后蕴涵的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。 </p><p>在C++中，使用访问标号来定义类的抽象接口和实施封装。类型的数据抽象视图由其 public 成员定义。 private 封装了类型的实现细节。 </p><h2 id="12-2-隐含的-this指针"><a href="#12-2-隐含的-this指针" class="headerlink" title="12.2 隐含的 this指针"></a>12.2 隐含的 this指针</h2><p>成员函数具有一个附加的隐含形参，即指向该类对象的一个指针。这个隐含形参命名为 this，与调用成员函数的对象绑定在一起。成员函数不能定义 this 形参，而是由编译器隐含地定义。如果对类成员的引用没有限定，编译器会将这种引用处理成通过 this 指针的引用。 </p><p>尽管在成员函数内部显式引用 this 通常是不必要的，但有一种情况下必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最<br>常见的情况是在这样的函数中使用 this：该函数返回对调用该函数的对象的引用。 </p><p>在普通的非 const 成员函数中，this 的类型是一个指向类类型的 const 指针。可以改变 this 所指向的值，但不能改变 this 所保存的地址。在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。</p><p><strong>可变数据成员</strong></p><p>有时，我们希望类的数据成员（甚至在 const 成员函数内）可以修改。这可以通过将它们声明为 mutable 来实现。 </p><p>可变数据成员永远都不能为 const，甚至当它是 const 对象的成员时也如此。因此，const 成员函数可以改变 mutable 成员。</p><h2 id="12-3-类作用域"><a href="#12-3-类作用域" class="headerlink" title="12.3 类作用域"></a>12.3 类作用域</h2><p>如果返回类型使用由类定义的类型，则必须使用完全限定名： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123; </span><br><span class="line">   public: </span><br><span class="line">       typedef std::string::size_type index; </span><br><span class="line">       index get_cursor() const; </span><br><span class="line">   &#125;; </span><br><span class="line">   inline Screen::index Screen::get_cursor() const </span><br><span class="line">   &#123; </span><br><span class="line">       return cursor; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="12-4-构造函数"><a href="#12-4-构造函数" class="headerlink" title="12.4 构造函数"></a>12.4 构造函数</h2><p>构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值。</p><p><strong>构造函数可以被重载</strong></p><p><strong>构造函数自动执行</strong></p><p><strong>构造函数不能声明为const</strong></p><h3 id="12-4-1-构造函数初始化式"><a href="#12-4-1-构造函数初始化式" class="headerlink" title="12.4.1 构造函数初始化式"></a>12.4.1 构造函数初始化式</h3><p>构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。构造函数初始化只在构造函数的定义中而不是声明中指定。 </p><p>从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。 不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。 </p><p>有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。 </p><p><strong>成员初始化的次序</strong></p><p>构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。</p><p>初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数。可以使用该类型的任意构造函数。</p><h3 id="12-4-2-默认实参与构造函数"><a href="#12-4-2-默认实参与构造函数" class="headerlink" title="12.4.2 默认实参与构造函数"></a>12.4.2 默认实参与构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book = &quot;&quot;):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-3-默认构造函数"><a href="#12-4-3-默认构造函数" class="headerlink" title="12.4.3 默认构造函数"></a>12.4.3 默认构造函数</h3><p>只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。 </p><h3 id="12-4-4-隐式类类型转换"><a href="#12-4-4-隐式类类型转换" class="headerlink" title="12.4.4 隐式类类型转换"></a>12.4.4 隐式类类型转换</h3><p>可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.same_isbn(cin);</span><br></pre></td></tr></table></figure><p><strong>抑制由构造函数定义的隐式转换</strong>：可以通过将构造函数声明为 explicit，来防止在需要隐式转换的上下文中使用构造函数。explicit 关键字只能用于类内部的构造函数声明上。在类的定义体外部所做的定义上不再重复它。</p><p><strong>为转换而显式地使用构造函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book = &quot;9-999-99999-9&quot;; </span><br><span class="line">item.same_isbn(Sales_item(null_book))</span><br></pre></td></tr></table></figure><h3 id="12-4-5-类成员的显式初始化"><a href="#12-4-5-类成员的显式初始化" class="headerlink" title="12.4.5 类成员的显式初始化"></a>12.4.5 类成员的显式初始化</h3><p>对于没有定义构造函数并且其全体数据成员均为 public 的类，可以采用与初始化数组元素相同的方式初始化其成员。根据数据成员的声明次序来使用初始化式。</p><h2 id="12-5-友元"><a href="#12-5-友元" class="headerlink" title="12.5 友元"></a>12.5 友元</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字 friend 开始。它只能出现在类定义的内部。友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A1;</span><br><span class="line">class A2;</span><br><span class="line"></span><br><span class="line">class A1 &#123;</span><br><span class="line">public:</span><br><span class="line">A1() :a(1) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">friend int addA12(A1 a1, A2 a2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 &#123;</span><br><span class="line">public:</span><br><span class="line">A2() :a(2) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">friend int addA12(A1 a1, A2 a2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int addA12(A1 a1, A2 a2) &#123;</span><br><span class="line">return a1.a + a2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A1 aa;</span><br><span class="line">A2 ab;</span><br><span class="line">cout &lt;&lt; addA12(aa, ab) &lt;&lt; endl;       //3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-static类成员"><a href="#12-6-static类成员" class="headerlink" title="12.6 static类成员"></a>12.6 static类成员</h2><p>通常，非 static 数据成员存在于类类型的每个对象中。static 数据成员独立于该类的任意对象而存在；每个 static 数据成员是与类关联的对象，并不与该类的对象相关联。</p><p>static 成员函数没有 this 形参，它可以直接访问所属类的 static 成员，但不能直接使用非 static 成员。</p><p>当我们在类的外部定义 static 成员时，无须重复指定 static 保留字，该保留字只出现在类定义体内部的声明处。</p><p>static 数据成员必须在类定义体的外部定义（正好一次）。不像普通数据成员，static 成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><p><strong>抽象数据类型：</strong>使用封装来隐藏其实现的数据结构，允许使用类型的程序员抽象地考虑该类型做什么，而不是具体地考虑类型如何表示。</p></li><li><p><strong>封装：</strong>实现与接口的分离。封闭隐藏了类型的实现细节。在 C++ 中，实施封装可以阻止普通用户访问类的 private 部分。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十二章-类&quot;&gt;&lt;a href=&quot;#第十二章-类&quot; class=&quot;headerlink&quot; title=&quot;第十二章 类&quot;&gt;&lt;/a&gt;第十二章 类&lt;/h1&gt;&lt;p&gt;在 C++ 中，用类来定义自己的抽象数据类型（abstract data types）。通过定义类型来对应所要解决的问题中的各种概念，可以使我们更容易编写、调试和修改程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson17</title>
    <link href="https://zypsola.com/2018/11/07/C++Primer17/"/>
    <id>https://zypsola.com/2018/11/07/C++Primer17/</id>
    <published>2018-11-07T09:21:36.000Z</published>
    <updated>2018-11-09T16:02:51.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章-泛型算法"><a href="#第十一章-泛型算法" class="headerlink" title="第十一章 泛型算法"></a>第十一章 泛型算法</h1><p>标准库并没有为每种容器类型都定义实现这些操作的成员函数，而是定义了一组<strong>泛型算法</strong>：因为它们实现共同的操作，所以称之为“算法”；而“泛型”指的是它们可以操作在多种容器类型上——不但可作用于vector或list这些标准库类型，还可用在内置数组类型、甚至其他类型的序列上。自定义的容器类型只要与标准库兼容，同样可以使用这些泛型算法。 </p><a id="more"></a><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>泛型算法本身从不执行容器操作，只是单独依赖迭代器和迭代器操作实现。</p><p>大多数情况下，每个算法都需要使用（至少）两个迭代器指出该算法操纵的元素范围。第一个迭代器指向第一个元素，而第二个迭代器则指向最后一个元素的下一位置。第二个迭代器所指向的元素［有时被称为超出末端迭代器］本身不是要操作的元素，而被用作终止遍历的哨兵。 </p><h2 id="11-2-初窥算法"><a href="#11-2-初窥算法" class="headerlink" title="11.2 初窥算法"></a>11.2 初窥算法</h2><p>使用泛型算法必须包含 algorithm 头文件，标准库还定义了一组泛化的算术算法，其命名习惯与泛型算法相同。使用这些算法则必须包含 numeric 头文件。</p><p>除了少数例外情况，所有算法都在一段范围内的元素上操作。带有输入范围参数的算法总是使用头两个形参标记该范围。这两个形参是分别指向要处理的第一个元素和最后一个元素的下一位置的迭代器。 </p><p>理解算法的最基本方法是了解该算法是否读元素、写元素或者对元素进行重新排序。</p><h3 id="11-2-1-只读算法"><a href="#11-2-1-只读算法" class="headerlink" title="11.2.1 只读算法"></a>11.2.1 只读算法</h3><p>许多算法只会读取其输入范围内的元素，而不会写这些元素。find 就是一个这样的算法。另一个简单的只读算法是 accumulate，该算法在 numeric 头文件中定义。</p><p>accumulate 带有三个形参。头两个形参指定要累加的元素范围。第三个形参则是累加的初值。用于指定累加起始值的第三个实参是必要的，因为 accumulate 对将要累加的元素类型一无所知，因此，除此之外，没有别的办法创建合适的起始值或者关联的类型。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10, 5);</span><br><span class="line">cout &lt;&lt; static_cast&lt;int&gt;(accumulate(ivec.begin(), ivec.end(), 0)) &lt;&lt; endl;      //50</span><br><span class="line">vector&lt;string&gt; cvec(3, &quot;ab&quot;);</span><br><span class="line">string str = accumulate(cvec.begin(), cvec.end(), static_cast&lt;string&gt;(&quot;ccc&quot;));</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;          //cccababab</span><br></pre></td></tr></table></figure><h3 id="11-2-2-写容器元素的算法"><a href="#11-2-2-写容器元素的算法" class="headerlink" title="11.2.2 写容器元素的算法"></a>11.2.2 写容器元素的算法</h3><p>写入到输入序列的算法本质上是安全的——只会写入与指定输入范围数量相同的元素。 </p><p>fill 带有一对迭代器形参，用于指定要写入的范围，而所写的值是它的第三个形参的副本。fill_n 函数带有的参数包括：一个迭代器、一个计数器以及一个值。该函数从迭代器指向的元素开始，将指定数量的元素设置为给定的值。对指定数目的元素做写入运算，或者写到目标迭代器的算法，都不检查目标的大小是否足以存储要写入的元素。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10, 5);</span><br><span class="line">fill(ivec.begin(), ivec.end(), 6);</span><br><span class="line">fill_n(ivec.begin(), 5, 10);</span><br><span class="line">cout &lt;&lt; static_cast&lt;int&gt;(accumulate(ivec.begin(), ivec.end(), 0)) &lt;&lt; endl;      //80</span><br></pre></td></tr></table></figure><p><strong>引入back_inserter</strong></p><p>确保算法有足够的元素存储输出数据的一种方法是使用<strong>插入迭代器</strong>。插入迭代器是可以给基础容器添加元素的迭代器。通常，用迭代器给容器元素赋值时，被赋值的是迭代器所指向的元素。而使用插入迭代器赋值时，则会在容器中添加一个新元素，其值等于赋值运算的右操作数的值。使用back_inserter必须包含 iterator 头文件</p><p>back_inserter函数是迭代器适配器。与容器适配器一样，迭代器适配器使用一个对象作为实参，并生成一个适应其实参行为的新对象。</p><p>传递给 back_inserter 的实参是一个容器的引用。back_inserter 生成一个绑定在该容器上的插入迭代器。在试图通过这个迭代器给元素赋值时，赋值运算将调用 push_back 在容器中添加一个具有指定值的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(5, 4);</span><br><span class="line">fill_n(back_inserter(ivec), 5, 1);       //4 4 4 4 4 1 1 1 1 1</span><br></pre></td></tr></table></figure><p>copy 带有三个迭代器参数：头两个指定输入范围，第三个则指向目标序列的一个元素。传递给 copy 的目标序列必须至少要与输入范围一样大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; ilst(2, 5);</span><br><span class="line">vector&lt;int&gt; ivec(3, 7);</span><br><span class="line">copy(ilst.begin(), ilst.end(), ivec.begin());      //5 5 7</span><br><span class="line">copy(ilst.begin(), ilst.end(), back_inserter(ivec));   //5 5 7 5 5</span><br></pre></td></tr></table></figure><p>replace算法对输入序列做读写操作，将序列中特定的值替换为新的值。该算法带有四个形参：一对指定输入范围的迭代器和两个值。每一个等于第一值的元素替换成第二个值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(ivec.begin(), ivec.end(), 5, 9);</span><br></pre></td></tr></table></figure><h3 id="11-2-3-对容器元素重新排序的算法"><a href="#11-2-3-对容器元素重新排序的算法" class="headerlink" title="11.2.3 对容器元素重新排序的算法"></a>11.2.3 对容器元素重新排序的算法</h3><p>unique 算法带有两个指定元素范围的迭代器参数。该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器，表示无重复的值范围的结束。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[8] = &#123; 1,3,5,5,3,3,5,1 &#125;;</span><br><span class="line">vector&lt;int&gt; ivec(a, a + 8);</span><br><span class="line">vector&lt;int&gt;::iterator end_uni = unique(ivec.begin(), ivec.end());   //ivec:1,3,5,3,5,1,5,1</span><br><span class="line">vector&lt;int&gt;::iterator iter = ivec.begin();</span><br><span class="line">while (iter != end_uni) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;         //135351</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique 实际上并没有删除任何元素，而是将无重复的元素复制到序列的前端，从而覆盖相邻的重复元素。unique 返回的迭代器指向超出无重复的元素范围末端的下一位置。 </p><p><strong>stable_sort 和 count_if</strong>。使用这些算法，还需要一个配套的实用函数，称为<strong>谓词</strong>。谓词是做某些检测的函数，返回用于条件判断的类型，指出条件是否成立。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool smaller(const int &amp;v1,const int &amp;v2) &#123;</span><br><span class="line">return v1 &lt; v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool more5(const int &amp;v) &#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[8] = &#123; 1,3,6,5,4,8,5,9 &#125;;</span><br><span class="line">vector&lt;int&gt; ivec(a, a + 8);</span><br><span class="line">cout &lt;&lt; count_if(ivec.begin(), ivec.end(), more5) &lt;&lt; endl;   //3</span><br><span class="line">sort(ivec.begin(), ivec.end(), smaller);</span><br><span class="line">vector&lt;int&gt;::iterator iter = ivec.begin();</span><br><span class="line">while (iter != ivec.end()) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;       //13455689</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-再谈迭代器"><a href="#11-3-再谈迭代器" class="headerlink" title="11.3 再谈迭代器"></a>11.3 再谈迭代器</h2><p>标准库所定义的迭代器不依赖于特定的容器。事实上，C++语言还提供了另外三种迭代器： </p><ol><li><p>插入迭代器：这类迭代器与容器绑定在一起，实现在容器中插入元素的功能。 </p></li><li><p>iostream 迭代器：这类迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 </p></li><li><p>反向迭代器：这类迭代器实现向后遍历，而不是向前遍历。所有容器类型都定义了自己的 reverse_iterator 类型，由 rbegin 和 rend 成员函数返回。 </p></li></ol><h3 id="11-3-1-插入迭代器"><a href="#11-3-1-插入迭代器" class="headerlink" title="11.3.1 插入迭代器"></a>11.3.1 插入迭代器</h3><p>back_inserter，创建使用 push_back 实现插入的迭代器。 </p><p>front_inserter，使用 push_front 实现插入。 </p><p>inserter，使用 insert 实现插入操作。除了所关联的容器外，inserter还带有第二实参：指向插入起始位置的迭代器。 </p><h3 id="11-3-2-iostream-迭代器"><a href="#11-3-2-iostream-迭代器" class="headerlink" title="11.3.2 iostream 迭代器"></a>11.3.2 iostream 迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;T&gt; in(strm);      //创建从输入流 strm 中读取 T 类型对象的 istream_iterator 对象 </span><br><span class="line">istream_iterator&lt;T&gt; in;            //istream_iterator 对象的超出末端迭代器 </span><br><span class="line">ostream_iterator&lt;T&gt; in(strm);      //创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象 </span><br><span class="line">ostream_iterator&lt;T&gt; in(strm, delim);     //创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象，在写入过程中使用 delim 作为元素的分隔符。delim 是以空字符结束的字符数组</span><br></pre></td></tr></table></figure><p>这个程序读 cin，并将每个读入的值依次写到 cout 中不同的行中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;string&gt; out_iter(cout, &quot;\n&quot;);</span><br><span class="line">istream_iterator&lt;string&gt; in_iter(cin), eof;</span><br><span class="line">while (in_iter != eof) &#123;</span><br><span class="line">*out_iter++ = *in_iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可能从 ostream_iterator 对象读入，也不可能写到 istream_iterator 对象中。 </p><p>一旦给 ostream_iterator 对象赋了一个值，写入就提交了。赋值后，没有办法再改变这个值。此外，ostream_iterator 对象中每个不同的值都只能正好输出一次。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; cin_it(cin), end_of_stream;</span><br><span class="line">vector&lt;int&gt; vec(cin_it, end_of_stream);       //输入：3 109 45 89 6 34 12 90 34 23 56 23 8 89 23</span><br><span class="line">sort(vec.begin(), vec.end());</span><br><span class="line">ostream_iterator&lt;int&gt; output(cout, &quot; &quot;);</span><br><span class="line">unique_copy(vec.begin(), vec.end(), output);      //6 8 12 23 34 45 56 89 90 109</span><br></pre></td></tr></table></figure><h3 id="11-3-3-反向迭代器"><a href="#11-3-3-反向迭代器" class="headerlink" title="11.3.3 反向迭代器"></a>11.3.3 反向迭代器</h3><p>反向迭代器是一种反向遍历容器的迭代器。也就是，从最后一个元素到第一个元素遍历容器。反向迭代器将自增（和自减）的含义反过来了：对于反向迭代器，++ 运算将访问前一个元素，而 – 运算则访问下一个元素。 </p><p>流迭代器不能创建反向迭代器。</p><h3 id="11-3-4-const-迭代器"><a href="#11-3-4-const-迭代器" class="headerlink" title="11.3.4 const 迭代器"></a>11.3.4 const 迭代器</h3><p>不希望使用这个迭代器来修改容器中的元素。 </p><h3 id="11-3-5-五种迭代器"><a href="#11-3-5-五种迭代器" class="headerlink" title="11.3.5 五种迭代器"></a>11.3.5 五种迭代器</h3><p>输入迭代器：读，不能写；只支持自增运算<br>输出迭代器：写，不能读；只支持自增运算<br>前向迭代器：读和写；只支持自增运算<br>双向迭代器：读和写；支持自增和自减运算<br>随机访问迭代器：读和写；支持完整的迭代器算术运算 </p><h2 id="11-4-泛型算法的结构"><a href="#11-4-泛型算法的结构" class="headerlink" title="11.4 泛型算法的结构"></a>11.4 泛型算法的结构</h2><p>大多数算法采用下面四种形式之一： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg (beg, end, other parms); </span><br><span class="line">alg (beg, end, dest, other parms); </span><br><span class="line">alg (beg, end, beg2, other parms); </span><br><span class="line">alg (beg, end, beg2, end2, other parms)</span><br></pre></td></tr></table></figure><p>其中，alg 是算法的名字，beg 和 end 指定算法操作的元素范围。其他形参：dest、beg2 和 end2，它们都是迭代器。有些算法还带有其他的非迭代器形参。</p><h2 id="11-5-容器特有的算法"><a href="#11-5-容器特有的算法" class="headerlink" title="11.5 容器特有的算法"></a>11.5 容器特有的算法</h2><p>list 容器上的迭代器是双向的，而不是随机访问类型。由于 list 容器不支持随机访问，因此，在此容器上不能使用需要随机访问迭代器的算法。这些算法包括 sort 及其相关的算法。还有一些其他的泛型算法，如 merge、remove、reverse 和 unique，虽然可以用在 list 上，但却付出了性能上的代价。</p><p><strong>list 容器特有的操作</strong></p><p>对于 list 对象，应该优先使用 list 容器特有的成员版本，而不是泛型算法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst.merge(lst2) </span><br><span class="line">lst.merge(lst2, comp)</span><br></pre></td></tr></table></figure><p>将 lst2 的元素合并到 lst 中。这两个 list 容器对象都必须排序。lst2 中的元素将被删除。合并后，lst2 为空。返回 void 类型。第一个版本使用 &lt; 操作符，而第二个版本则使用 comp 指定的比较运算 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst.remove(val) </span><br><span class="line">lst.remove_if(unaryPred)</span><br></pre></td></tr></table></figure><p>调用 lst.erase 删除所有等于指定值或使指定的谓词函数返回非零值的元素。返回 void 类型 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十一章-泛型算法&quot;&gt;&lt;a href=&quot;#第十一章-泛型算法&quot; class=&quot;headerlink&quot; title=&quot;第十一章 泛型算法&quot;&gt;&lt;/a&gt;第十一章 泛型算法&lt;/h1&gt;&lt;p&gt;标准库并没有为每种容器类型都定义实现这些操作的成员函数，而是定义了一组&lt;strong&gt;泛型算法&lt;/strong&gt;：因为它们实现共同的操作，所以称之为“算法”；而“泛型”指的是它们可以操作在多种容器类型上——不但可作用于vector或list这些标准库类型，还可用在内置数组类型、甚至其他类型的序列上。自定义的容器类型只要与标准库兼容，同样可以使用这些泛型算法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson16</title>
    <link href="https://zypsola.com/2018/11/06/C++Primer16/"/>
    <id>https://zypsola.com/2018/11/06/C++Primer16/</id>
    <published>2018-11-06T13:26:16.000Z</published>
    <updated>2018-11-07T09:19:53.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-关联容器"><a href="#第十章-关联容器" class="headerlink" title="第十章 关联容器"></a>第十章 关联容器</h1><p><strong>关联容器</strong>和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。 </p><a id="more"></a><p>关联容器（Associative containers）支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map、set。map 的元素以键－值（key-value）对的形式组织：键用作元素在 map 中的索引，而值则表示所存储和读取的数据。set 仅包含一个键，并有效地支持关于某个键是否存在的查询。 </p><p>set 和 map 类型的对象所包含的元素都具有不同的键，不允许为同一个键添加第二个元素。如果一个键必须对应多个实例，则需使用 multimap 或 multiset，这两种类型允许多个元素拥有相同的键。 </p><h2 id="10-1-引言：pair类型"><a href="#10-1-引言：pair类型" class="headerlink" title="10.1 引言：pair类型"></a>10.1 引言：pair类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;         创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用值初始化</span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2); 创建一个 pair 对象，它的两个元素分别是 T1 和 T2 ，其中 first 成员初始化为 v1，而 second 成员初始化为 v2 </span><br><span class="line">make_pair(v1, v2)        以 v1 和 v2 值创建一个新 pair 对象，其元素类型分别是 v1 和 v2 的类型 </span><br><span class="line">p1 &lt; p2    两个 pair 对象之间的小于运算，其定义遵循字典次序：如果 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second，则返回 true </span><br><span class="line">p1 == p2   如果两个 pair 对象的 first 和 second 成员依次相等，则这两个对象相等。该运算使用其元素的 == 操作符 </span><br><span class="line">p.first    返回 p 中名为 first 的（公有）数据成员 </span><br><span class="line">p.second   返回 p 的名为 second 的（公有）数据成员</span><br></pre></td></tr></table></figure><p>与其他标准库类型不同，对于 pair 类，可以直接访问其数据成员：其成员都是仅有的，分别命名为 first 和 second。只需使用普通的点操作符——成员访问标志即可访问其成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, string&gt; b = make_pair(4, &quot;afsd&quot;);  </span><br><span class="line">cout &lt;&lt; b.first &lt;&lt; b.second &lt;&lt; endl;   //4afsd</span><br><span class="line">b = pair&lt;int, string&gt;(6, &quot;ggg&quot;);</span><br><span class="line">cout &lt;&lt; b.first &lt;&lt; b.second &lt;&lt; endl;   //6ggg</span><br></pre></td></tr></table></figure><h2 id="10-2-关联容器"><a href="#10-2-关联容器" class="headerlink" title="10.2 关联容器"></a>10.2 关联容器</h2><p>关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供 front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 </p><ol><li><p>三种构造函数：C<t> c; C<t> c1(c2);  C<t> c(b, e); 关联容器不能通过容器大小来定义，因为这样的话就无法知道键所对应的值是什么。 </t></t></t></p></li><li><p>关系运算。</p></li><li><p>begin、end、rbegin 和 rend 操作。 </p></li><li><p>swap 和赋值操作。但关联容器不提供 assign 函数。</p></li><li><p>clear 和 erase 操作，但关联容器的 erase 运算返回 void 类型。 </p></li><li><p>关于容器大小的操作。但 resize 函数不能用于关联容器。</p></li></ol><h2 id="10-3-map类型"><a href="#10-3-map类型" class="headerlink" title="10.3 map类型"></a>10.3 map类型</h2><p>map 是键－值对的集合。map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。而关联的本质在于元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取。 </p><h3 id="10-3-1-map对象的定义"><a href="#10-3-1-map对象的定义" class="headerlink" title="10.3.1 map对象的定义"></a>10.3.1 map对象的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;k, v&gt; m;         创建一个名为 m 的空 map 对象，其键和值的类型分别为 k 和 v</span><br><span class="line">map&lt;k, v&gt; m(m2);     创建 m2 的副本 m，m 与 m2 必须有相同的键类型和值类型 </span><br><span class="line">map&lt;k, v&gt; m(b, e);   创建 map 类型的对象 m，存储迭代器 b 和 e 标记的范围内所有元素的副本。元素的类型必须能转换为 pair&lt;const k, v&gt;</span><br></pre></td></tr></table></figure><p>在使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。默认情况下，标准库使用键类型定义的 &lt; 操作符来实现键（key type）的比较。</p><p>所用的比较函数必须在键类型上定义严格弱排序（strict weak ordering）。所谓的严格弱排序可理解为键类型数据上的“小于”关系，虽然实际上可以选择将比较函数设计得更复杂。但无论这样的比较函数如何定义，当用于一个键与自身的比较时，肯定会导致 false 结果。此外，在比较两个键时，不能出现相互“小于”的情况，而且，如果 k1“小于”k2，k2“小于”k3，则 k1 必然“小于”k3。对于两个键，如果它们相互之间都不存在“小于”关系，则容器将之视为相同的键。用做 map 对象的键时，可使用任意一个键值来访问相应的元素。 </p><h3 id="10-3-2-map定义的类型"><a href="#10-3-2-map定义的类型" class="headerlink" title="10.3.2 map定义的类型"></a>10.3.2 map定义的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt;::key_type    在 map 容器中，用做索引的键的类型 </span><br><span class="line">map&lt;K, V&gt;::mapped_type 在 map 容器中，键所关联的值的类型 </span><br><span class="line">map&lt;K, V&gt;::value_type  一个 pair 类型，它的 first 元素具有 const map&lt;K, V&gt;::key_type 类型，而 second 元素则为 map&lt;K, V&gt;::mapped_type 类型</span><br></pre></td></tr></table></figure><p>value_type 是 pair 类型，它的值成员可以修改，但键成员不能修改。 </p><p>对迭代器进行解引用时，将获得一个引用，指向容器中一个 value_type 类型的值。对于 map 容器，其 value_type 是 pair 类型。</p><h3 id="10-3-3-给map添加元素"><a href="#10-3-3-给map添加元素" class="headerlink" title="10.3.3 给map添加元素"></a>10.3.3 给map添加元素</h3><p>可使用 insert 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。</p><h3 id="10-3-4-使用下标访问map对象"><a href="#10-3-4-使用下标访问map对象" class="headerlink" title="10.3.4 使用下标访问map对象"></a>10.3.4 使用下标访问map对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m[&quot;abc&quot;] = 5;</span><br><span class="line">m[&quot;Abc&quot;] = 3;</span><br><span class="line">map&lt;string, int&gt;::iterator iter = m.begin();</span><br><span class="line">cout &lt;&lt; (*iter).first &lt;&lt; (*iter).second &lt;&lt; endl;     //Abc3</span><br><span class="line">cout &lt;&lt; m.size() &lt;&lt; endl;                            //2</span><br></pre></td></tr></table></figure><p>map 的下标也使用索引（键）来获取该键所关联的值。如果该键已在容器中，则 map 的下标运算与 vector 的下标运算行为相同：返回该键所关联的值。只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。</p><h3 id="10-3-5-map-insert-的使用"><a href="#10-3-5-map-insert-的使用" class="headerlink" title="10.3.5 map::insert 的使用"></a>10.3.5 map::insert 的使用</h3><ol><li><p>m.insert(e)        e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则插入一个值为 e.second 的新元素；如果该键在 m 中已存在，则保持 m 不变。该函数返回一个 pair 类型对象，包含指向键为 e.first 的元素的 map 迭代器，以及一个 bool 类型的对象，表示是否插入了该元素 </p></li><li><p>m.insert(beg, end) beg 和 end 是标记元素范围的迭代器，其中的元素必须为 m.value_type 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。返回 void 类型 </p></li><li><p>m.insert(iter, e)  e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则创建新元素，并以迭代器 iter 为起点搜索新元素存储的位置。返回一个迭代器，指向 m 中具有给定键的元素 </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef map&lt;string, int&gt;::value_type valType;</span><br><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m.insert(map&lt;string, int&gt;::value_type(&quot;afd&quot;, 7));</span><br><span class="line">m.insert(make_pair(&quot;4df&quot;, 1));</span><br><span class="line">m.insert(valType(&quot;123&quot;, 9));</span><br></pre></td></tr></table></figure><h3 id="10-3-6-查找并读取map中的元素"><a href="#10-3-6-查找并读取map中的元素" class="headerlink" title="10.3.6 查找并读取map中的元素"></a>10.3.6 查找并读取map中的元素</h3><p>下标操作符给出了读取一个值的最简单方法，但是，使用下标存在一个很危险的副作用：如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。 </p><p>map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.count(k)  返回m中k的出现次数 </span><br><span class="line">m.find(k)   如果m容器中存在按k索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代</span><br></pre></td></tr></table></figure><p>对于 map 对象，count 成员的返回值只能是 0 或 1。map 容器只允许一个键对应一个实例，所以 count 可有效地表明一个键是否存在。</p><h3 id="10-3-7-从-map-对象中删除元素"><a href="#10-3-7-从-map-对象中删除元素" class="headerlink" title="10.3.7 从 map 对象中删除元素"></a>10.3.7 从 map 对象中删除元素</h3><p>map 容器的 erase 操作返回 void。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.erase(k)     删除 m 中键为 k 的元素。返回被删除元素的个数。对于 map 容器，该值必然是 0 或 1。如果返回 0，则表示欲删除的元素在 map 不存在。 </span><br><span class="line">m.erase(p)     从 m 中删除迭代器 p 所指向的元素。p 必须指向 m 中确实存在的元素，而且不能等于 m.end()。返回 void </span><br><span class="line">m.erase(b, e)  从 m 中删除一段范围内的元素，该范围由迭代器对 b 和 e 标记。b 和 e 必须标记 m 中的一段有效范围：即 b 和 e 都必须指向 m 中的元素或最后一个元素的下一个位置。而且，b 和 e 要么相等（此时删除的范围为空），要么 b 所指向的元素必须出现在 e 所指向的元素之前。返回 void 类型</span><br></pre></td></tr></table></figure><h2 id="10-4-set"><a href="#10-4-set" class="headerlink" title="10.4 set"></a>10.4 set</h2><p>set 容器只是单纯的键的集合。</p><p>set 容器支持大部分的 map 操作，set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。它们指的都是 set 中存储的元素类型。</p><p><strong>从set中获取元素</strong></p><p>set 容器不提供下标操作符。为了通过键从 set 中获取元素，可使用 find 运算。如果只需简单地判断某个元素是否存在，同样可以使用 count 运算，返回 set 中该键对应的元素个数。当然，对于 set 容器，count 的返回值只能是 1（该元素存在）或 0（该元素不存在）。</p><p>set 中的键也为 const。在获得指向 set 中某元素的迭代器后，只能对其做读操作，而不能做写操作。</p><h2 id="10-5-multimap和multiset类型"><a href="#10-5-multimap和multiset类型" class="headerlink" title="10.5. multimap和multiset类型"></a>10.5. multimap和multiset类型</h2><p>multiset和multimap类型允许一个键对应多个实例。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。不能对 multimap 对象使用下标操作，因为在这类容器中，某个键可能对应多个值。</p><h3 id="10-5-1-元素的添加和删除"><a href="#10-5-1-元素的添加和删除" class="headerlink" title="10.5.1 元素的添加和删除"></a>10.5.1 元素的添加和删除</h3><p>由于键不要求是唯一的，因此每次调用 insert 总会添加一个元素。</p><p>带有一个键参数的 erase 版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回 void 类型。</p><h3 id="10-5-2-在multimap和multiset中查找元素"><a href="#10-5-2-在multimap和multiset中查找元素" class="headerlink" title="10.5.2 在multimap和multiset中查找元素"></a>10.5.2 在multimap和multiset中查找元素</h3><p>count 函数求出某键出现的次数，而 find 操作则返回一个迭代器，指向第一个拥有正在查找的键的实例。</p><p><strong>lower_bound 和 upper_bound</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.lower_bound(k)  返回一个迭代器，指向键不小于 k 的第一个元素 </span><br><span class="line">m.upper_bound(k)  返回一个迭代器，指向键大于 k 的第一个元素 </span><br><span class="line">m.equal_range(k)  返回一个迭代器的 pair 对象，它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十章-关联容器&quot;&gt;&lt;a href=&quot;#第十章-关联容器&quot; class=&quot;headerlink&quot; title=&quot;第十章 关联容器&quot;&gt;&lt;/a&gt;第十章 关联容器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;关联容器&lt;/strong&gt;和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson15</title>
    <link href="https://zypsola.com/2018/11/05/C++Primer15/"/>
    <id>https://zypsola.com/2018/11/05/C++Primer15/</id>
    <published>2018-11-05T15:43:41.000Z</published>
    <updated>2018-11-06T14:49:49.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><p>容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是<strong>顺序容器</strong>。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。 </p><a id="more"></a><p>标准库定义了三种顺序容器类型：<strong>vector</strong>(支持快速随机访问)、<strong>list</strong>(支持快速插入/删除)和<strong>deque</strong>(双端队列)。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括<strong>stack</strong>(后进先出LIFO堆栈)、<strong>queue</strong>(先进先出FIFO队列)和<strong>priority_queue</strong>(有优先级管理的队列)类型。</p><h2 id="9-1-顺序容器的定义"><a href="#9-1-顺序容器的定义" class="headerlink" title="9.1 顺序容器的定义"></a>9.1 顺序容器的定义</h2><p>所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C&lt;T&gt; c;    创建一个的空容器，适用于所有容器。 </span><br><span class="line">C c(c2);   创建容器 c2 的副本；c 和 c2 必须具有相同的容器类型，相同类型的元素。适用于所有容器。 </span><br><span class="line">C c(b, e); 创建 c，其元素是迭代器 b 和 e 标示的范围内元素的副本。适用于所有容器。 </span><br><span class="line">C c(n, t); 用 n 个值为 t 的元素创建容器 c，其中值 t 必须是容器类型 C 的元素类型的值，或者是可转换为该类型的值。 只适用于顺序容器。 </span><br><span class="line">C c(n);    创建有 n 个值初始化元素的容器 c。 只适用于顺序容器。</span><br></pre></td></tr></table></figure><p><strong>初始化为一段元素的副本</strong></p><p>尽管不能直接将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要它们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *words[] = &#123; &quot;asd&quot;,&quot;gfd&quot;,&quot;qwe&quot; &#125;;</span><br><span class="line">vector&lt;string&gt; svec(words, words + sizeof(words) / sizeof(char*));</span><br><span class="line">vector&lt;string&gt;::iterator iter = svec.begin();</span><br><span class="line">list&lt;string&gt; slist(svec.begin(), svec.end());</span><br><span class="line">list&lt;string&gt;::iterator iter2 = slist.begin();</span><br><span class="line">while (iter != svec.end() &amp;&amp; iter2 != slist.end())&#123;</span><br><span class="line">cout &lt;&lt; *iter++ &lt;&lt; *iter2++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容器内元素的类型约束</strong></p><p>大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。除了引用类型外，所有内置<br>或复合类型都可用做元素类型。此外，关联容器的键类型还需满足其他的约束。IO 库类型不支持复制或赋值。因此，不能创建存放 IO 类型对象的容器。</p><h2 id="9-2-迭代器和迭代器范围"><a href="#9-2-迭代器和迭代器范围" class="headerlink" title="9.2 迭代器和迭代器范围"></a>9.2 迭代器和迭代器范围</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*iter       返回迭代器 iter 所指向的元素的引用 </span><br><span class="line">iter-&gt;mem   对 iter 进行解引用，等效于(*iter).mem</span><br><span class="line">iter++;++iter;iter--;--iter;==;!=</span><br></pre></td></tr></table></figure><p><strong>vector和deque容器的迭代器提供额外的运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iter + n;iter - n;</span><br><span class="line">iter += n;iter -= iter;</span><br><span class="line">iter1 - iter2;</span><br><span class="line">&gt;,&gt;=,&lt;,&lt;=;</span><br></pre></td></tr></table></figure><h3 id="9-2-1-迭代器范围"><a href="#9-2-1-迭代器范围" class="headerlink" title="9.2.1 迭代器范围"></a>9.2.1 迭代器范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.begin();C.end();</span><br></pre></td></tr></table></figure><h3 id="9-2-2-使迭代器失效的容器操作"><a href="#9-2-2-使迭代器失效的容器操作" class="headerlink" title="9.2.2 使迭代器失效的容器操作"></a>9.2.2 使迭代器失效的容器操作</h3><p>一些容器操作会修改容器的内在状态或移动容器内的元素。这样的操作使所有指向被移动的元素的迭代器失效，也可能同时使其他迭代器失效。使用无效迭代器是没有定义的，可能会导致与悬垂指针相同的问题。 </p><h2 id="9-3-每种顺序容器都提供了一组有用的类型定义以及以下操作"><a href="#9-3-每种顺序容器都提供了一组有用的类型定义以及以下操作" class="headerlink" title="9.3 每种顺序容器都提供了一组有用的类型定义以及以下操作"></a>9.3 每种顺序容器都提供了一组有用的类型定义以及以下操作</h2><p>在容器中添加元素。<br>在容器中删除元素。<br>设置容器大小。<br>（如果有的话）获取容器内的第一个和最后一个元素。</p><h3 id="9-3-1-容器定义的类型别名"><a href="#9-3-1-容器定义的类型别名" class="headerlink" title="9.3.1 容器定义的类型别名"></a>9.3.1 容器定义的类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_type   无符号整型，足以存储此容器类型的最大可能容器长度 </span><br><span class="line">iterator    此容器类型的迭代器类型 </span><br><span class="line">const_iterator    元素的只读迭代器类型 </span><br><span class="line">reverse_iterator  按逆序寻址元素的迭代器 </span><br><span class="line">const_reverse_iterator  元素的只读（不能写）逆序迭代器 </span><br><span class="line">difference_type   足够存储两个迭代器差值的有符号整型，可为负数 </span><br><span class="line">value_type        元素类型 </span><br><span class="line">reference         元素的左值类型，是 value_type&amp; 的同义词 </span><br><span class="line">const_reference   元素的常量左值类型，等效于 const value_type&amp;</span><br></pre></td></tr></table></figure><h3 id="9-3-2-begin和end成员"><a href="#9-3-2-begin和end成员" class="headerlink" title="9.3.2 begin和end成员"></a>9.3.2 begin和end成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.begin()   返回一个迭代器，指向 c 的第一个元素 </span><br><span class="line">c.end()     返回一个迭代器，指向 c 的最后一个元素的下一位置 </span><br><span class="line">c.rbegin()  返回一个逆序迭代器，指向 c 的最后一个元素 </span><br><span class="line">c.rend()    返回一个逆序迭代器，指向 c 的第一个元素前面的位置</span><br></pre></td></tr></table></figure><p>这些操作返回什么类型取决于容器是否为 const。如果容器不是 const，则这些操作返回 iterator 或 reverse_iterator 类型。如果容器是 const，则其返回类型要加上 const_ 前缀，也就是 const_iterator 和 const_reverse_iterator 类型。</p><h3 id="9-3-3-在顺序容器中添加元素"><a href="#9-3-3-在顺序容器中添加元素" class="headerlink" title="9.3.3 在顺序容器中添加元素"></a>9.3.3 在顺序容器中添加元素</h3><p>所有顺序容器都支持push_back操作，提供在容器尾部插入一个元素的功能。</p><p>除了 push_back 运算，list 和 deque 容器类型还提供了类似的操作：push_front。这个操作实现在容器首部插入新元素的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.push_back(t)   在容器 c 的尾部添加值为 t 的元素。返回 void 类型 </span><br><span class="line">c.push_front(t)  在容器 c 的前端添加值为 t 的元素。返回 void 类型，只适用于 list 和 deque 容器类型 </span><br><span class="line">c.insert(p,t)    在迭代器 p 所指向的元素前面插入值为 t 的新元素。返回指向新添加元素的迭代器</span><br><span class="line">c.insert(p,n,t)  在迭代器 p 所指向的元素前面插入 n 个值为 t 的新元素。返回 void 类型</span><br><span class="line">c.insert(p,b,e)  在迭代器 p 所指向的元素前面插入由迭代器 b 和 e 标记的范围内的元素。返回 void 类型</span><br></pre></td></tr></table></figure><h3 id="9-3-4-关系操作符"><a href="#9-3-4-关系操作符" class="headerlink" title="9.3.4 关系操作符"></a>9.3.4 关系操作符</h3><p>所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。容器的比较使用了元素类型定义的同<br>一个关系操作符：两个容器做 != 比较使用了其元素类型定义的 != 操作符。如果容器的元素类型不支持某种操作符，则该容器就不能做这种比较运算。 </p><p>如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。 </p><p>如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。 </p><p>如果两个容器都不是对文的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。 </p><h3 id="9-3-5-容器大小的操作"><a href="#9-3-5-容器大小的操作" class="headerlink" title="9.3.5 容器大小的操作"></a>9.3.5 容器大小的操作</h3><p>所有容器类型都提供四种与容器大小相关的操。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.size()       返回容器 c 中的元素个数。返回类型为 c::size_type </span><br><span class="line">c.max_size()   返回容器 c 可容纳的最多元素个数，返回类型为 c::size_type </span><br><span class="line">c.empty()      返回标记容器大小是否为 0 的布尔值 </span><br><span class="line">c.resize(n)    调整容器 c 的长度大小，使其能容纳 n 个元素，如果 n &lt; c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素 </span><br><span class="line">c.resize(n,t)  调整容器 c 的长度大小，使其能容纳 n 个元素。所有新添加的元素值都为 t</span><br></pre></td></tr></table></figure><h3 id="9-3-6-访问元素"><a href="#9-3-6-访问元素" class="headerlink" title="9.3.6 访问元素"></a>9.3.6 访问元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.back()   返回容器 c 的最后一个元素的引用。如果 c 为空，则该操作未定义 </span><br><span class="line">c.front()  返回容器 c 的第一个元素的引用。如果 c 为空，则该操作未定义</span><br><span class="line">c[n]       返回下标为 n 的元素的引用 如果 n &lt;0 或 n &gt;= c.size()，则该操作未定义，只适用于vector和deque</span><br><span class="line">c.at(n)    返回下标为 n 的元素的引用。如果下标越界，则该操作未定义，只适用于vector和deque</span><br></pre></td></tr></table></figure><h3 id="9-3-7-删除元素"><a href="#9-3-7-删除元素" class="headerlink" title="9.3.7 删除元素"></a>9.3.7 删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.erase(p)    删除p所指向的元素，返回一个迭代器，它指向被删除元素后面的元素。如果p指向容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置 </span><br><span class="line">c.erase(b,e)  删除b和e所标记的范围内所有的元素，返回一个迭代器，它指向被删除元素段后面的元素。如果e本身就是指向超出末端的下一位置的迭代器，则返回的迭代器也指向容器的超出末端的下一位置</span><br><span class="line">c.clear()     删除容器c内的所有元素。返回 void </span><br><span class="line">c.pop_back()  删除容器c的最后一个元素。返回 void。如果c为空容器，则该函数未定义 </span><br><span class="line">c.pop_front() 删除容器c的第一个元素。返回 void。如果c为空容器，则该函数未定义，只适用于 list 或 deque 容器</span><br></pre></td></tr></table></figure><h3 id="9-3-8-赋值与swap"><a href="#9-3-8-赋值与swap" class="headerlink" title="9.3.8 赋值与swap"></a>9.3.8 赋值与swap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2        删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和c2 的类型（包括容器类型和元素类型）必须相同 </span><br><span class="line">c1.swap(c2)    交换内容：c1 中存放的是 c2 原来的元素，c2 中存放的则是 c1 原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 复制到 c1 的操作快 </span><br><span class="line">c.assign(b,e)  重新设置 c 的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器 </span><br><span class="line">c.assign(n,t)  将容器 c 重新设置为存储 n 个值为 t 的元素</span><br></pre></td></tr></table></figure><p>swap操作不会删除或插入任何元素，而且保证在常量时间内实现交换。由于容器内没有移动任何元素，因此迭代器不会失效。 </p><h2 id="9-4-vector容器的自增长"><a href="#9-4-vector容器的自增长" class="headerlink" title="9.4 vector容器的自增长"></a>9.4 vector容器的自增长</h2><p>为了支持快速的随机访问，vector 容器的元素以连续的方式存放：每一个元素都紧挨着前一个元素存储。 </p><p>为了使 vector 容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些。vector 容器预留了这些额外的存储区，用于存放新添加的元素。</p><p>在实际应用中，比起 list 和 deque 容器，vector 的增长效率通常会更高。 </p><h3 id="9-4-1-capacity和reserve成员"><a href="#9-4-1-capacity和reserve成员" class="headerlink" title="9.4.1 capacity和reserve成员"></a>9.4.1 capacity和reserve成员</h3><p>vector容器处理内存分配的细节是其实现的一部分。然而，该实现部分是由vector的接口支持的。vector类提供了两个成员函数：capacity和reserve使程序员可与vector容器内存分配的实现部分交互工作。capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而reserve操作则告诉vector容器应该预留多少个元素的存储空间。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; svec(10);</span><br><span class="line">cout &lt;&lt; svec.capacity() &lt;&lt; endl;     //10</span><br><span class="line">svec.reserve(50);</span><br><span class="line">cout &lt;&lt; svec.capacity() &lt;&lt; endl;     //50</span><br></pre></td></tr></table></figure><h2 id="9-5-容器的选用"><a href="#9-5-容器的选用" class="headerlink" title="9.5 容器的选用"></a>9.5 容器的选用</h2><p>程序使用这些操作的程序将决定应该选择哪种类型的容器。vector和deque容器提供了对元素的快速随机访问，但付出的代价是，在容器的任意位置插入或删除元素，比在容器尾部插入和删除的开销更大。list类型在任何位置都能快速插入和删除，但付出的代价是元素的随机访问开销较大。 </p><p><strong>插入操作如何影响容器的选择</strong></p><p>list 容器表示不连续的内存区域，允许向前和向后逐个遍历元素。在任何位置都可高效地 insert 或 erase 一个元素。插入或删除 list 容器中的一个元素不需要移动任何其他元素。另一方面，list 容器不支持随机访问，访问某个元素要求遍历涉及的其他元素。 </p><p>对于 vector 容器，除了容器尾部外，其他任何位置上的插入（或删除）操作都要求移动被插入（或删除）元素右边所有的元素。</p><p>deque 容器拥有更加复杂的数据结构。从 deque 队列的两端插入和删除元素都非常快。在容器中间插入或删除付出的代价将更高。</p><p><strong>元素的访问如何影响容器的选择</strong></p><p>vector 和 deque 容器都支持对其元素实现高效的随机访问。由于 vector 容器的每次访问都是距离其起点的固定偏移，因此其随机访问非常有效率。在 list 容器中，上述跳跃访问会变得慢很多。在 list 容器的元素之间移动的唯一方法是顺序跟随指针。</p><h2 id="再谈string类型"><a href="#再谈string类型" class="headerlink" title="再谈string类型"></a>再谈string类型</h2><p>string 类型还支持大多数顺序容器操作。在某些方面，可将 string 类型视为字符容器。除了一些特殊操作，string 类型提供与 vector 容器相同的操作。string 类型与 vector 容器不同的是，它不支持以栈方式操纵容器：在 string 类型中不能使用 front、back 和 pop_back 操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;123&quot;;</span><br><span class="line">string::iterator iter = str.begin();</span><br><span class="line">while (iter != str.end()) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只适用于string类型的操作"><a href="#只适用于string类型的操作" class="headerlink" title="只适用于string类型的操作"></a>只适用于string类型的操作</h3><p><strong>子串操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos, n) 返回一个 string 类型的字符串，它包含 s 中从下标 pos 开始的 n 个字符 </span><br><span class="line">s.substr(pos)    返回一个 string 类型的字符串，它包含从下标 pos 开始到 s 末尾的所有字符 </span><br><span class="line">s.substr()       返回 s 的副本</span><br></pre></td></tr></table></figure><p><strong>append和replace</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.append( args)           将 args 串接在 s 后面。返回 s 引用 </span><br><span class="line">s.replace(pos, len, args) 删除 s 中从下标 pos 开始的 len 个字符，用 args 指定的字符替换之。返回 s 的引用，在这个版本中，args 不能为 b2，e2 </span><br><span class="line">s.replace(b, e, args)     删除迭代器 b 和 e 标记范围内所有的字符，用 args 替换之。返回 s 的引用，在这个版本中，args 不能为 s2，pos2，len2</span><br></pre></td></tr></table></figure><p><strong>append和replace的args</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s2              string 类型的字符串 s2 </span><br><span class="line">s2, pos2, len2  字符串 s2 中从下标 pos2 开始的 len2 个字符 </span><br><span class="line">cp              指针 cp 指向的以空字符结束的数组 </span><br><span class="line">cp, len2        cp 指向的以空字符结束的数组中前 len2 个字符 </span><br><span class="line">n, c            字符 c 的 n 个副本 </span><br><span class="line">b2, e2          迭代器 b2 和 e2 标记的范围内所有字符</span><br></pre></td></tr></table></figure><p><strong>find</strong></p><p>string 类提供了6种查找函数，每种函数以不同形式的 find 命名。这些操作全都返回 string::size_type 类型的值，以下标形式标记查找匹配所发生的位置；或者返回一个名为 string::npos 的特殊值，说明查找没有匹配。string 类将 npos 定义为保证大于任何有效下标的值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.find( args)   在 s 中查找 args 的第一次出现 </span><br><span class="line">s.rfind( args)  在 s 中查找 args 的最后一次出现 </span><br><span class="line">s.find_first_of( args)   在 s 中查找 args 的任意字符的第一次出现 </span><br><span class="line">s.find_last_of( args)    在 s 中查找 args 的任意字符的最后一次出现</span><br><span class="line">s.find_first_not_of( args)  在 s 中查找第一个不属于 args 的字符 </span><br><span class="line">s.find_last_not_of( args)   在 s 中查找最后一个不属于 args 的字符</span><br></pre></td></tr></table></figure><p><strong>find的args</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c, pos      在 s 中，从下标 pos 标记的位置开始，查找字符 c。pos 的默认值为 0 </span><br><span class="line">s2, pos     在 s 中，从下标 pos 标记的位置开始，查找 string 对象 s2。pos 的默认值为 0 </span><br><span class="line">cp, pos     在 s 中，从下标 pos 标记的位置形参，查找指针 cp 所指向的 C 风格的以空字符结束的字符串。pos 的默认值为 0 </span><br><span class="line">cp, pos, n  在 s 中，从下标 pos 标记的位置开始，查找指针 cp 所指向数组的前 n 个字符。pos 和 n 都没有默认值</span><br></pre></td></tr></table></figure><p><strong>查找任意字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string numbers = &quot;0123456789&quot;;</span><br><span class="line">string str = &quot;ab5bz9&quot;;</span><br><span class="line">cout &lt;&lt; str.find_first_of(numbers);      //2</span><br></pre></td></tr></table></figure><p><strong>compare 函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.compare(s2)                        比较 s 和 s2 </span><br><span class="line">s.compare(pos1, n1, s2)              让 s 中从 pos 下标位置开始的 n1 个字符与 s2 做比较 </span><br><span class="line">s.compare(pos1, n1, s2, pos2, n2)    让 s 中从 pos1 下标位置开始的 n1 个字符与 s2 中从 pos2 下标位置开始的 n2 个字符做比较 </span><br><span class="line">s.compare(cp)               比较 s 和 cp 所指向的以空字符结束的字符串 </span><br><span class="line">s.compare(pos1, n1, cp)     让 s 中从 pos1 下标位置开始的 n1 个字符与 cp 所指向的字符串做比较 </span><br><span class="line">s.compare(pos1, n1, cp, n2) 让 s 中从 pos1 下标位置开始的 n1 个字符与 cp 所指向的字符串的前 n2 个字符做比较</span><br></pre></td></tr></table></figure><h2 id="9-7-容器适配器"><a href="#9-7-容器适配器" class="headerlink" title="9.7 容器适配器"></a>9.7 容器适配器</h2><p>除了顺序容器，标准库还提供了三种顺序容器适配器：<strong>queue</strong>、<strong>priority_queue</strong>和<strong>stack</strong>。适配器(adaptor)是标准库中通用的概念，包括容器适配器、迭代器适配器和函数适配器。本质上，适配器是使一事物的行为类似于另一事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;    // stack adaptor </span><br><span class="line">#include &lt;queue&gt;    // both queue and priority_queue adaptors</span><br></pre></td></tr></table></figure><p><strong>适配器的初始化</strong></p><p>所有适配器都定义了两个构造函数：默认构造函数用于创建空对象，而带一个容器参数的构造函数将参数容器的副本作为其基础值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deq(10);</span><br><span class="line">stack&lt;int&gt; mystack(deq);</span><br></pre></td></tr></table></figure><p><strong>覆盖基础容器类型</strong></p><p>默认的 stack 和 queue 都基于 deque 容器实现，而 priority_queue 则在 vector 容器上实现。在创建适配器时，通过将一个顺序容器指定为适配器的第二个类型实参，可覆盖其关联的基础容器类型： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec(10);</span><br><span class="line">stack&lt;int,vector&lt;int&gt;&gt; mystack(vec);</span><br></pre></td></tr></table></figure><p>对于给定的适配器，其关联的容器必须满足一定的约束条件。stack 适配器所关联的基础容器可以是任意一种顺序容器类型。因此，stack 栈可以建立在 vector、list 或者 deque 容器之上。而 queue 适配器要求其关联的基础容器必须提供 push_front 运算，因此只能建立在 list 容器上，而不能建立在 vector 容器上。priority_queue 适配器要求提供随机访问功能，因此可建立在 vector 或 deque 容器上，但不能建立在 list 容器上。 </p><h3 id="9-7-1-栈适配器"><a href="#9-7-1-栈适配器" class="headerlink" title="9.7.1 栈适配器"></a>9.7.1 栈适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.empty()     如果栈为空，则返回 true，否则返回 stack</span><br><span class="line">s.size()      返回栈中元素的个数 </span><br><span class="line">s.pop()       删除栈顶元素的值，但不返回其值 </span><br><span class="line">s.top()       返回栈顶元素的值，但不删除该元素</span><br><span class="line">s.push(item)  在栈顶压入新元素</span><br></pre></td></tr></table></figure><h3 id="9-7-2-队列和优先级队列"><a href="#9-7-2-队列和优先级队列" class="headerlink" title="9.7.2 队列和优先级队列"></a>9.7.2 队列和优先级队列</h3><p>priority_queue 允许用户为队列中存储的元素设置优先级。这种队列不是直接将新元素放置在队列尾部，而是放在比它优先级低的元素前面。标准库默认使用元素类型的 &lt; 操作符来确定它们之间的优先级关系。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.empty()     如果队列为空，则返回 true，否则返回 false </span><br><span class="line">q.size()      返回队列中元素的个数 </span><br><span class="line">q.pop()       删除队首元素，但不返回其值 </span><br><span class="line">q.front()     返回队首元素的值，但不删除该元素 该操作只适用于队列 </span><br><span class="line">q.back()      返回队尾元素的值，但不删除该元素 该操作只适用于队列 </span><br><span class="line">q.top()       返回具有最高优先级的元素值，但不删除该元素 该操作只适用于优先级队列 </span><br><span class="line">q.push(item)  对于 queue，在队尾压入一个新元素，对于 priority_quue，在基于优先级的适当位置插入新元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第九章-顺序容器&quot;&gt;&lt;a href=&quot;#第九章-顺序容器&quot; class=&quot;headerlink&quot; title=&quot;第九章 顺序容器&quot;&gt;&lt;/a&gt;第九章 顺序容器&lt;/h1&gt;&lt;p&gt;容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是&lt;strong&gt;顺序容器&lt;/strong&gt;。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson14</title>
    <link href="https://zypsola.com/2018/11/02/C++Primer14/"/>
    <id>https://zypsola.com/2018/11/02/C++Primer14/</id>
    <published>2018-11-02T12:54:55.000Z</published>
    <updated>2018-11-05T15:42:29.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-标准IO库"><a href="#第八章-标准IO库" class="headerlink" title="第八章 标准IO库"></a>第八章 标准IO库</h1><p>C++ 的输入／输出由标准库提供。标准库定义了一族类型，支持对文件和控制窗口等设备的读写（IO）。还定义了其他一些类型，使 string 对象能够像文件一样操作，从而使我们无须 IO 就能实现数据与字符之间的转换。这些 IO 类型都定义了如何读写内置数据类型的值。</p><a id="more"></a><h2 id="8-1-面向对象的标准库"><a href="#8-1-面向对象的标准库" class="headerlink" title="8.1 面向对象的标准库"></a>8.1 面向对象的标准库</h2><p>IO 类型在三个独立的头文件中定义：iostream 定义读写控制窗口的类型，fstream 定义读写已命名文件的类型，而 sstream 所定义的类型则用于读写存储在内存中的 string 对象。在 fstream 和 sstream 里定义的每种类型都是从 iostream 头文件中定义的相关类型派生而来。</p><p><strong>国际字符的支持</strong></p><p>标准库还定义了一组相关的类型，支持 wchar_t 类型。每个类都加上“w”前缀，以此与 char 类型的版本区分开来。</p><p><strong>IO 对象不可复制或赋值</strong></p><p>形参或返回类型也不能为流类型。如果需要传递或返回 IO 对象，则必须传递或返回指向该对象的指针或引用。</p><p>一般情况下，如果要传递IO对象以便对它进行读写，可用非const引用的方式传递这个流对象。对IO对象的读写会改变它的状态，因此引用必须是非const的。 </p><h2 id="8-2-条件状态"><a href="#8-2-条件状态" class="headerlink" title="8.2 条件状态"></a>8.2 条件状态</h2><p>IO 标准库管理一系列<strong>条件状态</strong>（condition state）成员，用来标记给定的 IO 对象是否处于可用状态，或者碰到了哪种特定的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strm::iostate     机器相关的整型名，由各个 iostream 类定义，用于定义条件状态 </span><br><span class="line">strm::badbit      strm::iostate 类型的值，用于指出被破坏的流 </span><br><span class="line">strm::failbit     strm::iostate 类型的值，用于指出失败的 IO 操作 </span><br><span class="line">strm::eofbit      strm::iostate 类型的值，用于指出流已经到达文件结束符</span><br><span class="line">strm::goodbit     strm::iostate 类型的值，用于指出流未处于错误状态</span><br><span class="line">s.eof()           如果设置了流 s 的 eofbit 值，则该函数返回 true </span><br><span class="line">s.fail()          如果设置了流 s 的 failbit 值，则该函数返回 true </span><br><span class="line">s.bad()           如果设置了流 s 的 badbit 值，则该函数返回 true </span><br><span class="line">s.good()          如果流 s 处于有效状态，则该函数返回 true </span><br><span class="line">s.clear()         将流 s 中的所有状态值都重设为有效状态/复位，返回void</span><br><span class="line">s.clear(flag)     将流 s 中的某个指定条件状态设置为有效/复位。flag 的类型是strm::iostate，返回void</span><br><span class="line">s.setstate(flag)  将流 s 中对应条件状态位置位。flag 的类型是 strm::iostate，返回void</span><br><span class="line">s.rdstate()       返回流 s 的当前条件，返回值类型为 strm::iostate</span><br></pre></td></tr></table></figure><p>IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能，这个类型应作为一个位集合来使用。</p><p>badbit表示系统级错误，如不可恢复的读写错误，通常，一旦badbit被置位，流就无法使用了。发生可恢复错误后，failbit被置位，如期望读数值却读出一个字符等错误。如果到达文件结束位置，eofbit与failbit都会被置位。goodbit的值为0表示流未发生错误。若badbit、failbit和eofbit任何一个被置位，则检测流状态的条件会失败。</p><h2 id="8-3-输出缓冲区的管理"><a href="#8-3-输出缓冲区的管理" class="headerlink" title="8.3 输出缓冲区的管理"></a>8.3 输出缓冲区的管理</h2><p>每个 IO 对象管理一个缓冲区，用于存储程序读写的数据。</p><p>下面几种情况将导致缓冲区的内容被刷新，即写入到真实的输出设备或者文件： </p><ol><li><p>程序正常结束。作为main函数的return操作的一部分，将清空所有输出缓冲区。</p></li><li><p>缓冲区满时，缓冲区将会在写下一个值之前刷新。 </p></li><li><p>用操纵符显式地刷新缓冲区，例如行结束符endl。</p></li><li><p>在每次输出操作执行完后，用unitbuf操作符设置流的内部状态，从而清空缓冲区。默认cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</p></li><li><p>一个输出流可能被关联到另一个流。此时，当读写被关联的流时，关联到的流的缓冲区会被刷新，如默认cin与cerr都关联到cout。</p></li></ol><p>我们的程序已经使用过endl操纵符，用于输出一个换行符并刷新缓冲区。除此之外，C++语言还提供了另外两个类似的操纵符。第一个经常使用的flush，用于刷新流，但不在输出中添加任何字符。第二个则是比较少用的ends，这个操纵符在缓冲区中插入空字符null，然后后刷新它。</p><p><strong>unitbuf操纵符</strong></p><p>若需要每次输出操作后都刷新缓冲区，可使用unitbuf操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf &lt;&lt; &quot;first&quot; &lt;&lt; &quot; second&quot; &lt;&lt; nounitbuf; </span><br><span class="line">//等价于：</span><br><span class="line">cout &lt;&lt; &quot;first&quot; &lt;&lt; flush &lt;&lt; &quot; second&quot; &lt;&lt; flush</span><br></pre></td></tr></table></figure><p>nounitbuf 操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。</p><p><strong>关联输入输出流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ostream *old_tie = cin.tie();  //返回指向原关联流的指针</span><br><span class="line">cin.tie(&amp;cerr);</span><br></pre></td></tr></table></figure><h2 id="8-4-文件输入输出"><a href="#8-4-文件输入输出" class="headerlink" title="8.4 文件输入输出"></a>8.4 文件输入输出</h2><p>fstream 头文件定义了三种支持文件 IO 的类型： </p><ol><li>ifstream，由 istream 派生而来，提供读文件的功能。 </li><li>ofstream，由 ostream 派生而来，提供写文件的功能。 </li><li>fstream，由 iostream 派生而来，提供读写同一个文件的功能。 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fstream file(&quot;123.txt&quot;);</span><br><span class="line">file.close();</span><br><span class="line">file.open(&quot;123.txt&quot;);</span><br><span class="line">file &lt;&lt; 12345;      //写入12345</span><br></pre></td></tr></table></figure><p>当一个fstream对象被销毁时，close会自动被调用。</p><p><strong>文件模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in        以读方式打开</span><br><span class="line">out       以写方式打开</span><br><span class="line">app       每次写操作前定位到文件末尾</span><br><span class="line">ate       打开文件后立即定位到文件末尾</span><br><span class="line">trunc     打开文件时清空已存在的文件流</span><br><span class="line">binary    以二进制模式进行 IO 操作</span><br></pre></td></tr></table></figure><p>如果需要重用文件流读写多个文件，必须在读另一个文件之前调用 clear 清除该流的状态。 </p><h2 id="8-5-字符串流"><a href="#8-5-字符串流" class="headerlink" title="8.5 字符串流"></a>8.5 字符串流</h2><p>stringstream strm;    创建自由的 stringstream 对象<br>stringstream strm(s); 创建存储 s 的副本的 stringstream 对象，其中 s 是 string 类型的对象<br>strm.str()  返回 strm 中存储的 string 类型对象<br>strm.str(s) 将 string 类型的 s 复制给 strm，返回 void </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ostringstream ostr;</span><br><span class="line">ostr &lt;&lt; 123;</span><br><span class="line">string line, word;</span><br><span class="line">while (getline(cin, line)) &#123;            //输入：ad fes</span><br><span class="line">istringstream strstream(line);</span><br><span class="line">while (strstream &gt;&gt; word) &#123;</span><br><span class="line">ostr &lt;&lt; word;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ostr.str();           //123adfes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第八章-标准IO库&quot;&gt;&lt;a href=&quot;#第八章-标准IO库&quot; class=&quot;headerlink&quot; title=&quot;第八章 标准IO库&quot;&gt;&lt;/a&gt;第八章 标准IO库&lt;/h1&gt;&lt;p&gt;C++ 的输入／输出由标准库提供。标准库定义了一族类型，支持对文件和控制窗口等设备的读写（IO）。还定义了其他一些类型，使 string 对象能够像文件一样操作，从而使我们无须 IO 就能实现数据与字符之间的转换。这些 IO 类型都定义了如何读写内置数据类型的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson13</title>
    <link href="https://zypsola.com/2018/11/01/C++Primer13/"/>
    <id>https://zypsola.com/2018/11/01/C++Primer13/</id>
    <published>2018-11-01T15:49:11.000Z</published>
    <updated>2018-11-02T12:53:42.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="7-8-重载函数"><a href="#7-8-重载函数" class="headerlink" title="7.8 重载函数"></a>7.8 重载函数</h2><p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为<strong>重载函数</strong>。 </p><a id="more"></a><p>任何程序都仅有一个 main 函数的实例。main 函数不能重载。 </p><p>如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。</p><p>有些看起来不相同的形参表本质上是相同的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(const Account &amp;acct); </span><br><span class="line">   Record lookup(const Account&amp;);</span><br><span class="line"></span><br><span class="line">   typedef Phone Telno; </span><br><span class="line">   Record lookup(const Phone&amp;); </span><br><span class="line">   Record lookup(const Telno&amp;);</span><br><span class="line"></span><br><span class="line">   Record lookup(const Phone&amp;, const Name&amp;);</span><br><span class="line">   Record lookup(const Phone&amp;, const Name&amp; = &quot;&quot;); </span><br><span class="line"></span><br><span class="line">   Record lookup(Phone); </span><br><span class="line">   Record lookup(const Phone);</span><br></pre></td></tr></table></figure><h3 id="7-8-1-重载与作用域"><a href="#7-8-1-重载与作用域" class="headerlink" title="7.8.1 重载与作用域"></a>7.8.1 重载与作用域</h3><p>一般的作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。由此推论，每一个版本的重载函数都应在同一个作用域中声明。 </p><h3 id="7-8-2-函数匹配与实参转换"><a href="#7-8-2-函数匹配与实参转换" class="headerlink" title="7.8.2 函数匹配与实参转换"></a>7.8.2 函数匹配与实参转换</h3><p>函数<strong>重载确定</strong>，即<strong>函数匹配</strong>是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。匹配结果有三种可能： </p><ol><li><p>编译器找到与实参<strong>最佳匹配</strong>的函数，并生成调用该函数的代码。 </p></li><li><p>找不到形参与函数调用的实参匹配的函数，在这种情况下，编译器将给出编译错误信息。 </p></li><li><p>存在多个与实参匹配的函数，但没有一个是明显的最佳选择。这种情况也是，该调用具有<strong>二义性</strong>。 </p></li></ol><h3 id="7-8-3-重载确定的三个步骤"><a href="#7-8-3-重载确定的三个步骤" class="headerlink" title="7.8.3 重载确定的三个步骤"></a>7.8.3 重载确定的三个步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void f(); </span><br><span class="line">void f(int); </span><br><span class="line">void f(int, int); </span><br><span class="line">void f(double, double = 3.14); </span><br><span class="line">f(5.6);  // calls void f(double, double)</span><br></pre></td></tr></table></figure><p>函数重载确定的第一步是确定该调用所考虑的重载函数集合，该集合中的函数称为<strong>候选函数</strong>。</p><p>第二步是从候选函数中选择一个或多个函数，它们能够用该调用中指定的实参来调用。因此，选出来的函数称为<strong>可行函数</strong>。可行函数必须满足两个条件：第一，函数的形参个数与该调用的实参个数相同；第二，每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型。 </p><p>如果函数具有默认实参，则调用该函数时，所用的实参可能比实际需要的少。默认实参也是实参，在函数匹配过程中，它的处理方式与其他实参一样。 </p><p>函数重载确定的第三步是确定与函数调用中使用的实际参数匹配最佳的可行函数。这个过程考虑函数调用中的每一个实参，选择对应形参与之最匹配的一个或多个可行函数。其原则是实参类型与形参类型越接近则匹配越佳。因此，实参类型与形参类型之间的精确类型匹配比需要转换的匹配好。 </p><p>如果函数调用使用了两个或两个以上的显式实参，则函数匹配会更加复杂。假设有两样的名为 f 的函数，分析下面的函数调用： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(42, 2.56);</span><br></pre></td></tr></table></figure><p>在本例中，可行函数是 f(int, int) 和 f(double, double)。接下来，编译器通过依次检查每一个实参来决定哪个或哪些函数匹配最佳。如果有且仅有一个函数满足下列条件，则匹配成功： </p><ol><li><p>其每个实参的匹配都不劣于其他可行函数需要的匹配。 </p></li><li><p>至少有一个实参的匹配优于其他可行函数提供的匹配。 </p></li></ol><p>这个调用有二义性：每个可行函数都对函数调用的一个实参实现更好的匹配。编译器将产生错误。解决这样的二义性，可通过显式的强制类型转换强制函数匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(static_cast&lt;double&gt;(42), 2.56);  // calls f(double, double) </span><br><span class="line">f(42, static_cast&lt;int&gt;(2.56));     // calls f(int, int)</span><br></pre></td></tr></table></figure><h3 id="7-8-4-实参类型转换"><a href="#7-8-4-实参类型转换" class="headerlink" title="7.8.4 实参类型转换"></a>7.8.4 实参类型转换</h3><p>为了确定最佳匹配，编译器将实参类型到相应形参类型转换划分等级。转换等级以降序排列如下： </p><ol><li><p>精确匹配。实参与形参类型相同。 </p></li><li><p>通过类型提升实现的匹配。 </p></li><li><p>通过标准转换实现的匹配。 </p></li><li><p>通过类类型转换实现的匹配。 </p></li></ol><p>必须注意的一个重点是较小的整型提升为 int 型。假设有两个函数，一个的形参为 int 型，另一个的形参则是 short 型。对于任意整型的实参值，int 型版本都是优于 short 型版本的较佳匹配，即使从形式上看 short 型版本的匹配较佳:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ff(int); </span><br><span class="line">void ff(short); </span><br><span class="line">ff(&apos;a&apos;);    // char promotes to int, so matches ff(int)</span><br></pre></td></tr></table></figure><p>字面值常量 3.14 的类型为 double。这种类型既可转为 long 型也可转为 float 型。由于两者都是可行的标准转换，因此该调用具有二义性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern void manip(long); </span><br><span class="line">extern void manip(float); </span><br><span class="line">manip(3.14);  // error: ambiguous call</span><br></pre></td></tr></table></figure><p><strong>参数匹配和枚举类型</strong></p><p>回顾枚举类型enum，我们知道这种类型的对象只能用同一枚举类型的另一个对象或一个枚举成员进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Tokens &#123;INLINE = 128, VIRTUAL = 129&#125;; </span><br><span class="line">void ff(Tokens); </span><br><span class="line">void ff(int); </span><br><span class="line">int main() &#123; </span><br><span class="line">    Tokens curTok = INLINE; </span><br><span class="line">    ff(128);    // exactly matches ff(int) </span><br><span class="line">    ff(INLINE); // exactly matches ff(Tokens) </span><br><span class="line">    ff(curTok); // exactly matches ff(Tokens) </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整型形参。此时，枚举值被提升为 int 型或更大的整型。具体的提升类型取决于枚举成员的值。</p><p><strong>重载和const形参</strong></p><p>仅当形参是引用或指针时，形参是否为 const 才有影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun(int &amp;a)&#123;return ++a;&#125;</span><br><span class="line">int fun(const int &amp;a) &#123;return a;&#125;</span><br><span class="line"></span><br><span class="line">const int a(5);</span><br><span class="line">int b(5);</span><br><span class="line">cout &lt;&lt; fun(a) &lt;&lt; endl;   //5</span><br><span class="line">cout &lt;&lt; fun(b) &lt;&lt; endl;   //6</span><br></pre></td></tr></table></figure><p>不能基于指针本身是否为 const 来实现函数的重载： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *a)</span><br><span class="line">int fun(int *const a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *a)&#123;return ++*a;&#125;</span><br><span class="line">int fun(const int *a) &#123;return *a;&#125;</span><br><span class="line"></span><br><span class="line">const int a(5);</span><br><span class="line">int b(5);</span><br><span class="line">cout &lt;&lt; fun(&amp;a) &lt;&lt; endl;   //5</span><br><span class="line">cout &lt;&lt; fun(&amp;b) &lt;&lt; endl;   //6</span><br></pre></td></tr></table></figure><h2 id="7-9-指向函数的指针"><a href="#7-9-指向函数的指针" class="headerlink" title="7.9 指向函数的指针"></a>7.9 指向函数的指针</h2><p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int(*pf)(int, int);</span><br><span class="line"></span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pf = &amp;sum;      //or pf = sum;</span><br><span class="line">cout &lt;&lt; pf(3, 4) &lt;&lt; endl;   //7</span><br><span class="line">cout &lt;&lt; (*pf)(3, 4) &lt;&lt; endl;  //7</span><br></pre></td></tr></table></figure><p><strong>用 typedef 简化函数指针的定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef int(*pf)(int, int);</span><br><span class="line"></span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pf p = &amp;sum;    //or pf p = sum;</span><br><span class="line">cout &lt;&lt; p(3, 4) &lt;&lt; endl;    //7</span><br><span class="line">cout &lt;&lt; (*p)(3, 4) &lt;&lt; endl;   //7</span><br></pre></td></tr></table></figure><p><strong>函数指针形参</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int sum2(int v1, int v2, int a(int, int)) &#123;     //or int (*a)(int, int) or pf a</span><br><span class="line">return a(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pf p = sum;</span><br><span class="line">cout &lt;&lt; sum2(3, 4, p) &lt;&lt; endl;   //7</span><br></pre></td></tr></table></figure><p><strong>返回指向函数的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int(*sum3())(int, int) &#123;     //or pf sum3() &#123;...&#125;</span><br><span class="line">pf p = sum;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">pf p = sum;</span><br><span class="line">cout &lt;&lt; sum2(3, 4, sum3()) &lt;&lt; endl;   //7</span><br></pre></td></tr></table></figure><p><strong>指向重载函数的指针</strong></p><p>C++ 语言允许使用函数指针指向重载的函数。指针的类型必须与重载函数的一个版本精确匹配。如果没有精确匹配的函数，则对该指针的初始化或赋值都将导致编译错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第七章-函数&quot;&gt;&lt;a href=&quot;#第七章-函数&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数&quot;&gt;&lt;/a&gt;第七章 函数&lt;/h1&gt;&lt;h2 id=&quot;7-8-重载函数&quot;&gt;&lt;a href=&quot;#7-8-重载函数&quot; class=&quot;headerlink&quot; title=&quot;7.8 重载函数&quot;&gt;&lt;/a&gt;7.8 重载函数&lt;/h2&gt;&lt;p&gt;出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为&lt;strong&gt;重载函数&lt;/strong&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空之境界</title>
  
  <subtitle>ZYP&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zypsola.com/"/>
  <updated>2019-03-23T08:11:04.718Z</updated>
  <id>https://zypsola.com/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络 Chapter3</title>
    <link href="https://zypsola.com/2019/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C3/"/>
    <id>https://zypsola.com/2019/03/18/计算机网络3/</id>
    <published>2019-03-18T15:06:12.000Z</published>
    <updated>2019-03-23T08:11:04.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-传输层"><a href="#第三章-传输层" class="headerlink" title="第三章 传输层"></a>第三章 传输层</h1><a id="more"></a><h2 id="3-1-传输层提供的服务"><a href="#3-1-传输层提供的服务" class="headerlink" title="3.1 传输层提供的服务"></a>3.1 传输层提供的服务</h2><p>为运行在不同主机上的应用进程之间提供逻辑通信。</p><p>无连接服务：在发送方和接收方之间无握手；<br>面向连接服务：在进行数据交换前，通过握手(交换控制报文)来初始化发送方与接收方的状态；</p><h2 id="3-2-UDP用户数据报协议"><a href="#3-2-UDP用户数据报协议" class="headerlink" title="3.2 UDP用户数据报协议"></a>3.2 UDP用户数据报协议</h2><p>可能丢失失序；无连接(每个UDP报文的处理独立于其他的UDP报文)</p><h2 id="3-3-可靠数据传输的原理"><a href="#3-3-可靠数据传输的原理" class="headerlink" title="3.3 可靠数据传输的原理"></a>3.3 可靠数据传输的原理</h2><p>可靠数据传输协议要在非可靠信道上提供可靠的数据通信。</p><ol><li><p>接收方检测到错误分组后，要求发送方重传该分组；接收方检测到丢失分组后，要求发送方重传该分组；Automatic Repeat reQuest(ARQ自动重传请求) Protocol</p></li><li><p>Checksum 校验和</p></li><li><p>Acknowledgement (ACK) 确认；Timeout 超时</p></li><li><p>Retransmit 重传</p></li></ol><h3 id="3-3-1-停止-等待协议"><a href="#3-3-1-停止-等待协议" class="headerlink" title="3.3.1 停止-等待协议"></a>3.3.1 停止-等待协议</h3><p>发送方发送一个分组后，必须停下来等待接收方的确认后才可以发送下一个分组；</p><p>处理错误分组：在接收方接收到错误分组时，接收方发送一个否定的确认NAK (Negative AcKnowlegement) ，要求发送方重发该分组；</p><p>处理分组丢失：为了防止发送的数据丢失，发送方内部设置一个定时器，当超过定时时间，而发送方仍未收到确认ACK时，发送方重发该分组；</p><p>Handling duplicates处理重复分组: 为防止确认(ACK/NAK)丢失而造成发送方重发同一分组，发送方给每一个分组带上一个序列号。</p><h3 id="3-3-2-流水线协议-连续ARQ协议"><a href="#3-3-2-流水线协议-连续ARQ协议" class="headerlink" title="3.3.2 流水线协议/连续ARQ协议"></a>3.3.2 流水线协议/连续ARQ协议</h3><p>允许发送方发送多个“传输中的”还没有被确认的分组。</p><p><strong>Go-Back-N 回退N</strong>：</p><p>发送方连续发送多个分组，如果发送方接收到接收方发回的确认，则继续发送分组；<br>发送方在每发完一个分组后，就启动内部计时器，在设置的超时时间内未收到该分组的确认ACK(或在超时前收到否定确认NAK)，则重发该分组及其后已发送的N个分组；<br>累积确认：接收方只对按序到达的最后一个分组发送确认，如果分组前有间隔，则不确认该分组。<br>缺点：在重传时必须把原来已正确传送过的数据分组进行重传，使传输速率降低。</p><p><strong>选择重传</strong></p><p>当接收方发现某个分组出错（丢失或受损）后，其后继续送来的正确分组收下来，存放在一个缓冲区中，同时要求发送方重新传送出错的那一个分组。一旦收到重新传来的分组后，就可以与原来已存于缓冲区中的其余分组一并按正确的顺序递交给高层。<br>选择重传协议避免不必要的重传。</p><h2 id="3-4-TCP"><a href="#3-4-TCP" class="headerlink" title="3.4 TCP"></a>3.4 TCP</h2><p>点到点；可靠有序；全双工；面向连接；流量控制；拥塞控制；</p><p><strong>TCP可靠传输的具体体现</strong></p><p>TCP连接的每一端都必须设有两个窗口：一个发送窗口一个接收窗口；<br>TCP的可靠传输机制用字节的序号进行控制；<br>TCP两端的四个窗口处于动态变化之中：TCP是全双工协议，双方可以同时发送和接收；</p><p><strong>TCP的连接建立</strong>：三次握手<br><strong>TCP连接释放</strong>：四次挥手</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-传输层&quot;&gt;&lt;a href=&quot;#第三章-传输层&quot; class=&quot;headerlink&quot; title=&quot;第三章 传输层&quot;&gt;&lt;/a&gt;第三章 传输层&lt;/h1&gt;
    
    </summary>
    
    
      <category term="计网" scheme="https://zypsola.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 Chapter2</title>
    <link href="https://zypsola.com/2019/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/"/>
    <id>https://zypsola.com/2019/03/18/计算机网络2/</id>
    <published>2019-03-18T08:07:11.000Z</published>
    <updated>2019-03-18T15:06:08.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><a id="more"></a><h2 id="2-1-应用程序的体系结构"><a href="#2-1-应用程序的体系结构" class="headerlink" title="2.1 应用程序的体系结构"></a>2.1 应用程序的体系结构</h2><h3 id="Client-Server-architecture"><a href="#Client-Server-architecture" class="headerlink" title="Client-Server architecture"></a><strong>Client-Server architecture</strong></h3><p>server:总是在线；永久IP address；用服务器集群增强可扩展性<br>clients:动态IP地址；客户机之间不直接通信</p><h3 id="P2P-architecture"><a href="#P2P-architecture" class="headerlink" title="P2P architecture"></a><strong>P2P architecture</strong></h3><p>任意端系统之间直接通信；对等方间歇性连接，可以改变IP地址</p><h2 id="2-2-应用层协议"><a href="#2-2-应用层协议" class="headerlink" title="2.2 应用层协议"></a>2.2 应用层协议</h2><p>应用层协议是网络应用的主要组成部分，规定了应用程序进程之间通信所遵循的通信规则。</p><p>HTTP: hypertext transfer protocol超文本传输协议<br>FTP: File Transfer Protocol文件传输协议<br>SMTP: Simple Mail Transfer Protocol简单邮件传输协议<br>POP: Post Office Protocol邮局协议<br>IMAP: Internet Message Access Protocol因特网报文读取协议<br>DNS: Domain Name System域名系统</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-应用层&quot;&gt;&lt;a href=&quot;#第二章-应用层&quot; class=&quot;headerlink&quot; title=&quot;第二章 应用层&quot;&gt;&lt;/a&gt;第二章 应用层&lt;/h1&gt;
    
    </summary>
    
    
      <category term="计网" scheme="https://zypsola.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 Chapter1</title>
    <link href="https://zypsola.com/2019/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
    <id>https://zypsola.com/2019/03/18/计算机网络1/</id>
    <published>2019-03-18T07:11:32.000Z</published>
    <updated>2019-03-18T15:10:40.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h1><a id="more"></a><h2 id="1-1-计算机网络的定义"><a href="#1-1-计算机网络的定义" class="headerlink" title="1.1 计算机网络的定义"></a>1.1 计算机网络的定义</h2><ol><li><p>定义1:计算机网络就是通过交换机、路由器等网络设备和通信线路将分散在不同地理位置的多个计算机系统（服务器或工作站）连接起来，在网络协议和应用软件的控制下实现各种网络服务的系统。</p></li><li><p>计算机网络常常简称网络。</p></li><li><p>计算机网络最基本的功能是数据通信。资源共享是构建网络的最终目的，数据通信是实现资源共享的前提。</p></li><li><p>定义2:以能够相互共享资源的方式互联起来的自治计算机系统的集合。</p></li></ol><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议?"></a>什么是协议?</h3><p>协议定义了通信实体之间交换的报文格式(语法)和次序(时序)，以及在传输和接收报文时所采取的动作(语义)。</p><h2 id="1-2-网络的结构"><a href="#1-2-网络的结构" class="headerlink" title="1.2 网络的结构"></a>1.2 网络的结构</h2><h3 id="早期计算机网络的结构"><a href="#早期计算机网络的结构" class="headerlink" title="早期计算机网络的结构"></a>早期计算机网络的结构</h3><p>资源子网：直接面向用户；由主机系统、终端、各种网络软件与数据资源组成。</p><p>通信子网：负责通信；由路由器、通信线路组成。</p><h3 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h3><p>网络边缘：end systems, access networks, links；</p><p>网络核心：因特网的核心由ISP(Internet Service Providers因特网服务提供商)相互连接而成。</p><h2 id="1-3-网络分类"><a href="#1-3-网络分类" class="headerlink" title="1.3 网络分类"></a>1.3 网络分类</h2><h3 id="传输技术"><a href="#传输技术" class="headerlink" title="传输技术"></a>传输技术</h3><p>广播链路；点到点链路</p><h3 id="距离尺度"><a href="#距离尺度" class="headerlink" title="距离尺度"></a>距离尺度</h3><p>局域网；城域网；广域网</p><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>星形；环形；总线形；树形；网状形</p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><h2 id="1-4-网络协议分层"><a href="#1-4-网络协议分层" class="headerlink" title="1.4 网络协议分层"></a>1.4 网络协议分层</h2><h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><p>ISO/OSI；TCP/IP</p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>Application应用层：支持网络应用<br>Presentation表示层：允许应用程序解释数据的意义，如：加密、压缩<br>Session会话层：数据交换的同步，检查和恢复<br>Transport传输层：进程到进程的数据传输<br>Network网络层：为数据报选择从源主机到目的主机的路径<br>DataLink数据链路层：在邻近网元之间传输数据<br>Physical物理层：在介质上传输原始比特</p><h3 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h3><p>应用层：FTP；HTTP；SMTP；DNS；…<br>传输层：TCP；UDP<br>网际层：IP；ICMP；ARP；…<br>网络接口层：Internet；LANs</p><h3 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h3><p>应用层；传输层；网络层；数据链路层；物理层</p><h2 id="1-5-性能"><a href="#1-5-性能" class="headerlink" title="1.5 性能"></a>1.5 性能</h2><p>带宽：在单位时间内从网络中的某一点到另一点所能通过的位数。<br>1Kbps = 1000 bps (bits per second)</p><p>时延/延迟: 一个数据块（帧、分组、报文段）从网络的一端传送到另一端所需要的时间。</p><p>时延=处理时延+排队时延+传输时延+传播时延</p><p>传播时延=传输距离/光速</p><p>传输时延=数据量/带宽</p><p><strong>时延带宽积</strong></p><p>时延带宽积＝传播时延×带宽</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章-计算机网络体系结构&quot;&gt;&lt;a href=&quot;#第一章-计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;第一章 计算机网络体系结构&quot;&gt;&lt;/a&gt;第一章 计算机网络体系结构&lt;/h1&gt;
    
    </summary>
    
    
      <category term="计网" scheme="https://zypsola.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson10</title>
    <link href="https://zypsola.com/2019/03/11/%E7%AE%97%E6%B3%95Lesson10/"/>
    <id>https://zypsola.com/2019/03/11/算法Lesson10/</id>
    <published>2019-03-11T12:32:21.000Z</published>
    <updated>2019-03-11T14:21:25.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十八章-B树"><a href="#第十八章-B树" class="headerlink" title="第十八章 B树"></a>第十八章 B树</h1><p>B树是为磁盘或其他直接存取的辅助储存设备而设计的一种平衡搜索树。</p><a id="more"></a><h2 id="18-1-B树的定义"><a href="#18-1-B树的定义" class="headerlink" title="18.1 B树的定义"></a>18.1 B树的定义</h2><p>一棵m阶的B树，或为空，或为满足下列特征的m叉树：</p><ol><li>树中每个结点至多有m棵子树</li><li>若根结点不是叶结点，则至少有两棵子树</li><li>除根结点以外的所有非叶结点至少有⌈m/2⌉棵子树</li><li>非叶根结点有n(n &lt; m)个关键字k，k<sub>i</sub> &lt; k<sub>i+1</sub></li><li>所有叶子结点在同一层且不带信息</li></ol><h2 id="18-2-插入关键字"><a href="#18-2-插入关键字" class="headerlink" title="18.2 插入关键字"></a>18.2 插入关键字</h2><ol><li>插入后，该结点关键字个数n &lt; m，直接插入；</li><li>插入后，该结点关键字个数n = m，须结点分裂：令⌈m/2⌉插入父节点，右部分生成新结点，若父结点插入后也满，则继续结点分裂，若无父结点，则建立新的根结点；</li></ol><h2 id="18-3-删除关键字"><a href="#18-3-删除关键字" class="headerlink" title="18.3 删除关键字"></a>18.3 删除关键字</h2><ol><li>被删除关键字所在结点，关键字个数n&gt;=⌈m/2⌉，直接删去；</li><li>被删除关键字所在结点，关键字个数n=⌈m/2⌉-1，若相邻的左兄弟(右兄弟)的关键字个数n&gt;=⌈m/2⌉，将父结点中刚小于(大于)删除关键字的关键字下移到被删除关键字所在结点，将左兄弟(右兄弟)最大(最小)关键字上移到父结点；</li><li>被删除关键字所在结点和相邻的兄弟结点中的关键字个数均为n=⌈m/2⌉-1，删除后与兄弟结点合并；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十八章-B树&quot;&gt;&lt;a href=&quot;#第十八章-B树&quot; class=&quot;headerlink&quot; title=&quot;第十八章 B树&quot;&gt;&lt;/a&gt;第十八章 B树&lt;/h1&gt;&lt;p&gt;B树是为磁盘或其他直接存取的辅助储存设备而设计的一种平衡搜索树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson9</title>
    <link href="https://zypsola.com/2019/03/11/%E7%AE%97%E6%B3%95Lesson9/"/>
    <id>https://zypsola.com/2019/03/11/算法Lesson9/</id>
    <published>2019-03-11T08:33:46.000Z</published>
    <updated>2019-03-11T12:29:49.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-贪心算法"><a href="#第十六章-贪心算法" class="headerlink" title="第十六章 贪心算法"></a>第十六章 贪心算法</h1><p>贪心算法总是做出局部最优的选择。</p><a id="more"></a><h2 id="16-1-活动选择问题"><a href="#16-1-活动选择问题" class="headerlink" title="16.1 活动选择问题"></a>16.1 活动选择问题</h2><p>假设有一个活动的集合S={a<sub>1</sub>,…,a<sub>n</sub>}，这些活动使用同一个资源，而这个资源某个时空只能供一个活动使用，每个活动都有一个开始时间和结束时间。在活动选择问题中，我们希望选出一个最大兼容活动集。</p><p>反复选择最早结束的活动，保留兼容的活动。</p><h2 id="16-3-赫夫曼编码"><a href="#16-3-赫夫曼编码" class="headerlink" title="16.3 赫夫曼编码"></a>16.3 赫夫曼编码</h2><p>构造Huffman树</p><ol><li>根据给定的n个权值，构造n棵只有根结点的二叉树</li><li>在森林中取两棵根结点权值最小的树作左右子树，构造一棵二叉树，置根结点权值为左右子树根节点权值之和</li><li>重复上步直到只含一棵树，即哈夫曼树</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十六章-贪心算法&quot;&gt;&lt;a href=&quot;#第十六章-贪心算法&quot; class=&quot;headerlink&quot; title=&quot;第十六章 贪心算法&quot;&gt;&lt;/a&gt;第十六章 贪心算法&lt;/h1&gt;&lt;p&gt;贪心算法总是做出局部最优的选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson8</title>
    <link href="https://zypsola.com/2019/03/09/%E7%AE%97%E6%B3%95Lesson8/"/>
    <id>https://zypsola.com/2019/03/09/算法Lesson8/</id>
    <published>2019-03-09T15:06:37.000Z</published>
    <updated>2019-03-10T13:33:35.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五章-动态规划"><a href="#第十五章-动态规划" class="headerlink" title="第十五章 动态规划"></a>第十五章 动态规划</h1><p>分治法将问题划分为互不相交的子问题，动态规划应用于子问题重叠的情况。</p><a id="more"></a><p>我们通常按以下4个步骤来设计一个动态规划算法：</p><ol><li>刻画一个最优解的结构特征</li><li>递归地定义最优解的值</li><li>计算最优解的值，通常采用自底向上的方法</li><li>利用计算出的信息构造一个最优解。</li></ol><h2 id="15-1-钢条切割"><a href="#15-1-钢条切割" class="headerlink" title="15.1 钢条切割"></a>15.1 钢条切割</h2><p><strong>钢条切割问题</strong>:给定一段长度为n英寸的钢条和一个价格表<strong>p<sub>i</sub>(i=1,2,…,n)</strong>,求切割方案使收益<strong>r<sub>n</sub></strong>最大。</p><p><strong>r<sub>n</sub> = max(p<sub>n</sub>, r<sub>1</sub>+r<sub>n-1</sub>,…,r<sub>n-1</sub>+r<sub>1</sub>)</strong></p><p>我们称钢条切割问题满足<strong>最优子结构</strong>性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p><p>钢条切割问题还存在另一种方法：</p><p><strong>r<sub>n</sub> = max(p<sub>1</sub>+r<sub>n-1</sub>,…,p<sub>n-1</sub>+r<sub>1, p<sub>n</sub>)</sub></strong></p><h2 id="15-2-矩阵链乘法"><a href="#15-2-矩阵链乘法" class="headerlink" title="15.2 矩阵链乘法"></a>15.2 矩阵链乘法</h2><p>我们称有如下性质的矩阵乘积链为<strong>完全括号化的</strong>：它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。</p><h2 id="15-4-最长公共子序列"><a href="#15-4-最长公共子序列" class="headerlink" title="15.4 最长公共子序列"></a>15.4 最长公共子序列</h2><p><strong>最长公共子序列问题</strong>：给定两个序列X={x1,x2,…,x<sub>m</sub>}h和Y={y1,y2,…,y<sub>n</sub>},求X和Y的最长公共子序列LCS。</p><p>我们定义c[i,j]表示X<sub>i</sub>和Y<sub>j</sub>的LCS长度。</p><ol><li>若i=0 或 j=0, c[i,j]=0;</li><li>若i,j&gt;0 且 x<sub>i</sub> = y<sub>j</sub>, c[i,j]=c[i-1,j-1]+1;</li><li>若i,j&gt;0 且 x<sub>i</sub> ！= y<sub>j</sub>, max(c[i,j-1],c[i-1,j]);</li></ol><h2 id="15-5-最优二叉搜索树"><a href="#15-5-最优二叉搜索树" class="headerlink" title="15.5 最优二叉搜索树"></a>15.5 最优二叉搜索树</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十五章-动态规划&quot;&gt;&lt;a href=&quot;#第十五章-动态规划&quot; class=&quot;headerlink&quot; title=&quot;第十五章 动态规划&quot;&gt;&lt;/a&gt;第十五章 动态规划&lt;/h1&gt;&lt;p&gt;分治法将问题划分为互不相交的子问题，动态规划应用于子问题重叠的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson7</title>
    <link href="https://zypsola.com/2019/03/05/%E7%AE%97%E6%B3%95Lesson7/"/>
    <id>https://zypsola.com/2019/03/05/算法Lesson7/</id>
    <published>2019-03-05T05:47:12.000Z</published>
    <updated>2019-03-10T08:25:26.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-二叉搜索树"><a href="#第十二章-二叉搜索树" class="headerlink" title="第十二章 二叉搜索树"></a>第十二章 二叉搜索树</h1><a id="more"></a><h2 id="12-1-二叉树搜索树"><a href="#12-1-二叉树搜索树" class="headerlink" title="12.1 二叉树搜索树"></a>12.1 二叉树搜索树</h2><p>对任何结点x，其左子树中的key值最大不超过x.key，右子树中的key值最小不低于x.key。</p><p><strong>先序遍历</strong>：(1)访问根结点(2)先序遍历左子树(3)先序遍历右子树<br><strong>中序遍历</strong>：(1)中序遍历左子树(2)访问根结点(3)中序遍历右子树<br><strong>后序遍历</strong>：(1)后序遍历左子树(2)后序遍历右子树(3)访问根结点</p><p>后继结点：一个结点在中序遍历序列中的后一个结点<br>前驱结点：一个结点在中序遍历序列中的前一个结点</p><h2 id="12-3-插入和删除"><a href="#12-3-插入和删除" class="headerlink" title="12.3 插入和删除"></a>12.3 插入和删除</h2><h1 id="十三章-红黑树"><a href="#十三章-红黑树" class="headerlink" title="十三章 红黑树"></a>十三章 红黑树</h1><h2 id="13-1-红黑树的性质"><a href="#13-1-红黑树的性质" class="headerlink" title="13.1 红黑树的性质"></a>13.1 红黑树的性质</h2><p>红黑树是一棵二叉搜索树，它为每个结点上增加了颜色。通过对任意一条从根结点到叶子结点的路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长出2倍。</p><ol><li>每个结点是红色的或黑色的</li><li>根结点是黑色的</li><li>叶结点(空结点)是黑色的</li><li>红色结点的子结点是黑色的</li><li>对每个结点，从该结点到所有叶子结点的路径上，黑色结点的数目相同。</li></ol><p>从某个结点(不包括本身)到其叶子结点路径上黑色结点的数量为该结点的<strong>黑高</strong>。</p><h2 id="13-3-插入"><a href="#13-3-插入" class="headerlink" title="13.3 插入"></a>13.3 插入</h2><p>将插入节点设为红色。先正常插入。</p><ol><li>插入位置是根结点：直接涂为黑色。</li><li>插入位置的父结点为黑色：不需要操作。</li><li>插入位置的父结点为红色：</li></ol><p>case1:叔叔结点为红色:1.将父结点设为黑色；2.祖父结点设为红色；3.叔叔结点设为黑色；4.以祖父结点为当前结点递归分析；<br>case2:叔叔结点为黑色且当前结点为右孩子:1.以父结点为当前结点；2.以当前结点为支点左旋；<br>case3:叔叔结点为黑色且当前结点为左孩子:1.父结点设为黑色；2.祖父结点设为红色；3.以祖父结点为支点右旋；</p><h2 id="13-4-删除"><a href="#13-4-删除" class="headerlink" title="13.4 删除"></a>13.4 删除</h2><ol><li>删除结点z没有孩子结点:直接删除。</li><li>删除结点z只有一个孩子:删除z将孩子提升至z的位置。</li><li>删除结点z有2给孩子:找到其后继结点替换。</li></ol><p>设当前位置的结点有一个额外黑色。</p><ol><li>红+黑：直接设为黑。</li><li>黑+黑，且为根结点：直接设为黑。</li><li>黑+黑，不为根结点：</li></ol><p>case1:兄弟结点为红色:1.父结点设为红色；2.兄弟结点设为黑；3.以父结点旋转；<br>case2:兄弟结点为黑色,兄弟结点的2个子结点为黑:1.兄弟结点设为红；2.设父结点为当前结点；<br>case3:兄弟结点为黑色,兄弟结点的2个子结点为右黑左红:1.兄弟结点设为红色；2.红色子结点设为黑；以兄弟结点右旋；<br>case4:兄弟结点为黑色,兄弟结点的2个子结点为右红左任意：1.将父结点颜色赋予兄弟结点；2.将父结点设为黑；3.将兄弟结点是右子结点设为黑；4.以父结点左旋；5.修正结束；</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十二章-二叉搜索树&quot;&gt;&lt;a href=&quot;#第十二章-二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;第十二章 二叉搜索树&quot;&gt;&lt;/a&gt;第十二章 二叉搜索树&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson6</title>
    <link href="https://zypsola.com/2019/03/04/%E7%AE%97%E6%B3%95Lesson6/"/>
    <id>https://zypsola.com/2019/03/04/算法Lesson6/</id>
    <published>2019-03-04T09:03:53.000Z</published>
    <updated>2019-03-05T05:45:47.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-基本数据结构"><a href="#第十章-基本数据结构" class="headerlink" title="第十章 基本数据结构"></a>第十章 基本数据结构</h1><a id="more"></a><h2 id="10-1-栈和队列"><a href="#10-1-栈和队列" class="headerlink" title="10.1 栈和队列"></a>10.1 栈和队列</h2><p>栈：后进先出<br>队列：先进先出</p><h2 id="10-2-链表"><a href="#10-2-链表" class="headerlink" title="10.2 链表"></a>10.2 链表</h2><h2 id="10-4-有根树"><a href="#10-4-有根树" class="headerlink" title="10.4 有根树"></a>10.4 有根树</h2><p><strong>分支无限制的有根树</strong>：左孩子右兄弟</p><h1 id="第十一章-散列表"><a href="#第十一章-散列表" class="headerlink" title="第十一章 散列表"></a>第十一章 散列表</h1><p>在散列表中，不是直接把关键字作为数组下标，而是根据关键字计算出相应的下标。</p><h2 id="11-1-直接寻址法"><a href="#11-1-直接寻址法" class="headerlink" title="11.1 直接寻址法"></a>11.1 直接寻址法</h2><p>当关键字的全域比较小时，直接寻址简单而有效。</p><h2 id="11-2-散列表"><a href="#11-2-散列表" class="headerlink" title="11.2 散列表"></a>11.2 散列表</h2><p>在直接寻址方式下，关键字为k的元素放在槽k中。在散列方式下，该元素存放在槽h(k)中，即利用<strong>散列函数</strong>h，由关键字k计算出槽的位置。</p><p>两个关键字可能映射到同一个槽中。我们称之为冲突。</p><p><strong>链接法</strong>：把散列到同一槽中的元素都放在一个链表中。</p><h2 id="11-3-散列函数"><a href="#11-3-散列函数" class="headerlink" title="11.3 散列函数"></a>11.3 散列函数</h2><p><strong>将关键字转换为自然数</strong></p><h3 id="11-3-1-除法散列法"><a href="#11-3-1-除法散列法" class="headerlink" title="11.3.1 除法散列法"></a>11.3.1 除法散列法</h3><p>h(k) = k mod m</p><p>我们要避免选择m的某些值，例如2的幂。</p><h3 id="11-3-2-乘法散列表"><a href="#11-3-2-乘法散列表" class="headerlink" title="11.3.2 乘法散列表"></a>11.3.2 乘法散列表</h3><p>用关键字k乘常数A(0&lt;A&lt;1),并提取kA的小数部分，用m乘以这个这个值再向下取整。</p><p>h(k) = ⌊m(kA mod 1)⌋</p><h3 id="11-3-3-全域散列法"><a href="#11-3-3-全域散列法" class="headerlink" title="11.3.3 全域散列法"></a>11.3.3 全域散列法</h3><p>随机地选择散列函数，使之独立于关键字。</p><h2 id="11-4-开放寻址法"><a href="#11-4-开放寻址法" class="headerlink" title="11.4 开放寻址法"></a>11.4 开放寻址法</h2><p>为使开放寻址法插入一个元素，需要连续地检查散列表，或称为<strong>探查</strong>(probe)，直到找到一个空槽来放置。</p><p><strong>线性探查</strong></p><p>h(k,i) = (h’(k) + i) mod m, i=0,1,…,m-1</p><p><strong>二次探查</strong></p><p>h(k,i) = (h’(k) + c1i + c2i²) mod m, i=0,1,…,m-1</p><p><strong>双重散列</strong></p><p>h(k,i) = (h1(k) + ih2(k)) mod m, i=0,1,…,m-1</p><h2 id="11-5-完全散列"><a href="#11-5-完全散列" class="headerlink" title="11.5 完全散列"></a>11.5 完全散列</h2><p>采用两级散列方法设计完全散列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十章-基本数据结构&quot;&gt;&lt;a href=&quot;#第十章-基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;第十章 基本数据结构&quot;&gt;&lt;/a&gt;第十章 基本数据结构&lt;/h1&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson5</title>
    <link href="https://zypsola.com/2019/03/03/%E7%AE%97%E6%B3%95Lesson5/"/>
    <id>https://zypsola.com/2019/03/03/算法Lesson5/</id>
    <published>2019-03-03T09:17:45.000Z</published>
    <updated>2019-03-04T09:02:22.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-线性时间排序"><a href="#第八章-线性时间排序" class="headerlink" title="第八章 线性时间排序"></a>第八章 线性时间排序</h1><p>在排序的最终结果中，各元素的次序依赖于它们之间的比较的排序算法，我们称之为<strong>比较排序</strong>。</p><a id="more"></a><h2 id="8-2-计数排序"><a href="#8-2-计数排序" class="headerlink" title="8.2 计数排序"></a>8.2 计数排序</h2><p>计数排序假定输入数据都属于一个小区间内的整数。计数排序是<strong>稳定的</strong>:具有相同值的元素在输出数组中的相对次序于它们在输入数组中的相对次序相同。计数排序经常会被用作基数排序算法的一个子过程，为了使基数排序正常运行，计数排序必须是稳定的。</p><h2 id="8-3-基数排序"><a href="#8-3-基数排序" class="headerlink" title="8.3 基数排序"></a>8.3 基数排序</h2><p>基数排序是按最低有效位进行排序的。</p><h2 id="8-4-桶排序"><a href="#8-4-桶排序" class="headerlink" title="8.4 桶排序"></a>8.4 桶排序</h2><p>桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上，桶排序将[0,1)区间划分为n个相同大小的子区间，或称为<strong>桶</strong>。我们先对每个桶中的数据进行排序，然后遍历每个桶，依次输出各个桶中的元素即可。</p><h1 id="第九章-中位数和顺序统计量"><a href="#第九章-中位数和顺序统计量" class="headerlink" title="第九章 中位数和顺序统计量"></a>第九章 中位数和顺序统计量</h1><p>在一个由n个元素组成的集合中，第i个<strong>顺序统计量</strong>是该集合中第i小的元素。</p><p>如果不考虑n的奇偶性，中位数总是出现在i=⌊(n+1)/2⌋处(下中位数)和i=⌈(n+2)/2⌉处(上中位数)。</p><h2 id="9-1-最大值和最小值"><a href="#9-1-最大值和最小值" class="headerlink" title="9.1 最大值和最小值"></a>9.1 最大值和最小值</h2><p><strong>同时找到最小值和最大值</strong></p><p>分别独立地找出最大值和最小值需要2n-2次比较。事实上，最多只需要3⌊n/2⌋次比较。具体方法是:记录已知的最大值最小值，取一对元素互相比较，较小的与最小值比较，较大的与最大值比较。</p><h2 id="9-2-期望为线性时间的选择算法"><a href="#9-2-期望为线性时间的选择算法" class="headerlink" title="9.2 期望为线性时间的选择算法"></a>9.2 期望为线性时间的选择算法</h2><p>选择问题：在A[p..r]中找到第i小的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RANDOM-SELECT(A,p,r,i)</span><br><span class="line">if p==r</span><br><span class="line">return A[p]</span><br><span class="line">q = RANDOM-PARTITION(A,p,r)</span><br><span class="line">k = q - p + 1</span><br><span class="line">if i==k</span><br><span class="line">return A[q]</span><br><span class="line">else if i&lt;k</span><br><span class="line">return RANDOM-SELECT(A,p,q-1,i)</span><br><span class="line">else</span><br><span class="line">return RANDOM-SELECT(A,q+1,r,i-k)</span><br></pre></td></tr></table></figure><h2 id="9-3-最坏情况为线性时间的选择算法"><a href="#9-3-最坏情况为线性时间的选择算法" class="headerlink" title="9.3 最坏情况为线性时间的选择算法"></a>9.3 最坏情况为线性时间的选择算法</h2><ol><li><p>将数组划分为n/5组</p></li><li><p>对每组排序并找出中位数</p></li><li><p>递归调用找出中位数的中位数</p></li><li><p>使用中位数的中位数为主元调用PRATITION划分</p></li><li><p>递归调用</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第八章-线性时间排序&quot;&gt;&lt;a href=&quot;#第八章-线性时间排序&quot; class=&quot;headerlink&quot; title=&quot;第八章 线性时间排序&quot;&gt;&lt;/a&gt;第八章 线性时间排序&lt;/h1&gt;&lt;p&gt;在排序的最终结果中，各元素的次序依赖于它们之间的比较的排序算法，我们称之为&lt;strong&gt;比较排序&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson4</title>
    <link href="https://zypsola.com/2019/03/03/%E7%AE%97%E6%B3%95Lesson4/"/>
    <id>https://zypsola.com/2019/03/03/算法Lesson4/</id>
    <published>2019-03-03T08:24:31.000Z</published>
    <updated>2019-03-03T09:12:37.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-快速排序"><a href="#第七章-快速排序" class="headerlink" title="第七章 快速排序"></a>第七章 快速排序</h1><p>快速排序是一种最坏情况时间复杂度为Θ(n²)，期望时间复杂度为Θ(nlogn)的排序算法。</p><a id="more"></a><h2 id="7-1-快速排序的描述"><a href="#7-1-快速排序的描述" class="headerlink" title="7.1 快速排序的描述"></a>7.1 快速排序的描述</h2><p><strong>分解：</strong>将A[p..r]划分为A[p..q-1]和A[q+1..r],使得A[p..q-1]中的每个元素都小于等于A[q],A[q]小于等于A[q+1..r]中的每个元素。<br><strong>解决：</strong>递归调用，对A[p..q-1]和A[q+1..r]进行排序。<br><strong>合并：</strong>因为子数组都是原址排序，所以A[p..r]已经有序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSORT(A,p,r)</span><br><span class="line">q = PARTITION(A,p,r)</span><br><span class="line">QSORT(A,p,q-1)</span><br><span class="line">QSORT(A,p+1,r)</span><br></pre></td></tr></table></figure><p><strong>数组的划分</strong></p><p>算法的关键部分是<strong>PARTITION</strong>过程:PARTITION总是选择x=A[r]作为<strong>主元</strong>，并围绕它来划分子数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PARTITION(A,p,r)</span><br><span class="line">x = A[r]</span><br><span class="line">i = p -1</span><br><span class="line">for j = p to r-1</span><br><span class="line">if A[j]&lt;=x</span><br><span class="line">i++</span><br><span class="line">exchange A[i] with A[j]</span><br><span class="line">exchange A[i+1] with A[r]</span><br><span class="line">return i+1</span><br></pre></td></tr></table></figure><h2 id="7-2-快速排序的性能"><a href="#7-2-快速排序的性能" class="headerlink" title="7.2 快速排序的性能"></a>7.2 快速排序的性能</h2><p>快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素。如果划分是平衡的，那么快速排序的性能与归并排序一样，如果不平衡，则性能接近于插入排序。</p><h2 id="7-3-快速排序的随机化版本"><a href="#7-3-快速排序的随机化版本" class="headerlink" title="7.3 快速排序的随机化版本"></a>7.3 快速排序的随机化版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RANDOM-PARTITION(A,p,r)</span><br><span class="line">i = RANDOM(p,r)</span><br><span class="line">exchange A[r] with A[i]</span><br><span class="line">return PARTITION(A,p,r)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第七章-快速排序&quot;&gt;&lt;a href=&quot;#第七章-快速排序&quot; class=&quot;headerlink&quot; title=&quot;第七章 快速排序&quot;&gt;&lt;/a&gt;第七章 快速排序&lt;/h1&gt;&lt;p&gt;快速排序是一种最坏情况时间复杂度为Θ(n²)，期望时间复杂度为Θ(nlogn)的排序算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson3</title>
    <link href="https://zypsola.com/2019/03/02/%E7%AE%97%E6%B3%95Lesson3/"/>
    <id>https://zypsola.com/2019/03/02/算法Lesson3/</id>
    <published>2019-03-02T06:34:42.000Z</published>
    <updated>2019-03-03T08:23:15.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-堆排序"><a href="#第六章-堆排序" class="headerlink" title="第六章 堆排序"></a>第六章 堆排序</h1><p>堆排序的时间复杂度O(nlgn)。而与插入排序相同，但不同于归并排序的是，堆排序具有空间原址性：任何时候都只需要常数个额外的元素空间储存临时数据。</p><a id="more"></a><h2 id="6-1-堆"><a href="#6-1-堆" class="headerlink" title="6.1 堆"></a>6.1 堆</h2><p><strong>堆</strong>是一个数组，可以被看成一个完全二叉树。树的根节点是A[1]，对给定的一个结点下标i，可以计算出它的父结点、左孩子和右孩子的下标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PARENT(i)</span><br><span class="line">    return ⌊i/2⌋</span><br><span class="line">LEFT(i)</span><br><span class="line">return 2i</span><br><span class="line">RIGHT(i)</span><br><span class="line">return 2i+1</span><br></pre></td></tr></table></figure><p>二叉堆可以分为最大堆和最小堆。</p><p><strong>最大堆</strong>：A[PARENT(i)]&gt;=A[i],即某个结点的值至多与其父结点一样大。</p><p><strong>最小堆</strong>：A[PARENT(i)]&lt;=A[i]。</p><h2 id="6-2-维护堆的性质"><a href="#6-2-维护堆的性质" class="headerlink" title="6.2 维护堆的性质"></a>6.2 维护堆的性质</h2><p>MAX-HEAPIFY用于维护最大堆性质，输入为数组A与下标i，在调用时假定以LEFT(i)与RIGHT(i)的二叉树都是最大堆，但A[i]可能小于孩子，通过让A[i]在最大堆中逐级下降来维护。需要递归调用MAX-HEAPIFY。</p><p>O(lgn)</p><h2 id="6-3-建堆"><a href="#6-3-建堆" class="headerlink" title="6.3 建堆"></a>6.3 建堆</h2><p>我们可以用自底向上的方法利用MAX-HEAPIFY把一个数组A[1..n]转换为最大堆。A[⌊n/2⌋+1..n]中的元素都是树的叶结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i = ⌊n/2⌋ to 1</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br></pre></td></tr></table></figure><p>O(n)</p><h2 id="6-4-堆排序"><a href="#6-4-堆排序" class="headerlink" title="6.4 堆排序"></a>6.4 堆排序</h2><p>初始先建立最大堆，因为数组最大元素始终在A[1],将A[1]与A[heapsize]互换，heapsize-1，再调用MAX-HEAPIFY(A,1),不断重复。</p><p>O(nlgn)</p><h2 id="6-5-优先队列"><a href="#6-5-优先队列" class="headerlink" title="6.5 优先队列"></a>6.5 优先队列</h2><p><strong>优先队列</strong>是一种用来维护由一组元素构成的集合S的数据结构，其中的每一个元素都有一个关键字key值。一个最大优先队列支持以下操作：</p><ol><li>INSERT(S,x):把元素x插入S中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HEAP-INSERT(A,k)</span><br><span class="line">heapsize++</span><br><span class="line">A[heapsize] = k - 1</span><br><span class="line">HEAP-INCREASE-KEY(A,heapsize,k)</span><br></pre></td></tr></table></figure><ol start="2"><li>MAXIMUM(S):返回最大key值元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEAP-MAXIMUM(A)</span><br><span class="line">return A[1]</span><br></pre></td></tr></table></figure><ol start="3"><li>EXTRACT-MAX(S):返回并去掉最大Key值元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HEAP-EXTRACT-MAX(S)</span><br><span class="line">max = A[1]</span><br><span class="line">A[1] = A[heapsize]</span><br><span class="line">heapsize--</span><br><span class="line">MAX-HEAPIFY(A,1)</span><br><span class="line">return max</span><br></pre></td></tr></table></figure><ol start="4"><li>INCREASE-KEY(S,x,k):将元素x的key值增加到k,k大于原值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HEAP-INCREASE-KEY(A,i,k)</span><br><span class="line">A[i] = k</span><br><span class="line">while i&gt;1 and A[PARENT(i)] &lt; A[i]</span><br><span class="line">exchange A[i] with A[PARENT[i]]</span><br><span class="line">i = PARENT[i]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六章-堆排序&quot;&gt;&lt;a href=&quot;#第六章-堆排序&quot; class=&quot;headerlink&quot; title=&quot;第六章 堆排序&quot;&gt;&lt;/a&gt;第六章 堆排序&lt;/h1&gt;&lt;p&gt;堆排序的时间复杂度O(nlgn)。而与插入排序相同，但不同于归并排序的是，堆排序具有空间原址性：任何时候都只需要常数个额外的元素空间储存临时数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson2</title>
    <link href="https://zypsola.com/2019/02/28/%E7%AE%97%E6%B3%95Lesson2/"/>
    <id>https://zypsola.com/2019/02/28/算法Lesson2/</id>
    <published>2019-02-28T08:58:22.000Z</published>
    <updated>2019-03-02T06:33:35.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-分治策略"><a href="#第四章-分治策略" class="headerlink" title="第四章 分治策略"></a>第四章 分治策略</h1><p>分解,解决,合并。</p><a id="more"></a><h2 id="4-1-最大子数组问题"><a href="#4-1-最大子数组问题" class="headerlink" title="4.1 最大子数组问题"></a>4.1 最大子数组问题</h2><p>只有当数组中包含负数时，最大子数组问题才有意义。</p><p>暴力求解时间复杂度O(n²)。</p><p><strong>使用分治策略的求解方法</strong></p><p>设数组A[low…mid…high],mid为中间位置。A的任何连续子数组A[i…j]必然是：low&lt;=i&lt;=j&lt;=mid; mid&lt;i&lt;=j&lt;=high; low&lt;=i&lt;=mid&lt;j&lt;=high。</p><p>我们可以在线性时间内求出跨越中点的最大子数组。</p><p>时间复杂度O(nlgn)。</p><p><strong>线性时间求解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int maxArray(vector&lt;int&gt; const &amp;num) &#123;</span><br><span class="line">int len = num.end() - num.begin();</span><br><span class="line">int i = 1, max = num[0], sum = num[0];</span><br><span class="line">while (i &lt; len) &#123;</span><br><span class="line">if (sum &lt; 0) &#123;</span><br><span class="line">sum = 0;</span><br><span class="line">&#125;</span><br><span class="line">sum = sum + num[i];</span><br><span class="line">i++;</span><br><span class="line">if (sum &gt; max) &#123;</span><br><span class="line">max = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-矩阵乘法的Strassen算法"><a href="#4-2-矩阵乘法的Strassen算法" class="headerlink" title="4.2 矩阵乘法的Strassen算法"></a>4.2 矩阵乘法的Strassen算法</h2><p>暴力求解O(n³)</p><p>Strassen算法(分治)O(n^lg7)</p><h1 id="第五章-概率分析和随机算法"><a href="#第五章-概率分析和随机算法" class="headerlink" title="第五章 概率分析和随机算法"></a>第五章 概率分析和随机算法</h1><p>如果一个算法的行为不仅由输入决定，而且也由随机数生成器产生的数值决定，则称这个算法是<strong>随机的</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-分治策略&quot;&gt;&lt;a href=&quot;#第四章-分治策略&quot; class=&quot;headerlink&quot; title=&quot;第四章 分治策略&quot;&gt;&lt;/a&gt;第四章 分治策略&lt;/h1&gt;&lt;p&gt;分解,解决,合并。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法 Lesson1</title>
    <link href="https://zypsola.com/2019/02/27/%E7%AE%97%E6%B3%95Lesson1/"/>
    <id>https://zypsola.com/2019/02/27/算法Lesson1/</id>
    <published>2019-02-27T07:28:42.000Z</published>
    <updated>2019-02-28T08:42:33.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><p>非形式的说，<strong>算法(algorithm)</strong>就是任何良定义的计算过程，该过程取某个值或值的集合作为<strong>输入</strong>并产生某个值或值的集合作为<strong>输出</strong>。这样算法就是把输入转换成输出的计算步骤的一个序列。</p><a id="more"></a><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>Θ(n²)</p><h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>我们往往集中于最坏情况运行时间。</p><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解，然后合并子问题的解来建立原问题的解。</p><p><strong>归并排序</strong>:分解待排序的n个元素的序列成各具n/2个元素的两个子序列;使用归并排序递归地排序两个子序列;合并两个已排序的子序列。</p><p>Θ(nlgn)</p><h1 id="第三章-函数的增长"><a href="#第三章-函数的增长" class="headerlink" title="第三章 函数的增长"></a>第三章 函数的增长</h1><h2 id="3-1-渐进记号"><a href="#3-1-渐进记号" class="headerlink" title="3.1 渐进记号"></a>3.1 渐进记号</h2><p>我们主要使用渐进记号来描述算法的运行时间。然而，渐进记号实际上应用于函数。</p><p><strong>Θ记号</strong></p><p>Θ(g(n))={f(n):存在正常量c1,c2,n0,使得对所有n&gt;=n0,有0&lt;=c1g(n)&lt;=f(n)&lt;=c2g(n)}</p><p><strong>O记号</strong></p><p>Θ记号渐进地给出一个函数的上界和下界。当只有一个渐进上界时，使用O记号。</p><p>O(g(n))={f(n):存在正常量c,n0,使得对所有n&gt;=n0,有0&lt;=f(n)&lt;=cg(n)}</p><p><strong>Ω记号</strong></p><p>Ω记号提供了渐进下界。</p><p>Ω(g(n))={f(n):存在正常量c,n0,使得对所有n&gt;=n0,有0&lt;=cg(n)&lt;=f(n)}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-算法基础&quot;&gt;&lt;a href=&quot;#第二章-算法基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 算法基础&quot;&gt;&lt;/a&gt;第二章 算法基础&lt;/h1&gt;&lt;p&gt;非形式的说，&lt;strong&gt;算法(algorithm)&lt;/strong&gt;就是任何良定义的计算过程，该过程取某个值或值的集合作为&lt;strong&gt;输入&lt;/strong&gt;并产生某个值或值的集合作为&lt;strong&gt;输出&lt;/strong&gt;。这样算法就是把输入转换成输出的计算步骤的一个序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson22</title>
    <link href="https://zypsola.com/2019/02/27/C++Primer22/"/>
    <id>https://zypsola.com/2019/02/27/C++Primer22/</id>
    <published>2019-02-26T16:54:35.000Z</published>
    <updated>2019-02-26T16:56:27.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-模板和泛型编程"><a href="#第十六章-模板和泛型编程" class="headerlink" title="第十六章 模板和泛型编程"></a>第十六章 模板和泛型编程</h1><p>所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。第二部分中描述的标准库的容器、迭代器和算法都是泛型编程的例子。每种容器(如 vector)都有单一的定义，但可以定义许多不同种类的 vector，它们的区别在于所包含的元素类型。</p><a id="more"></a><h2 id="16-1-模板定义"><a href="#16-1-模板定义" class="headerlink" title="16.1 模板定义"></a>16.1 模板定义</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十六章-模板和泛型编程&quot;&gt;&lt;a href=&quot;#第十六章-模板和泛型编程&quot; class=&quot;headerlink&quot; title=&quot;第十六章 模板和泛型编程&quot;&gt;&lt;/a&gt;第十六章 模板和泛型编程&lt;/h1&gt;&lt;p&gt;所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。第二部分中描述的标准库的容器、迭代器和算法都是泛型编程的例子。每种容器(如 vector)都有单一的定义，但可以定义许多不同种类的 vector，它们的区别在于所包含的元素类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson21</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer21/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer21/</id>
    <published>2019-02-24T13:09:00.000Z</published>
    <updated>2019-02-26T16:52:12.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五章-面向对象编程"><a href="#第十五章-面向对象编程" class="headerlink" title="第十五章 面向对象编程"></a>第十五章 面向对象编程</h1><p>面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。</p><a id="more"></a><h2 id="15-1-面向对象编程：概述"><a href="#15-1-面向对象编程：概述" class="headerlink" title="15.1 面向对象编程：概述"></a>15.1 面向对象编程：概述</h2><p><strong>继承</strong>：派生类（derived class）能够继承基类（base class）定义的成员，派生类可以无须改变而使用那些与派生类型具体特性不相关的操作，派生类可以重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。</p><p><strong>动态绑定</strong>：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。</p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>保留字 virtual 的目的是启用动态绑定。成员默认为非虚函数，对非虚函数的调用在编译时确定。为了指明函数为虚函数，在其返回类型前面加上保留字 virtual。除了构造函数之外，任意非 static 成员函数都可以是虚函数。保留字只在类内部的成员函数声明中出现，不能用在类定义体外部出现的函数定义上。</p><p>基类通常应将派生类需要重定义的任意函数定义为虚函数。</p><h3 id="15-2-2-protected成员"><a href="#15-2-2-protected成员" class="headerlink" title="15.2.2 protected成员"></a>15.2.2 protected成员</h3><p>派生类对基类的 public 和 private 成员的访问权限与程序中任意其他部分一样：它可以访问 public 成员而不能访问 private 成员。protected 成员可以被派生类对象访问但不能被该类型的普通用户访问。</p><h3 id="15-2-3-派生类"><a href="#15-2-3-派生类" class="headerlink" title="15.2.3 派生类"></a>15.2.3 派生类</h3><p>为了定义派生类，使用类派生列表指定基类。类派生列表指定了一个或多个基类。</p><p>派生类一般会重定义所继承的虚函数。派生类没有重定义某个虚函数，则使用基类中定义的版本。</p><p>派生类型必须对想要重定义的每个继承成员进行声明。</p><p>派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。 </p><p>派生类重定义虚函数时，可以使用 virtual 保留字，但不是必须这样做。</p><p>已定义的类才可以用作基类。</p><h3 id="15-2-4-virtual与其他成员函数"><a href="#15-2-4-virtual与其他成员函数" class="headerlink" title="15.2.4 virtual与其他成员函数"></a>15.2.4 virtual与其他成员函数</h3><p>C++ 中的函数调用默认不使用动态绑定。要触发动态绑定，满足两个条件：第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；第二，必须通过基类类型的引用或指针进行函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">virtual void a() &#123;</span><br><span class="line">cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int b;</span><br><span class="line">protected:</span><br><span class="line">void c() &#123;</span><br><span class="line">cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">void a() &#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, *p;</span><br><span class="line">B b;</span><br><span class="line">p = &amp;a;</span><br><span class="line">p-&gt;a();       //a</span><br><span class="line">p = &amp;b;</span><br><span class="line">p-&gt;a();       //c</span><br><span class="line">p-&gt;A::a();    //a</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-2-5-公用、私有和受保护的继承"><a href="#15-2-5-公用、私有和受保护的继承" class="headerlink" title="15.2.5 公用、私有和受保护的继承"></a>15.2.5 公用、私有和受保护的继承</h3><p><strong>公用继承:</strong>基类成员保持自己的访问级别。</p><p><strong>受保护继承:</strong>基类的public和protected成员在派生类中为protected成员。 </p><p><strong>私有继承:</strong>基类的的所有成员在派生类中为private成员。</p><p><strong>接口继承与实现继承</strong></p><p>public 派生类继承基类的接口，它具有与基类相同的接口。设计良好的类层次中，public 派生类的对象可以用在任何需要基类对象的地方。</p><p>使用 private 或 protected 派生的类不继承基类的接口，相反，这些派生通常被称为实现继承。</p><p>派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C :private A&#123;</span><br><span class="line">public:</span><br><span class="line">using A::a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 class 保留字定义的派生默认具有 private 继承，而用 struct 保留字定义的类默认具有 public 继承。</p><h3 id="15-2-6-友元关系与继承"><a href="#15-2-6-友元关系与继承" class="headerlink" title="15.2.6 友元关系与继承"></a>15.2.6 友元关系与继承</h3><p>友元关系不能继承。</p><h3 id="15-2-7-继承与静态成员"><a href="#15-2-7-继承与静态成员" class="headerlink" title="15.2.7 继承与静态成员"></a>15.2.7 继承与静态成员</h3><p>如果基类定义 static 成员，则<strong>整个继承层次中只有一个这样的成员</strong>。无论从基类派生出多少个派生类，每个 static 成员只有一个实例。</p><h2 id="15-3-转换与继承"><a href="#15-3-转换与继承" class="headerlink" title="15.3 转换与继承"></a>15.3 转换与继承</h2><p>每个派生类对象包含一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行操作。因为派生类对象也是基类对象，所以存在从派生类型引用到基类类型引用的自动转换，即，可以将派生类对象的引用转换为基类子对象的引用，对指针也类似。 </p><p>基类类型对象既可以作为独立对象存在，也可以作为派生类对象的一部分而存在，因此，一个基类对象可能是也可能不是一个派生类对象的部分，结果，没有从基类引用（或基类指针）到派生类引用（或派生类指针）的（自动）转换。</p><p>相对于引用或指针而言，对象转换的情况更为复杂。虽然一般可以使用派生类型的对象对基类类型的对象进行初始化或赋值，但，没有从派生类型对象到基类类型对象的直接转换。</p><h2 id="15-4-构造函数与复制控制"><a href="#15-4-构造函数与复制控制" class="headerlink" title="15.4 构造函数与复制控制"></a>15.4 构造函数与复制控制</h2><p>构造函数和复制控制成员不能继承，每个类定义自己的构造函数和复制控制成员。</p><h3 id="15-4-2-派生类构造函数"><a href="#15-4-2-派生类构造函数" class="headerlink" title="15.4.2 派生类构造函数"></a>15.4.2 派生类构造函数</h3><p>派生类的合成默认构造函数与非派生的构造函数只有一点不同：除了初始化派生类的数据成员之外，它还初始化派生类对象的基类部分。基类部分由基类的默认构造函数初始化。</p><p>派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初始化继承成员。</p><p>构造函数初始化列表为类的基类和成员提供初始值，它并不指定初始化的执行次序。首先初始化基类，然后根据声明次序初始化派生类的成员。</p><h3 id="15-4-3-复制控制和继承"><a href="#15-4-3-复制控制和继承" class="headerlink" title="15.4.3 复制控制和继承"></a>15.4.3 复制控制和继承</h3><p>如果派生类定义了自己的复制构造函数，该复制构造函数一般应显式使用基类复制构造函数初始化对象的基类部分。</p><p>赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显式赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">A() :i(5) &#123;&#125;;</span><br><span class="line">A(const A&amp; a) &#123;</span><br><span class="line">i = 2 * a.i;</span><br><span class="line">&#125;</span><br><span class="line">int i;</span><br><span class="line">virtual void out() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; operator=(const A&amp; r) &#123;</span><br><span class="line">i = 3 * r.i;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">B() :j(3) &#123;&#125;;</span><br><span class="line">B(const B&amp; b) :A(b) &#123;</span><br><span class="line">j = 2 * b.j;</span><br><span class="line">&#125;</span><br><span class="line">int j;</span><br><span class="line">void out() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B&amp; operator=(const B&amp; r) &#123;</span><br><span class="line">A::operator=(r);</span><br><span class="line">j = 3 * r.j;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, b(a);</span><br><span class="line">a.out();      //5</span><br><span class="line">b.out();      //10</span><br><span class="line">a = b;</span><br><span class="line">a.out();      //30</span><br><span class="line">B c, d(c);</span><br><span class="line">c.out();      //5 3</span><br><span class="line">d.out();      //10 6</span><br><span class="line">c = d;</span><br><span class="line">c.out();      //30 18</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数的工作与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员。编译器总是显式调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员。对象的撤销顺序与构造顺序相反：首先运行派生析构函数，然后按继承层次依次向上调用各基类析构函数。</p><h3 id="15-4-4-虚析构函数"><a href="#15-4-4-虚析构函数" class="headerlink" title="15.4.4 虚析构函数"></a>15.4.4 虚析构函数</h3><p>如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~A() &#123;</span><br><span class="line">cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">~B() &#123;</span><br><span class="line">cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A *p = new A;</span><br><span class="line">delete p;      //a</span><br><span class="line">p = new B;</span><br><span class="line">delete p;      //b</span><br><span class="line">                   //a</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p><h2 id="15-5-继承情况下的类作用域"><a href="#15-5-继承情况下的类作用域" class="headerlink" title="15.5 继承情况下的类作用域"></a>15.5 继承情况下的类作用域</h2><p>每个类都保持着自己的作用域，在该作用域中定义了成员的名字。在继承情况下，派生类的作用域嵌套在基类作用域中。如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。</p><p>与基类成员同名的派生类成员将屏蔽对基类成员的直接访问。可以使用作用域操作符访问被屏蔽的基类成员。</p><p>在基类和派生类中使用同一名字的成员函数，其行为与数据成员一样：在派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽。</p><h2 id="15-6-纯虚函数"><a href="#15-6-纯虚函数" class="headerlink" title="15.6 纯虚函数"></a>15.6 纯虚函数</h2><p>含有（或继承）一个或多个纯虚函数的类是<strong>抽象类类型</strong>。不能创建抽象类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void out() = 0;</span><br></pre></td></tr></table></figure><h2 id="15-7-容器与继承"><a href="#15-7-容器与继承" class="headerlink" title="15.7 容器与继承"></a>15.7 容器与继承</h2><p>如果定义容器保存基类类型的对象，则加入派生类型的对象时，只将对象的基类部分保存在容器中。</p><h2 id="15-8-句柄类与继承"><a href="#15-8-句柄类与继承" class="headerlink" title="15.8 句柄类与继承"></a>15.8 句柄类与继承</h2><p>C++ 中一个通用的技术是定义包装（cover）类或句柄类。句柄类存储和管理基类指针。指针所指对象的类型可以变化，它既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。因为句柄类使用指针执行操作，虚成员的行为将在运行时根据句柄实际绑定的对象的类型而变化。因此，句柄的用户可以获得动态行为但无须操心指针的管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十五章-面向对象编程&quot;&gt;&lt;a href=&quot;#第十五章-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;第十五章 面向对象编程&quot;&gt;&lt;/a&gt;第十五章 面向对象编程&lt;/h1&gt;&lt;p&gt;面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson20</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer20/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer20/</id>
    <published>2019-02-24T08:09:00.000Z</published>
    <updated>2019-02-24T13:08:47.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-重载操作符与转换"><a href="#第十四章-重载操作符与转换" class="headerlink" title="第十四章 重载操作符与转换"></a>第十四章 重载操作符与转换</h1><p>C++ 允许我们重定义操作符用于类类型对象时的含义。如果需要，可以像内置转换那样使用类类型转换，将一个类型的对象隐式转换到另一类型。</p><a id="more"></a><h2 id="14-1-重载操作符的定义"><a href="#14-1-重载操作符的定义" class="headerlink" title="14.1 重载操作符的定义"></a>14.1 重载操作符的定义</h2><p>重载操作符是具有特殊名称的函数：保留字 operator 后接需定义的操作符号。像任意其他函数一样，重载操作符具有返回类型和形参表。</p><p>用于内置类型的操作符，其含义不能改变。重载操作符必须具有至少一个类类型或枚举类型的操作数。这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。</p><p>操作符的优先级、结合性或操作数目不能改变。不管操作数的类型和操作符的功能定义如何。</p><p>大多数重载操作符可以定义为普通非成员函数或类的成员函数。作为类成员的重载函数，其形参看起来比操作数数目少 1。作为成员函数的操作符有一个隐含的 this 形参，限定为第一个操作数。 </p><p>操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元。</p><h2 id="14-2-输入和输出操作符"><a href="#14-2-输入和输出操作符" class="headerlink" title="14.2 输入和输出操作符"></a>14.2 输入和输出操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">void outstr() &#123;cout &lt;&lt; str1 &lt;&lt; endl;&#125;</span><br><span class="line">friend istream&amp; operator&gt;&gt;(istream&amp;, Myclass&amp;);</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Myclass&amp;);</span><br><span class="line">friend Myclass&amp; operator+(const Myclass&amp;, const Myclass&amp;);</span><br><span class="line">Myclass&amp; operator+=(Myclass&amp;);</span><br><span class="line">private:</span><br><span class="line">string str1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline istream&amp; operator&gt;&gt;(istream&amp; in, Myclass&amp; m) &#123;</span><br><span class="line">in &gt;&gt; m.str1;</span><br><span class="line">return in;</span><br><span class="line">&#125;</span><br><span class="line">inline ostream&amp; operator&lt;&lt;(ostream&amp; out, const Myclass&amp; m) &#123;</span><br><span class="line">out &lt;&lt; m.str1;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-3-算术操作符和关系操作符"><a href="#14-3-算术操作符和关系操作符" class="headerlink" title="14.3 算术操作符和关系操作符"></a>14.3 算术操作符和关系操作符</h2><p>一般而言，将算术和关系操作符定义为非成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline Myclass&amp; Myclass::operator+=(Myclass&amp; r) &#123;</span><br><span class="line">this-&gt;str1 = this-&gt;str1 + r.str1;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Myclass&amp; operator+(const Myclass&amp; l, const Myclass&amp; r) &#123;</span><br><span class="line">Myclass tem;</span><br><span class="line">tem.str1 = l.str1 + r.str1;</span><br><span class="line">return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-5-下标操作符"><a href="#14-5-下标操作符" class="headerlink" title="14.5 下标操作符"></a>14.5 下标操作符</h2><p>下标操作符必须定义为类成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">Myclass() &#123; num = &#123; 1,2,3,4 &#125;; &#125;;</span><br><span class="line">int&amp; operator[](int);</span><br><span class="line">private:</span><br><span class="line">vector&lt;int&gt; num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int&amp; Myclass::operator[](int i) &#123;</span><br><span class="line">return num[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-8-调用操作符和函数对象"><a href="#14-8-调用操作符和函数对象" class="headerlink" title="14.8 调用操作符和函数对象"></a>14.8 调用操作符和函数对象</h2><p>函数调用操作符必须声明为成员函数。定义了调用操作符的类，其对象常称为函数对象，即它们是行为类似函数的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">int operator() (int val)&#123;</span><br><span class="line">return val*val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a;</span><br><span class="line">cout &lt;&lt; a(5);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十四章-重载操作符与转换&quot;&gt;&lt;a href=&quot;#第十四章-重载操作符与转换&quot; class=&quot;headerlink&quot; title=&quot;第十四章 重载操作符与转换&quot;&gt;&lt;/a&gt;第十四章 重载操作符与转换&lt;/h1&gt;&lt;p&gt;C++ 允许我们重定义操作符用于类类型对象时的含义。如果需要，可以像内置转换那样使用类类型转换，将一个类型的对象隐式转换到另一类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson19</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer19/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer19/</id>
    <published>2019-02-24T06:19:00.000Z</published>
    <updated>2019-02-26T14:56:18.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章-复制控制"><a href="#第十三章-复制控制" class="headerlink" title="第十三章 复制控制"></a>第十三章 复制控制</h1><p>当定义一个新类型的时候，需要显式或隐式地指定复制、赋值和撤销该类型的对象时会发生什么——这是通过定义特殊成员：复制构造函数、赋值操作符和析构函数来达到的。如果没有显式定义复制构造函数或赋值操作符，编译器（通常）会为我们定义。</p><a id="more"></a><p><strong>复制构造函数</strong>是一种特殊构造函数，具有单个形参，该形参（常用 const 修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。当将该类型的对象传递给函数或函数返回该类型的对象时，将隐式使用复制构造函数。</p><p><strong>析构函数</strong>是构造函数的互补：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非 static 数据成员的析构函数。</p><p>复制构造函数、赋值操作符和析构函数总称为<strong>复制控制</strong>。</p><h2 id="13-1-复制构造函数"><a href="#13-1-复制构造函数" class="headerlink" title="13.1 复制构造函数"></a>13.1 复制构造函数</h2><p>只有单个形参，而且该形参是对本类类型对象的引用（常用 const 修饰），这样的构造函数称为复制构造函数。与默认构造函数一样，复制构造函数可由编译器隐式调用。复制构造函数可用于：</p><ol><li>根据另一个同类型的对象显式或隐式初始化一个对象。</li><li>复制一个对象，将它作为实参传给一个函数。</li><li>从函数返回时复制一个对象。</li><li>初始化顺序容器中的元素。</li><li>根据元素初始化式列表初始化数组元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">A() :i(5) &#123;&#125;;</span><br><span class="line">A(const A&amp;);</span><br><span class="line">int i;</span><br><span class="line">void outA() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A(const A&amp; a) &#123;</span><br><span class="line">i = 2 * a.i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, b(a);</span><br><span class="line">a.outA();</span><br><span class="line">b.outA();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-1-1-合成的复制构造函数"><a href="#13-1-1-合成的复制构造函数" class="headerlink" title="13.1.1 合成的复制构造函数"></a>13.1.1 合成的复制构造函数</h3><p>如果我们没有定义复制构造函数，编译器就会为我们合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本。</p><h3 id="13-1-3-禁止复制"><a href="#13-1-3-禁止复制" class="headerlink" title="13.1.3 禁止复制"></a>13.1.3 禁止复制</h3><p>有些类需要完全禁止复制。例如，iostream 类就不允许复制。为了防止复制，类必须显式声明其复制构造函数为 private。然而，类的友元和成员仍可以进行复制。如果想要连友元和成员中的复制也禁止，就可以声明一个（private）复制构造函数但不对其定义。</p><h2 id="13-2-赋值操作符"><a href="#13-2-赋值操作符" class="headerlink" title="13.2 赋值操作符"></a>13.2 赋值操作符</h2><p>与复制构造函数一样，如果类没有定义自己的赋值操作符，则编译器会合成一个。</p><p>大多数操作符可以定义为成员函数或非成员函数。当操作符为成员函数时，它的第一个操作数隐式绑定到 this 指针。有些操作符（包括赋值操作符）必须是定义自己的类的成员。因为赋值必须是类的成员，所以 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为 const 引用传递。 </p><p>合成赋值操作符与合成复制构造函数的操作类似。它会执行逐个成员赋值：右操作数对象的每个成员赋值给左操作数对象的对应成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">Myclass(string);</span><br><span class="line">Myclass(Myclass&amp;);</span><br><span class="line">void outstr() &#123;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Myclass&amp; operator=(const Myclass&amp;);</span><br><span class="line">private:</span><br><span class="line">string str1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Myclass&amp; Myclass::operator=(const Myclass&amp; myc1) &#123;</span><br><span class="line">str1 = myc1.str1 + myc1.str1 + myc1.str1;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Myclass::Myclass(string str):str1(str) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Myclass::Myclass(Myclass&amp; myc1) &#123;</span><br><span class="line">str1 = myc1.str1 + myc1.str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a(&quot;123&quot;);</span><br><span class="line">a.outstr();           //123</span><br><span class="line">Myclass&amp; c = a;</span><br><span class="line">Myclass b(c);</span><br><span class="line">b.outstr();           //123123</span><br><span class="line">b = a;</span><br><span class="line">b.outstr();           //123123123</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-3-析构函数"><a href="#13-3-析构函数" class="headerlink" title="13.3 析构函数"></a>13.3 析构函数</h2><p>析构函数通常用于释放在构造函数或在对象生命期内获取的资源。</p><p>与复制构造函数或赋值操作符不同，编译器总是会为我们合成一个析构函数。<strong>合成析构函数</strong>按对象创建时的逆序撤销每个非 static 成员，因此，它按成员在类中声明次序的逆序撤销成员。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。 </p><p>析构函数与复制构造函数或赋值操作符之间的一个重要区别是，即使我们编写了自己的析构函数，合成析构函数仍然运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十三章-复制控制&quot;&gt;&lt;a href=&quot;#第十三章-复制控制&quot; class=&quot;headerlink&quot; title=&quot;第十三章 复制控制&quot;&gt;&lt;/a&gt;第十三章 复制控制&lt;/h1&gt;&lt;p&gt;当定义一个新类型的时候，需要显式或隐式地指定复制、赋值和撤销该类型的对象时会发生什么——这是通过定义特殊成员：复制构造函数、赋值操作符和析构函数来达到的。如果没有显式定义复制构造函数或赋值操作符，编译器（通常）会为我们定义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson18</title>
    <link href="https://zypsola.com/2018/11/10/C++Primer18/"/>
    <id>https://zypsola.com/2018/11/10/C++Primer18/</id>
    <published>2018-11-09T16:03:18.000Z</published>
    <updated>2019-02-23T16:04:02.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-类"><a href="#第十二章-类" class="headerlink" title="第十二章 类"></a>第十二章 类</h1><p>在 C++ 中，用类来定义自己的抽象数据类型（abstract data types）。通过定义类型来对应所要解决的问题中的各种概念，可以使我们更容易编写、调试和修改程序。</p><a id="more"></a><p>类类型常被称为抽象数据类型。抽象数据类型将数据（即状态）和作用于状态的操作视为一个单元。我们可以抽象地考虑类该做什么，而无须知道类如何去完成这些操作。抽象数据类型是面向对象编程和泛型编程的基础。 </p><h2 id="12-1-类的定义和声明"><a href="#12-1-类的定义和声明" class="headerlink" title="12.1 类的定义和声明"></a>12.1 类的定义和声明</h2><h3 id="12-1-1-类定义"><a href="#12-1-1-类定义" class="headerlink" title="12.1.1 类定义"></a>12.1.1 类定义</h3><p>最简单地说，类就是定义了一个新的类型和一个新作用域。</p><p><strong>类成员</strong>:每个类可以没有成员，也可以定义多个成员，成员可以是数据、函数或类型别名。 所有成员必须在类的内部声明，一旦类定义完成后，就没有任何方式可以增加成员了。 </p><p><strong>构造函数</strong>:构造函数是一个特殊的、与类同名的成员函数，用于给每个数据成员设置适当的初始值。 构造函数一般就使用一个构造函数初始化列表，来初始化对象的数据成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong>:在类内部定义的函数默认为inline。 成员函数有一个附加的隐含实参，将函数绑定到调用函数的对象；将关键字 const 加在形参表之后，就可以将成员函数声明为常量。const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声明和定义中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double avg_price() const;</span><br></pre></td></tr></table></figure><h3 id="12-1-2-数据抽象和封装"><a href="#12-1-2-数据抽象和封装" class="headerlink" title="12.1.2 数据抽象和封装"></a>12.1.2 数据抽象和封装</h3><p>类背后蕴涵的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。 </p><p>在C++中，使用访问标号来定义类的抽象接口和实施封装。类型的数据抽象视图由其 public 成员定义。 private 封装了类型的实现细节。 </p><h2 id="12-2-隐含的-this指针"><a href="#12-2-隐含的-this指针" class="headerlink" title="12.2 隐含的 this指针"></a>12.2 隐含的 this指针</h2><p>成员函数具有一个附加的隐含形参，即指向该类对象的一个指针。这个隐含形参命名为 this，与调用成员函数的对象绑定在一起。成员函数不能定义 this 形参，而是由编译器隐含地定义。如果对类成员的引用没有限定，编译器会将这种引用处理成通过 this 指针的引用。 </p><p>尽管在成员函数内部显式引用 this 通常是不必要的，但有一种情况下必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最<br>常见的情况是在这样的函数中使用 this：该函数返回对调用该函数的对象的引用。 </p><p>在普通的非 const 成员函数中，this 的类型是一个指向类类型的 const 指针。可以改变 this 所指向的值，但不能改变 this 所保存的地址。在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。</p><p><strong>可变数据成员</strong></p><p>有时，我们希望类的数据成员（甚至在 const 成员函数内）可以修改。这可以通过将它们声明为 mutable 来实现。 </p><p>可变数据成员永远都不能为 const，甚至当它是 const 对象的成员时也如此。因此，const 成员函数可以改变 mutable 成员。</p><h2 id="12-3-类作用域"><a href="#12-3-类作用域" class="headerlink" title="12.3 类作用域"></a>12.3 类作用域</h2><p>如果返回类型使用由类定义的类型，则必须使用完全限定名： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123; </span><br><span class="line">   public: </span><br><span class="line">       typedef std::string::size_type index; </span><br><span class="line">       index get_cursor() const; </span><br><span class="line">   &#125;; </span><br><span class="line">   inline Screen::index Screen::get_cursor() const </span><br><span class="line">   &#123; </span><br><span class="line">       return cursor; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="12-4-构造函数"><a href="#12-4-构造函数" class="headerlink" title="12.4 构造函数"></a>12.4 构造函数</h2><p>构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值。</p><p><strong>构造函数可以被重载</strong></p><p><strong>构造函数自动执行</strong></p><p><strong>构造函数不能声明为const</strong></p><h3 id="12-4-1-构造函数初始化式"><a href="#12-4-1-构造函数初始化式" class="headerlink" title="12.4.1 构造函数初始化式"></a>12.4.1 构造函数初始化式</h3><p>构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。构造函数初始化只在构造函数的定义中而不是声明中指定。 </p><p>从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。 不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。 </p><p>有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。 </p><p><strong>成员初始化的次序</strong></p><p>构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。</p><p>初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数。可以使用该类型的任意构造函数。</p><h3 id="12-4-2-默认实参与构造函数"><a href="#12-4-2-默认实参与构造函数" class="headerlink" title="12.4.2 默认实参与构造函数"></a>12.4.2 默认实参与构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book = &quot;&quot;):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-3-默认构造函数"><a href="#12-4-3-默认构造函数" class="headerlink" title="12.4.3 默认构造函数"></a>12.4.3 默认构造函数</h3><p>只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。 </p><h3 id="12-4-4-隐式类类型转换"><a href="#12-4-4-隐式类类型转换" class="headerlink" title="12.4.4 隐式类类型转换"></a>12.4.4 隐式类类型转换</h3><p>可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.same_isbn(cin);</span><br></pre></td></tr></table></figure><p><strong>抑制由构造函数定义的隐式转换</strong>：可以通过将构造函数声明为 explicit，来防止在需要隐式转换的上下文中使用构造函数。explicit 关键字只能用于类内部的构造函数声明上。在类的定义体外部所做的定义上不再重复它。</p><p><strong>为转换而显式地使用构造函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book = &quot;9-999-99999-9&quot;; </span><br><span class="line">item.same_isbn(Sales_item(null_book))</span><br></pre></td></tr></table></figure><h3 id="12-4-5-类成员的显式初始化"><a href="#12-4-5-类成员的显式初始化" class="headerlink" title="12.4.5 类成员的显式初始化"></a>12.4.5 类成员的显式初始化</h3><p>对于没有定义构造函数并且其全体数据成员均为 public 的类，可以采用与初始化数组元素相同的方式初始化其成员。根据数据成员的声明次序来使用初始化式。</p><h2 id="12-5-友元"><a href="#12-5-友元" class="headerlink" title="12.5 友元"></a>12.5 友元</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字 friend 开始。它只能出现在类定义的内部。友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A1;</span><br><span class="line">class A2;</span><br><span class="line"></span><br><span class="line">class A1 &#123;</span><br><span class="line">public:</span><br><span class="line">A1() :a(1) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">friend int addA12(A1 a1, A2 a2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 &#123;</span><br><span class="line">public:</span><br><span class="line">A2() :a(2) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">friend int addA12(A1 a1, A2 a2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int addA12(A1 a1, A2 a2) &#123;</span><br><span class="line">return a1.a + a2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A1 aa;</span><br><span class="line">A2 ab;</span><br><span class="line">cout &lt;&lt; addA12(aa, ab) &lt;&lt; endl;       //3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-static类成员"><a href="#12-6-static类成员" class="headerlink" title="12.6 static类成员"></a>12.6 static类成员</h2><p>通常，非 static 数据成员存在于类类型的每个对象中。static 数据成员独立于该类的任意对象而存在；每个 static 数据成员是与类关联的对象，并不与该类的对象相关联。</p><p>static 成员函数没有 this 形参，它可以直接访问所属类的 static 成员，但不能直接使用非 static 成员。</p><p>当我们在类的外部定义 static 成员时，无须重复指定 static 保留字，该保留字只出现在类定义体内部的声明处。</p><p>static 数据成员必须在类定义体的外部定义（正好一次）。不像普通数据成员，static 成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><p><strong>抽象数据类型：</strong>使用封装来隐藏其实现的数据结构，允许使用类型的程序员抽象地考虑该类型做什么，而不是具体地考虑类型如何表示。</p></li><li><p><strong>封装：</strong>实现与接口的分离。封闭隐藏了类型的实现细节。在 C++ 中，实施封装可以阻止普通用户访问类的 private 部分。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十二章-类&quot;&gt;&lt;a href=&quot;#第十二章-类&quot; class=&quot;headerlink&quot; title=&quot;第十二章 类&quot;&gt;&lt;/a&gt;第十二章 类&lt;/h1&gt;&lt;p&gt;在 C++ 中，用类来定义自己的抽象数据类型（abstract data types）。通过定义类型来对应所要解决的问题中的各种概念，可以使我们更容易编写、调试和修改程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson17</title>
    <link href="https://zypsola.com/2018/11/07/C++Primer17/"/>
    <id>https://zypsola.com/2018/11/07/C++Primer17/</id>
    <published>2018-11-07T09:21:36.000Z</published>
    <updated>2018-11-09T16:02:51.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章-泛型算法"><a href="#第十一章-泛型算法" class="headerlink" title="第十一章 泛型算法"></a>第十一章 泛型算法</h1><p>标准库并没有为每种容器类型都定义实现这些操作的成员函数，而是定义了一组<strong>泛型算法</strong>：因为它们实现共同的操作，所以称之为“算法”；而“泛型”指的是它们可以操作在多种容器类型上——不但可作用于vector或list这些标准库类型，还可用在内置数组类型、甚至其他类型的序列上。自定义的容器类型只要与标准库兼容，同样可以使用这些泛型算法。 </p><a id="more"></a><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>泛型算法本身从不执行容器操作，只是单独依赖迭代器和迭代器操作实现。</p><p>大多数情况下，每个算法都需要使用（至少）两个迭代器指出该算法操纵的元素范围。第一个迭代器指向第一个元素，而第二个迭代器则指向最后一个元素的下一位置。第二个迭代器所指向的元素［有时被称为超出末端迭代器］本身不是要操作的元素，而被用作终止遍历的哨兵。 </p><h2 id="11-2-初窥算法"><a href="#11-2-初窥算法" class="headerlink" title="11.2 初窥算法"></a>11.2 初窥算法</h2><p>使用泛型算法必须包含 algorithm 头文件，标准库还定义了一组泛化的算术算法，其命名习惯与泛型算法相同。使用这些算法则必须包含 numeric 头文件。</p><p>除了少数例外情况，所有算法都在一段范围内的元素上操作。带有输入范围参数的算法总是使用头两个形参标记该范围。这两个形参是分别指向要处理的第一个元素和最后一个元素的下一位置的迭代器。 </p><p>理解算法的最基本方法是了解该算法是否读元素、写元素或者对元素进行重新排序。</p><h3 id="11-2-1-只读算法"><a href="#11-2-1-只读算法" class="headerlink" title="11.2.1 只读算法"></a>11.2.1 只读算法</h3><p>许多算法只会读取其输入范围内的元素，而不会写这些元素。find 就是一个这样的算法。另一个简单的只读算法是 accumulate，该算法在 numeric 头文件中定义。</p><p>accumulate 带有三个形参。头两个形参指定要累加的元素范围。第三个形参则是累加的初值。用于指定累加起始值的第三个实参是必要的，因为 accumulate 对将要累加的元素类型一无所知，因此，除此之外，没有别的办法创建合适的起始值或者关联的类型。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10, 5);</span><br><span class="line">cout &lt;&lt; static_cast&lt;int&gt;(accumulate(ivec.begin(), ivec.end(), 0)) &lt;&lt; endl;      //50</span><br><span class="line">vector&lt;string&gt; cvec(3, &quot;ab&quot;);</span><br><span class="line">string str = accumulate(cvec.begin(), cvec.end(), static_cast&lt;string&gt;(&quot;ccc&quot;));</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;          //cccababab</span><br></pre></td></tr></table></figure><h3 id="11-2-2-写容器元素的算法"><a href="#11-2-2-写容器元素的算法" class="headerlink" title="11.2.2 写容器元素的算法"></a>11.2.2 写容器元素的算法</h3><p>写入到输入序列的算法本质上是安全的——只会写入与指定输入范围数量相同的元素。 </p><p>fill 带有一对迭代器形参，用于指定要写入的范围，而所写的值是它的第三个形参的副本。fill_n 函数带有的参数包括：一个迭代器、一个计数器以及一个值。该函数从迭代器指向的元素开始，将指定数量的元素设置为给定的值。对指定数目的元素做写入运算，或者写到目标迭代器的算法，都不检查目标的大小是否足以存储要写入的元素。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10, 5);</span><br><span class="line">fill(ivec.begin(), ivec.end(), 6);</span><br><span class="line">fill_n(ivec.begin(), 5, 10);</span><br><span class="line">cout &lt;&lt; static_cast&lt;int&gt;(accumulate(ivec.begin(), ivec.end(), 0)) &lt;&lt; endl;      //80</span><br></pre></td></tr></table></figure><p><strong>引入back_inserter</strong></p><p>确保算法有足够的元素存储输出数据的一种方法是使用<strong>插入迭代器</strong>。插入迭代器是可以给基础容器添加元素的迭代器。通常，用迭代器给容器元素赋值时，被赋值的是迭代器所指向的元素。而使用插入迭代器赋值时，则会在容器中添加一个新元素，其值等于赋值运算的右操作数的值。使用back_inserter必须包含 iterator 头文件</p><p>back_inserter函数是迭代器适配器。与容器适配器一样，迭代器适配器使用一个对象作为实参，并生成一个适应其实参行为的新对象。</p><p>传递给 back_inserter 的实参是一个容器的引用。back_inserter 生成一个绑定在该容器上的插入迭代器。在试图通过这个迭代器给元素赋值时，赋值运算将调用 push_back 在容器中添加一个具有指定值的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(5, 4);</span><br><span class="line">fill_n(back_inserter(ivec), 5, 1);       //4 4 4 4 4 1 1 1 1 1</span><br></pre></td></tr></table></figure><p>copy 带有三个迭代器参数：头两个指定输入范围，第三个则指向目标序列的一个元素。传递给 copy 的目标序列必须至少要与输入范围一样大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; ilst(2, 5);</span><br><span class="line">vector&lt;int&gt; ivec(3, 7);</span><br><span class="line">copy(ilst.begin(), ilst.end(), ivec.begin());      //5 5 7</span><br><span class="line">copy(ilst.begin(), ilst.end(), back_inserter(ivec));   //5 5 7 5 5</span><br></pre></td></tr></table></figure><p>replace算法对输入序列做读写操作，将序列中特定的值替换为新的值。该算法带有四个形参：一对指定输入范围的迭代器和两个值。每一个等于第一值的元素替换成第二个值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(ivec.begin(), ivec.end(), 5, 9);</span><br></pre></td></tr></table></figure><h3 id="11-2-3-对容器元素重新排序的算法"><a href="#11-2-3-对容器元素重新排序的算法" class="headerlink" title="11.2.3 对容器元素重新排序的算法"></a>11.2.3 对容器元素重新排序的算法</h3><p>unique 算法带有两个指定元素范围的迭代器参数。该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器，表示无重复的值范围的结束。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[8] = &#123; 1,3,5,5,3,3,5,1 &#125;;</span><br><span class="line">vector&lt;int&gt; ivec(a, a + 8);</span><br><span class="line">vector&lt;int&gt;::iterator end_uni = unique(ivec.begin(), ivec.end());   //ivec:1,3,5,3,5,1,5,1</span><br><span class="line">vector&lt;int&gt;::iterator iter = ivec.begin();</span><br><span class="line">while (iter != end_uni) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;         //135351</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique 实际上并没有删除任何元素，而是将无重复的元素复制到序列的前端，从而覆盖相邻的重复元素。unique 返回的迭代器指向超出无重复的元素范围末端的下一位置。 </p><p><strong>stable_sort 和 count_if</strong>。使用这些算法，还需要一个配套的实用函数，称为<strong>谓词</strong>。谓词是做某些检测的函数，返回用于条件判断的类型，指出条件是否成立。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool smaller(const int &amp;v1,const int &amp;v2) &#123;</span><br><span class="line">return v1 &lt; v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool more5(const int &amp;v) &#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[8] = &#123; 1,3,6,5,4,8,5,9 &#125;;</span><br><span class="line">vector&lt;int&gt; ivec(a, a + 8);</span><br><span class="line">cout &lt;&lt; count_if(ivec.begin(), ivec.end(), more5) &lt;&lt; endl;   //3</span><br><span class="line">sort(ivec.begin(), ivec.end(), smaller);</span><br><span class="line">vector&lt;int&gt;::iterator iter = ivec.begin();</span><br><span class="line">while (iter != ivec.end()) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;       //13455689</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-再谈迭代器"><a href="#11-3-再谈迭代器" class="headerlink" title="11.3 再谈迭代器"></a>11.3 再谈迭代器</h2><p>标准库所定义的迭代器不依赖于特定的容器。事实上，C++语言还提供了另外三种迭代器： </p><ol><li><p>插入迭代器：这类迭代器与容器绑定在一起，实现在容器中插入元素的功能。 </p></li><li><p>iostream 迭代器：这类迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 </p></li><li><p>反向迭代器：这类迭代器实现向后遍历，而不是向前遍历。所有容器类型都定义了自己的 reverse_iterator 类型，由 rbegin 和 rend 成员函数返回。 </p></li></ol><h3 id="11-3-1-插入迭代器"><a href="#11-3-1-插入迭代器" class="headerlink" title="11.3.1 插入迭代器"></a>11.3.1 插入迭代器</h3><p>back_inserter，创建使用 push_back 实现插入的迭代器。 </p><p>front_inserter，使用 push_front 实现插入。 </p><p>inserter，使用 insert 实现插入操作。除了所关联的容器外，inserter还带有第二实参：指向插入起始位置的迭代器。 </p><h3 id="11-3-2-iostream-迭代器"><a href="#11-3-2-iostream-迭代器" class="headerlink" title="11.3.2 iostream 迭代器"></a>11.3.2 iostream 迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;T&gt; in(strm);      //创建从输入流 strm 中读取 T 类型对象的 istream_iterator 对象 </span><br><span class="line">istream_iterator&lt;T&gt; in;            //istream_iterator 对象的超出末端迭代器 </span><br><span class="line">ostream_iterator&lt;T&gt; in(strm);      //创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象 </span><br><span class="line">ostream_iterator&lt;T&gt; in(strm, delim);     //创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象，在写入过程中使用 delim 作为元素的分隔符。delim 是以空字符结束的字符数组</span><br></pre></td></tr></table></figure><p>这个程序读 cin，并将每个读入的值依次写到 cout 中不同的行中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;string&gt; out_iter(cout, &quot;\n&quot;);</span><br><span class="line">istream_iterator&lt;string&gt; in_iter(cin), eof;</span><br><span class="line">while (in_iter != eof) &#123;</span><br><span class="line">*out_iter++ = *in_iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可能从 ostream_iterator 对象读入，也不可能写到 istream_iterator 对象中。 </p><p>一旦给 ostream_iterator 对象赋了一个值，写入就提交了。赋值后，没有办法再改变这个值。此外，ostream_iterator 对象中每个不同的值都只能正好输出一次。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; cin_it(cin), end_of_stream;</span><br><span class="line">vector&lt;int&gt; vec(cin_it, end_of_stream);       //输入：3 109 45 89 6 34 12 90 34 23 56 23 8 89 23</span><br><span class="line">sort(vec.begin(), vec.end());</span><br><span class="line">ostream_iterator&lt;int&gt; output(cout, &quot; &quot;);</span><br><span class="line">unique_copy(vec.begin(), vec.end(), output);      //6 8 12 23 34 45 56 89 90 109</span><br></pre></td></tr></table></figure><h3 id="11-3-3-反向迭代器"><a href="#11-3-3-反向迭代器" class="headerlink" title="11.3.3 反向迭代器"></a>11.3.3 反向迭代器</h3><p>反向迭代器是一种反向遍历容器的迭代器。也就是，从最后一个元素到第一个元素遍历容器。反向迭代器将自增（和自减）的含义反过来了：对于反向迭代器，++ 运算将访问前一个元素，而 – 运算则访问下一个元素。 </p><p>流迭代器不能创建反向迭代器。</p><h3 id="11-3-4-const-迭代器"><a href="#11-3-4-const-迭代器" class="headerlink" title="11.3.4 const 迭代器"></a>11.3.4 const 迭代器</h3><p>不希望使用这个迭代器来修改容器中的元素。 </p><h3 id="11-3-5-五种迭代器"><a href="#11-3-5-五种迭代器" class="headerlink" title="11.3.5 五种迭代器"></a>11.3.5 五种迭代器</h3><p>输入迭代器：读，不能写；只支持自增运算<br>输出迭代器：写，不能读；只支持自增运算<br>前向迭代器：读和写；只支持自增运算<br>双向迭代器：读和写；支持自增和自减运算<br>随机访问迭代器：读和写；支持完整的迭代器算术运算 </p><h2 id="11-4-泛型算法的结构"><a href="#11-4-泛型算法的结构" class="headerlink" title="11.4 泛型算法的结构"></a>11.4 泛型算法的结构</h2><p>大多数算法采用下面四种形式之一： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg (beg, end, other parms); </span><br><span class="line">alg (beg, end, dest, other parms); </span><br><span class="line">alg (beg, end, beg2, other parms); </span><br><span class="line">alg (beg, end, beg2, end2, other parms)</span><br></pre></td></tr></table></figure><p>其中，alg 是算法的名字，beg 和 end 指定算法操作的元素范围。其他形参：dest、beg2 和 end2，它们都是迭代器。有些算法还带有其他的非迭代器形参。</p><h2 id="11-5-容器特有的算法"><a href="#11-5-容器特有的算法" class="headerlink" title="11.5 容器特有的算法"></a>11.5 容器特有的算法</h2><p>list 容器上的迭代器是双向的，而不是随机访问类型。由于 list 容器不支持随机访问，因此，在此容器上不能使用需要随机访问迭代器的算法。这些算法包括 sort 及其相关的算法。还有一些其他的泛型算法，如 merge、remove、reverse 和 unique，虽然可以用在 list 上，但却付出了性能上的代价。</p><p><strong>list 容器特有的操作</strong></p><p>对于 list 对象，应该优先使用 list 容器特有的成员版本，而不是泛型算法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst.merge(lst2) </span><br><span class="line">lst.merge(lst2, comp)</span><br></pre></td></tr></table></figure><p>将 lst2 的元素合并到 lst 中。这两个 list 容器对象都必须排序。lst2 中的元素将被删除。合并后，lst2 为空。返回 void 类型。第一个版本使用 &lt; 操作符，而第二个版本则使用 comp 指定的比较运算 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst.remove(val) </span><br><span class="line">lst.remove_if(unaryPred)</span><br></pre></td></tr></table></figure><p>调用 lst.erase 删除所有等于指定值或使指定的谓词函数返回非零值的元素。返回 void 类型 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十一章-泛型算法&quot;&gt;&lt;a href=&quot;#第十一章-泛型算法&quot; class=&quot;headerlink&quot; title=&quot;第十一章 泛型算法&quot;&gt;&lt;/a&gt;第十一章 泛型算法&lt;/h1&gt;&lt;p&gt;标准库并没有为每种容器类型都定义实现这些操作的成员函数，而是定义了一组&lt;strong&gt;泛型算法&lt;/strong&gt;：因为它们实现共同的操作，所以称之为“算法”；而“泛型”指的是它们可以操作在多种容器类型上——不但可作用于vector或list这些标准库类型，还可用在内置数组类型、甚至其他类型的序列上。自定义的容器类型只要与标准库兼容，同样可以使用这些泛型算法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson16</title>
    <link href="https://zypsola.com/2018/11/06/C++Primer16/"/>
    <id>https://zypsola.com/2018/11/06/C++Primer16/</id>
    <published>2018-11-06T13:26:16.000Z</published>
    <updated>2018-11-07T09:19:53.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-关联容器"><a href="#第十章-关联容器" class="headerlink" title="第十章 关联容器"></a>第十章 关联容器</h1><p><strong>关联容器</strong>和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。 </p><a id="more"></a><p>关联容器（Associative containers）支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map、set。map 的元素以键－值（key-value）对的形式组织：键用作元素在 map 中的索引，而值则表示所存储和读取的数据。set 仅包含一个键，并有效地支持关于某个键是否存在的查询。 </p><p>set 和 map 类型的对象所包含的元素都具有不同的键，不允许为同一个键添加第二个元素。如果一个键必须对应多个实例，则需使用 multimap 或 multiset，这两种类型允许多个元素拥有相同的键。 </p><h2 id="10-1-引言：pair类型"><a href="#10-1-引言：pair类型" class="headerlink" title="10.1 引言：pair类型"></a>10.1 引言：pair类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;         创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用值初始化</span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2); 创建一个 pair 对象，它的两个元素分别是 T1 和 T2 ，其中 first 成员初始化为 v1，而 second 成员初始化为 v2 </span><br><span class="line">make_pair(v1, v2)        以 v1 和 v2 值创建一个新 pair 对象，其元素类型分别是 v1 和 v2 的类型 </span><br><span class="line">p1 &lt; p2    两个 pair 对象之间的小于运算，其定义遵循字典次序：如果 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second，则返回 true </span><br><span class="line">p1 == p2   如果两个 pair 对象的 first 和 second 成员依次相等，则这两个对象相等。该运算使用其元素的 == 操作符 </span><br><span class="line">p.first    返回 p 中名为 first 的（公有）数据成员 </span><br><span class="line">p.second   返回 p 的名为 second 的（公有）数据成员</span><br></pre></td></tr></table></figure><p>与其他标准库类型不同，对于 pair 类，可以直接访问其数据成员：其成员都是仅有的，分别命名为 first 和 second。只需使用普通的点操作符——成员访问标志即可访问其成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, string&gt; b = make_pair(4, &quot;afsd&quot;);  </span><br><span class="line">cout &lt;&lt; b.first &lt;&lt; b.second &lt;&lt; endl;   //4afsd</span><br><span class="line">b = pair&lt;int, string&gt;(6, &quot;ggg&quot;);</span><br><span class="line">cout &lt;&lt; b.first &lt;&lt; b.second &lt;&lt; endl;   //6ggg</span><br></pre></td></tr></table></figure><h2 id="10-2-关联容器"><a href="#10-2-关联容器" class="headerlink" title="10.2 关联容器"></a>10.2 关联容器</h2><p>关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供 front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 </p><ol><li><p>三种构造函数：C<t> c; C<t> c1(c2);  C<t> c(b, e); 关联容器不能通过容器大小来定义，因为这样的话就无法知道键所对应的值是什么。 </t></t></t></p></li><li><p>关系运算。</p></li><li><p>begin、end、rbegin 和 rend 操作。 </p></li><li><p>swap 和赋值操作。但关联容器不提供 assign 函数。</p></li><li><p>clear 和 erase 操作，但关联容器的 erase 运算返回 void 类型。 </p></li><li><p>关于容器大小的操作。但 resize 函数不能用于关联容器。</p></li></ol><h2 id="10-3-map类型"><a href="#10-3-map类型" class="headerlink" title="10.3 map类型"></a>10.3 map类型</h2><p>map 是键－值对的集合。map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。而关联的本质在于元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取。 </p><h3 id="10-3-1-map对象的定义"><a href="#10-3-1-map对象的定义" class="headerlink" title="10.3.1 map对象的定义"></a>10.3.1 map对象的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;k, v&gt; m;         创建一个名为 m 的空 map 对象，其键和值的类型分别为 k 和 v</span><br><span class="line">map&lt;k, v&gt; m(m2);     创建 m2 的副本 m，m 与 m2 必须有相同的键类型和值类型 </span><br><span class="line">map&lt;k, v&gt; m(b, e);   创建 map 类型的对象 m，存储迭代器 b 和 e 标记的范围内所有元素的副本。元素的类型必须能转换为 pair&lt;const k, v&gt;</span><br></pre></td></tr></table></figure><p>在使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。默认情况下，标准库使用键类型定义的 &lt; 操作符来实现键（key type）的比较。</p><p>所用的比较函数必须在键类型上定义严格弱排序（strict weak ordering）。所谓的严格弱排序可理解为键类型数据上的“小于”关系，虽然实际上可以选择将比较函数设计得更复杂。但无论这样的比较函数如何定义，当用于一个键与自身的比较时，肯定会导致 false 结果。此外，在比较两个键时，不能出现相互“小于”的情况，而且，如果 k1“小于”k2，k2“小于”k3，则 k1 必然“小于”k3。对于两个键，如果它们相互之间都不存在“小于”关系，则容器将之视为相同的键。用做 map 对象的键时，可使用任意一个键值来访问相应的元素。 </p><h3 id="10-3-2-map定义的类型"><a href="#10-3-2-map定义的类型" class="headerlink" title="10.3.2 map定义的类型"></a>10.3.2 map定义的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt;::key_type    在 map 容器中，用做索引的键的类型 </span><br><span class="line">map&lt;K, V&gt;::mapped_type 在 map 容器中，键所关联的值的类型 </span><br><span class="line">map&lt;K, V&gt;::value_type  一个 pair 类型，它的 first 元素具有 const map&lt;K, V&gt;::key_type 类型，而 second 元素则为 map&lt;K, V&gt;::mapped_type 类型</span><br></pre></td></tr></table></figure><p>value_type 是 pair 类型，它的值成员可以修改，但键成员不能修改。 </p><p>对迭代器进行解引用时，将获得一个引用，指向容器中一个 value_type 类型的值。对于 map 容器，其 value_type 是 pair 类型。</p><h3 id="10-3-3-给map添加元素"><a href="#10-3-3-给map添加元素" class="headerlink" title="10.3.3 给map添加元素"></a>10.3.3 给map添加元素</h3><p>可使用 insert 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。</p><h3 id="10-3-4-使用下标访问map对象"><a href="#10-3-4-使用下标访问map对象" class="headerlink" title="10.3.4 使用下标访问map对象"></a>10.3.4 使用下标访问map对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m[&quot;abc&quot;] = 5;</span><br><span class="line">m[&quot;Abc&quot;] = 3;</span><br><span class="line">map&lt;string, int&gt;::iterator iter = m.begin();</span><br><span class="line">cout &lt;&lt; (*iter).first &lt;&lt; (*iter).second &lt;&lt; endl;     //Abc3</span><br><span class="line">cout &lt;&lt; m.size() &lt;&lt; endl;                            //2</span><br></pre></td></tr></table></figure><p>map 的下标也使用索引（键）来获取该键所关联的值。如果该键已在容器中，则 map 的下标运算与 vector 的下标运算行为相同：返回该键所关联的值。只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。</p><h3 id="10-3-5-map-insert-的使用"><a href="#10-3-5-map-insert-的使用" class="headerlink" title="10.3.5 map::insert 的使用"></a>10.3.5 map::insert 的使用</h3><ol><li><p>m.insert(e)        e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则插入一个值为 e.second 的新元素；如果该键在 m 中已存在，则保持 m 不变。该函数返回一个 pair 类型对象，包含指向键为 e.first 的元素的 map 迭代器，以及一个 bool 类型的对象，表示是否插入了该元素 </p></li><li><p>m.insert(beg, end) beg 和 end 是标记元素范围的迭代器，其中的元素必须为 m.value_type 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。返回 void 类型 </p></li><li><p>m.insert(iter, e)  e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则创建新元素，并以迭代器 iter 为起点搜索新元素存储的位置。返回一个迭代器，指向 m 中具有给定键的元素 </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef map&lt;string, int&gt;::value_type valType;</span><br><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m.insert(map&lt;string, int&gt;::value_type(&quot;afd&quot;, 7));</span><br><span class="line">m.insert(make_pair(&quot;4df&quot;, 1));</span><br><span class="line">m.insert(valType(&quot;123&quot;, 9));</span><br></pre></td></tr></table></figure><h3 id="10-3-6-查找并读取map中的元素"><a href="#10-3-6-查找并读取map中的元素" class="headerlink" title="10.3.6 查找并读取map中的元素"></a>10.3.6 查找并读取map中的元素</h3><p>下标操作符给出了读取一个值的最简单方法，但是，使用下标存在一个很危险的副作用：如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。 </p><p>map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.count(k)  返回m中k的出现次数 </span><br><span class="line">m.find(k)   如果m容器中存在按k索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代</span><br></pre></td></tr></table></figure><p>对于 map 对象，count 成员的返回值只能是 0 或 1。map 容器只允许一个键对应一个实例，所以 count 可有效地表明一个键是否存在。</p><h3 id="10-3-7-从-map-对象中删除元素"><a href="#10-3-7-从-map-对象中删除元素" class="headerlink" title="10.3.7 从 map 对象中删除元素"></a>10.3.7 从 map 对象中删除元素</h3><p>map 容器的 erase 操作返回 void。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.erase(k)     删除 m 中键为 k 的元素。返回被删除元素的个数。对于 map 容器，该值必然是 0 或 1。如果返回 0，则表示欲删除的元素在 map 不存在。 </span><br><span class="line">m.erase(p)     从 m 中删除迭代器 p 所指向的元素。p 必须指向 m 中确实存在的元素，而且不能等于 m.end()。返回 void </span><br><span class="line">m.erase(b, e)  从 m 中删除一段范围内的元素，该范围由迭代器对 b 和 e 标记。b 和 e 必须标记 m 中的一段有效范围：即 b 和 e 都必须指向 m 中的元素或最后一个元素的下一个位置。而且，b 和 e 要么相等（此时删除的范围为空），要么 b 所指向的元素必须出现在 e 所指向的元素之前。返回 void 类型</span><br></pre></td></tr></table></figure><h2 id="10-4-set"><a href="#10-4-set" class="headerlink" title="10.4 set"></a>10.4 set</h2><p>set 容器只是单纯的键的集合。</p><p>set 容器支持大部分的 map 操作，set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。它们指的都是 set 中存储的元素类型。</p><p><strong>从set中获取元素</strong></p><p>set 容器不提供下标操作符。为了通过键从 set 中获取元素，可使用 find 运算。如果只需简单地判断某个元素是否存在，同样可以使用 count 运算，返回 set 中该键对应的元素个数。当然，对于 set 容器，count 的返回值只能是 1（该元素存在）或 0（该元素不存在）。</p><p>set 中的键也为 const。在获得指向 set 中某元素的迭代器后，只能对其做读操作，而不能做写操作。</p><h2 id="10-5-multimap和multiset类型"><a href="#10-5-multimap和multiset类型" class="headerlink" title="10.5. multimap和multiset类型"></a>10.5. multimap和multiset类型</h2><p>multiset和multimap类型允许一个键对应多个实例。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。不能对 multimap 对象使用下标操作，因为在这类容器中，某个键可能对应多个值。</p><h3 id="10-5-1-元素的添加和删除"><a href="#10-5-1-元素的添加和删除" class="headerlink" title="10.5.1 元素的添加和删除"></a>10.5.1 元素的添加和删除</h3><p>由于键不要求是唯一的，因此每次调用 insert 总会添加一个元素。</p><p>带有一个键参数的 erase 版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回 void 类型。</p><h3 id="10-5-2-在multimap和multiset中查找元素"><a href="#10-5-2-在multimap和multiset中查找元素" class="headerlink" title="10.5.2 在multimap和multiset中查找元素"></a>10.5.2 在multimap和multiset中查找元素</h3><p>count 函数求出某键出现的次数，而 find 操作则返回一个迭代器，指向第一个拥有正在查找的键的实例。</p><p><strong>lower_bound 和 upper_bound</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.lower_bound(k)  返回一个迭代器，指向键不小于 k 的第一个元素 </span><br><span class="line">m.upper_bound(k)  返回一个迭代器，指向键大于 k 的第一个元素 </span><br><span class="line">m.equal_range(k)  返回一个迭代器的 pair 对象，它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十章-关联容器&quot;&gt;&lt;a href=&quot;#第十章-关联容器&quot; class=&quot;headerlink&quot; title=&quot;第十章 关联容器&quot;&gt;&lt;/a&gt;第十章 关联容器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;关联容器&lt;/strong&gt;和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
</feed>

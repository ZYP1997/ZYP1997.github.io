<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空之境界</title>
  
  <subtitle>ZYP&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zypsola.com/"/>
  <updated>2019-02-28T08:34:45.693Z</updated>
  <id>https://zypsola.com/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法 Lesson1</title>
    <link href="https://zypsola.com/2019/02/27/%E7%AE%97%E6%B3%95Lesson1/"/>
    <id>https://zypsola.com/2019/02/27/算法Lesson1/</id>
    <published>2019-02-27T07:28:42.000Z</published>
    <updated>2019-02-28T08:34:45.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><p>非形式的说，<strong>算法(algorithm)</strong>就是任何良定义的计算过程，该过程取某个值或值的集合作为<strong>输入</strong>并产生某个值或值的集合作为<strong>输出</strong>。这样算法就是把输入转换成输出的计算步骤的一个序列。</p><a id="more"></a><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>Θ(n²)</p><h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>我们往往集中于最坏情况运行时间。</p><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解，然后合并子问题的解来建立原问题的解。</p><p><strong>归并排序</strong>:分解待排序的n个元素的序列成各具n/2个元素的两个子序列;使用归并排序递归地排序两个子序列;合并两个已排序的子序列。</p><p>Θ(nlgn)</p><h1 id="第三章-函数的增长"><a href="#第三章-函数的增长" class="headerlink" title="第三章 函数的增长"></a>第三章 函数的增长</h1><h2 id="3-1-渐进记号"><a href="#3-1-渐进记号" class="headerlink" title="3.1 渐进记号"></a>3.1 渐进记号</h2><p>我们主要使用渐进记号来描述算法的运行时间。然而，渐进记号实际上应用于函数。</p><p><strong>Θ记号</strong></p><p>Θ(g(n))={f(n):存在正常量c1,c2,n0,使得对所有n&gt;=n0,有0&lt;=c1g(n)&lt;=f(n)&lt;=c2g(n)}</p><p><strong>O记号</strong></p><p>Θ记号渐进地给出一个函数的上界和下界。当只有一个渐进上界时，使用O记号。</p><p>O(g(n))={f(n):存在正常量c,n0,使得对所有n&gt;=n0,有0&lt;=f(n)&lt;=cg(n)}</p><p><strong>Ω记号</strong></p><p>Ω记号提供了渐进下界</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-算法基础&quot;&gt;&lt;a href=&quot;#第二章-算法基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 算法基础&quot;&gt;&lt;/a&gt;第二章 算法基础&lt;/h1&gt;&lt;p&gt;非形式的说，&lt;strong&gt;算法(algorithm)&lt;/strong&gt;就是任何良定义的计算过程，该过程取某个值或值的集合作为&lt;strong&gt;输入&lt;/strong&gt;并产生某个值或值的集合作为&lt;strong&gt;输出&lt;/strong&gt;。这样算法就是把输入转换成输出的计算步骤的一个序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://zypsola.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson22</title>
    <link href="https://zypsola.com/2019/02/27/C++Primer22/"/>
    <id>https://zypsola.com/2019/02/27/C++Primer22/</id>
    <published>2019-02-26T16:54:35.000Z</published>
    <updated>2019-02-26T16:56:27.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-模板和泛型编程"><a href="#第十六章-模板和泛型编程" class="headerlink" title="第十六章 模板和泛型编程"></a>第十六章 模板和泛型编程</h1><p>所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。第二部分中描述的标准库的容器、迭代器和算法都是泛型编程的例子。每种容器(如 vector)都有单一的定义，但可以定义许多不同种类的 vector，它们的区别在于所包含的元素类型。</p><a id="more"></a><h2 id="16-1-模板定义"><a href="#16-1-模板定义" class="headerlink" title="16.1 模板定义"></a>16.1 模板定义</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十六章-模板和泛型编程&quot;&gt;&lt;a href=&quot;#第十六章-模板和泛型编程&quot; class=&quot;headerlink&quot; title=&quot;第十六章 模板和泛型编程&quot;&gt;&lt;/a&gt;第十六章 模板和泛型编程&lt;/h1&gt;&lt;p&gt;所谓泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例所操作的类型或值。第二部分中描述的标准库的容器、迭代器和算法都是泛型编程的例子。每种容器(如 vector)都有单一的定义，但可以定义许多不同种类的 vector，它们的区别在于所包含的元素类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson21</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer21/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer21/</id>
    <published>2019-02-24T13:09:00.000Z</published>
    <updated>2019-02-26T16:52:12.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五章-面向对象编程"><a href="#第十五章-面向对象编程" class="headerlink" title="第十五章 面向对象编程"></a>第十五章 面向对象编程</h1><p>面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。</p><a id="more"></a><h2 id="15-1-面向对象编程：概述"><a href="#15-1-面向对象编程：概述" class="headerlink" title="15.1 面向对象编程：概述"></a>15.1 面向对象编程：概述</h2><p><strong>继承</strong>：派生类（derived class）能够继承基类（base class）定义的成员，派生类可以无须改变而使用那些与派生类型具体特性不相关的操作，派生类可以重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。</p><p><strong>动态绑定</strong>：我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类的程序无须区分函数是在基类还是在派生类中定义的。</p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><p>保留字 virtual 的目的是启用动态绑定。成员默认为非虚函数，对非虚函数的调用在编译时确定。为了指明函数为虚函数，在其返回类型前面加上保留字 virtual。除了构造函数之外，任意非 static 成员函数都可以是虚函数。保留字只在类内部的成员函数声明中出现，不能用在类定义体外部出现的函数定义上。</p><p>基类通常应将派生类需要重定义的任意函数定义为虚函数。</p><h3 id="15-2-2-protected成员"><a href="#15-2-2-protected成员" class="headerlink" title="15.2.2 protected成员"></a>15.2.2 protected成员</h3><p>派生类对基类的 public 和 private 成员的访问权限与程序中任意其他部分一样：它可以访问 public 成员而不能访问 private 成员。protected 成员可以被派生类对象访问但不能被该类型的普通用户访问。</p><h3 id="15-2-3-派生类"><a href="#15-2-3-派生类" class="headerlink" title="15.2.3 派生类"></a>15.2.3 派生类</h3><p>为了定义派生类，使用类派生列表指定基类。类派生列表指定了一个或多个基类。</p><p>派生类一般会重定义所继承的虚函数。派生类没有重定义某个虚函数，则使用基类中定义的版本。</p><p>派生类型必须对想要重定义的每个继承成员进行声明。</p><p>派生类中虚函数的声明必须与基类中的定义方式完全匹配，但有一个例外：返回对基类型的引用（或指针）的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用（或指针）。 </p><p>派生类重定义虚函数时，可以使用 virtual 保留字，但不是必须这样做。</p><p>已定义的类才可以用作基类。</p><h3 id="15-2-4-virtual与其他成员函数"><a href="#15-2-4-virtual与其他成员函数" class="headerlink" title="15.2.4 virtual与其他成员函数"></a>15.2.4 virtual与其他成员函数</h3><p>C++ 中的函数调用默认不使用动态绑定。要触发动态绑定，满足两个条件：第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；第二，必须通过基类类型的引用或指针进行函数调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">virtual void a() &#123;</span><br><span class="line">cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int b;</span><br><span class="line">protected:</span><br><span class="line">void c() &#123;</span><br><span class="line">cout &lt;&lt; &quot;c&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">void a() &#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, *p;</span><br><span class="line">B b;</span><br><span class="line">p = &amp;a;</span><br><span class="line">p-&gt;a();       //a</span><br><span class="line">p = &amp;b;</span><br><span class="line">p-&gt;a();       //c</span><br><span class="line">p-&gt;A::a();    //a</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-2-5-公用、私有和受保护的继承"><a href="#15-2-5-公用、私有和受保护的继承" class="headerlink" title="15.2.5 公用、私有和受保护的继承"></a>15.2.5 公用、私有和受保护的继承</h3><p><strong>公用继承:</strong>基类成员保持自己的访问级别。</p><p><strong>受保护继承:</strong>基类的public和protected成员在派生类中为protected成员。 </p><p><strong>私有继承:</strong>基类的的所有成员在派生类中为private成员。</p><p><strong>接口继承与实现继承</strong></p><p>public 派生类继承基类的接口，它具有与基类相同的接口。设计良好的类层次中，public 派生类的对象可以用在任何需要基类对象的地方。</p><p>使用 private 或 protected 派生的类不继承基类的接口，相反，这些派生通常被称为实现继承。</p><p>派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C :private A&#123;</span><br><span class="line">public:</span><br><span class="line">using A::a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 class 保留字定义的派生默认具有 private 继承，而用 struct 保留字定义的类默认具有 public 继承。</p><h3 id="15-2-6-友元关系与继承"><a href="#15-2-6-友元关系与继承" class="headerlink" title="15.2.6 友元关系与继承"></a>15.2.6 友元关系与继承</h3><p>友元关系不能继承。</p><h3 id="15-2-7-继承与静态成员"><a href="#15-2-7-继承与静态成员" class="headerlink" title="15.2.7 继承与静态成员"></a>15.2.7 继承与静态成员</h3><p>如果基类定义 static 成员，则<strong>整个继承层次中只有一个这样的成员</strong>。无论从基类派生出多少个派生类，每个 static 成员只有一个实例。</p><h2 id="15-3-转换与继承"><a href="#15-3-转换与继承" class="headerlink" title="15.3 转换与继承"></a>15.3 转换与继承</h2><p>每个派生类对象包含一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行操作。因为派生类对象也是基类对象，所以存在从派生类型引用到基类类型引用的自动转换，即，可以将派生类对象的引用转换为基类子对象的引用，对指针也类似。 </p><p>基类类型对象既可以作为独立对象存在，也可以作为派生类对象的一部分而存在，因此，一个基类对象可能是也可能不是一个派生类对象的部分，结果，没有从基类引用（或基类指针）到派生类引用（或派生类指针）的（自动）转换。</p><p>相对于引用或指针而言，对象转换的情况更为复杂。虽然一般可以使用派生类型的对象对基类类型的对象进行初始化或赋值，但，没有从派生类型对象到基类类型对象的直接转换。</p><h2 id="15-4-构造函数与复制控制"><a href="#15-4-构造函数与复制控制" class="headerlink" title="15.4 构造函数与复制控制"></a>15.4 构造函数与复制控制</h2><p>构造函数和复制控制成员不能继承，每个类定义自己的构造函数和复制控制成员。</p><h3 id="15-4-2-派生类构造函数"><a href="#15-4-2-派生类构造函数" class="headerlink" title="15.4.2 派生类构造函数"></a>15.4.2 派生类构造函数</h3><p>派生类的合成默认构造函数与非派生的构造函数只有一点不同：除了初始化派生类的数据成员之外，它还初始化派生类对象的基类部分。基类部分由基类的默认构造函数初始化。</p><p>派生类构造函数的初始化列表只能初始化派生类的成员，不能直接初始化继承成员。相反派生类构造函数通过将基类包含在构造函数初始化列表中来间接初始化继承成员。</p><p>构造函数初始化列表为类的基类和成员提供初始值，它并不指定初始化的执行次序。首先初始化基类，然后根据声明次序初始化派生类的成员。</p><h3 id="15-4-3-复制控制和继承"><a href="#15-4-3-复制控制和继承" class="headerlink" title="15.4.3 复制控制和继承"></a>15.4.3 复制控制和继承</h3><p>如果派生类定义了自己的复制构造函数，该复制构造函数一般应显式使用基类复制构造函数初始化对象的基类部分。</p><p>赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显式赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">A() :i(5) &#123;&#125;;</span><br><span class="line">A(const A&amp; a) &#123;</span><br><span class="line">i = 2 * a.i;</span><br><span class="line">&#125;</span><br><span class="line">int i;</span><br><span class="line">virtual void out() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A&amp; operator=(const A&amp; r) &#123;</span><br><span class="line">i = 3 * r.i;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">B() :j(3) &#123;&#125;;</span><br><span class="line">B(const B&amp; b) :A(b) &#123;</span><br><span class="line">j = 2 * b.j;</span><br><span class="line">&#125;</span><br><span class="line">int j;</span><br><span class="line">void out() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B&amp; operator=(const B&amp; r) &#123;</span><br><span class="line">A::operator=(r);</span><br><span class="line">j = 3 * r.j;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, b(a);</span><br><span class="line">a.out();      //5</span><br><span class="line">b.out();      //10</span><br><span class="line">a = b;</span><br><span class="line">a.out();      //30</span><br><span class="line">B c, d(c);</span><br><span class="line">c.out();      //5 3</span><br><span class="line">d.out();      //10 6</span><br><span class="line">c = d;</span><br><span class="line">c.out();      //30 18</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数的工作与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员。编译器总是显式调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员。对象的撤销顺序与构造顺序相反：首先运行派生析构函数，然后按继承层次依次向上调用各基类析构函数。</p><h3 id="15-4-4-虚析构函数"><a href="#15-4-4-虚析构函数" class="headerlink" title="15.4.4 虚析构函数"></a>15.4.4 虚析构函数</h3><p>如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~A() &#123;</span><br><span class="line">cout &lt;&lt; &quot;a&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A &#123;</span><br><span class="line">public:</span><br><span class="line">~B() &#123;</span><br><span class="line">cout &lt;&lt; &quot;b&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A *p = new A;</span><br><span class="line">delete p;      //a</span><br><span class="line">p = new B;</span><br><span class="line">delete p;      //b</span><br><span class="line">                   //a</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p><h2 id="15-5-继承情况下的类作用域"><a href="#15-5-继承情况下的类作用域" class="headerlink" title="15.5 继承情况下的类作用域"></a>15.5 继承情况下的类作用域</h2><p>每个类都保持着自己的作用域，在该作用域中定义了成员的名字。在继承情况下，派生类的作用域嵌套在基类作用域中。如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。</p><p>与基类成员同名的派生类成员将屏蔽对基类成员的直接访问。可以使用作用域操作符访问被屏蔽的基类成员。</p><p>在基类和派生类中使用同一名字的成员函数，其行为与数据成员一样：在派生类作用域中派生类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽。</p><h2 id="15-6-纯虚函数"><a href="#15-6-纯虚函数" class="headerlink" title="15.6 纯虚函数"></a>15.6 纯虚函数</h2><p>含有（或继承）一个或多个纯虚函数的类是<strong>抽象类类型</strong>。不能创建抽象类型的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void out() = 0;</span><br></pre></td></tr></table></figure><h2 id="15-7-容器与继承"><a href="#15-7-容器与继承" class="headerlink" title="15.7 容器与继承"></a>15.7 容器与继承</h2><p>如果定义容器保存基类类型的对象，则加入派生类型的对象时，只将对象的基类部分保存在容器中。</p><h2 id="15-8-句柄类与继承"><a href="#15-8-句柄类与继承" class="headerlink" title="15.8 句柄类与继承"></a>15.8 句柄类与继承</h2><p>C++ 中一个通用的技术是定义包装（cover）类或句柄类。句柄类存储和管理基类指针。指针所指对象的类型可以变化，它既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。因为句柄类使用指针执行操作，虚成员的行为将在运行时根据句柄实际绑定的对象的类型而变化。因此，句柄的用户可以获得动态行为但无须操心指针的管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十五章-面向对象编程&quot;&gt;&lt;a href=&quot;#第十五章-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;第十五章 面向对象编程&quot;&gt;&lt;/a&gt;第十五章 面向对象编程&lt;/h1&gt;&lt;p&gt;面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。在C++中，用类进行数据抽象，用类派生从一个类继承另一个：派生类继承基类的成员。动态绑定使编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson20</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer20/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer20/</id>
    <published>2019-02-24T08:09:00.000Z</published>
    <updated>2019-02-24T13:08:47.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-重载操作符与转换"><a href="#第十四章-重载操作符与转换" class="headerlink" title="第十四章 重载操作符与转换"></a>第十四章 重载操作符与转换</h1><p>C++ 允许我们重定义操作符用于类类型对象时的含义。如果需要，可以像内置转换那样使用类类型转换，将一个类型的对象隐式转换到另一类型。</p><a id="more"></a><h2 id="14-1-重载操作符的定义"><a href="#14-1-重载操作符的定义" class="headerlink" title="14.1 重载操作符的定义"></a>14.1 重载操作符的定义</h2><p>重载操作符是具有特殊名称的函数：保留字 operator 后接需定义的操作符号。像任意其他函数一样，重载操作符具有返回类型和形参表。</p><p>用于内置类型的操作符，其含义不能改变。重载操作符必须具有至少一个类类型或枚举类型的操作数。这条规则强制重载操作符不能重新定义用于内置类型对象的操作符的含义。</p><p>操作符的优先级、结合性或操作数目不能改变。不管操作数的类型和操作符的功能定义如何。</p><p>大多数重载操作符可以定义为普通非成员函数或类的成员函数。作为类成员的重载函数，其形参看起来比操作数数目少 1。作为成员函数的操作符有一个隐含的 this 形参，限定为第一个操作数。 </p><p>操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元。</p><h2 id="14-2-输入和输出操作符"><a href="#14-2-输入和输出操作符" class="headerlink" title="14.2 输入和输出操作符"></a>14.2 输入和输出操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">void outstr() &#123;cout &lt;&lt; str1 &lt;&lt; endl;&#125;</span><br><span class="line">friend istream&amp; operator&gt;&gt;(istream&amp;, Myclass&amp;);</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Myclass&amp;);</span><br><span class="line">friend Myclass&amp; operator+(const Myclass&amp;, const Myclass&amp;);</span><br><span class="line">Myclass&amp; operator+=(Myclass&amp;);</span><br><span class="line">private:</span><br><span class="line">string str1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline istream&amp; operator&gt;&gt;(istream&amp; in, Myclass&amp; m) &#123;</span><br><span class="line">in &gt;&gt; m.str1;</span><br><span class="line">return in;</span><br><span class="line">&#125;</span><br><span class="line">inline ostream&amp; operator&lt;&lt;(ostream&amp; out, const Myclass&amp; m) &#123;</span><br><span class="line">out &lt;&lt; m.str1;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-3-算术操作符和关系操作符"><a href="#14-3-算术操作符和关系操作符" class="headerlink" title="14.3 算术操作符和关系操作符"></a>14.3 算术操作符和关系操作符</h2><p>一般而言，将算术和关系操作符定义为非成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline Myclass&amp; Myclass::operator+=(Myclass&amp; r) &#123;</span><br><span class="line">this-&gt;str1 = this-&gt;str1 + r.str1;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline Myclass&amp; operator+(const Myclass&amp; l, const Myclass&amp; r) &#123;</span><br><span class="line">Myclass tem;</span><br><span class="line">tem.str1 = l.str1 + r.str1;</span><br><span class="line">return tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-5-下标操作符"><a href="#14-5-下标操作符" class="headerlink" title="14.5 下标操作符"></a>14.5 下标操作符</h2><p>下标操作符必须定义为类成员函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">Myclass() &#123; num = &#123; 1,2,3,4 &#125;; &#125;;</span><br><span class="line">int&amp; operator[](int);</span><br><span class="line">private:</span><br><span class="line">vector&lt;int&gt; num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int&amp; Myclass::operator[](int i) &#123;</span><br><span class="line">return num[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-8-调用操作符和函数对象"><a href="#14-8-调用操作符和函数对象" class="headerlink" title="14.8 调用操作符和函数对象"></a>14.8 调用操作符和函数对象</h2><p>函数调用操作符必须声明为成员函数。定义了调用操作符的类，其对象常称为函数对象，即它们是行为类似函数的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">int operator() (int val)&#123;</span><br><span class="line">return val*val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a;</span><br><span class="line">cout &lt;&lt; a(5);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十四章-重载操作符与转换&quot;&gt;&lt;a href=&quot;#第十四章-重载操作符与转换&quot; class=&quot;headerlink&quot; title=&quot;第十四章 重载操作符与转换&quot;&gt;&lt;/a&gt;第十四章 重载操作符与转换&lt;/h1&gt;&lt;p&gt;C++ 允许我们重定义操作符用于类类型对象时的含义。如果需要，可以像内置转换那样使用类类型转换，将一个类型的对象隐式转换到另一类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson19</title>
    <link href="https://zypsola.com/2019/02/24/C++Primer19/"/>
    <id>https://zypsola.com/2019/02/24/C++Primer19/</id>
    <published>2019-02-24T06:19:00.000Z</published>
    <updated>2019-02-26T14:56:18.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章-复制控制"><a href="#第十三章-复制控制" class="headerlink" title="第十三章 复制控制"></a>第十三章 复制控制</h1><p>当定义一个新类型的时候，需要显式或隐式地指定复制、赋值和撤销该类型的对象时会发生什么——这是通过定义特殊成员：复制构造函数、赋值操作符和析构函数来达到的。如果没有显式定义复制构造函数或赋值操作符，编译器（通常）会为我们定义。</p><a id="more"></a><p><strong>复制构造函数</strong>是一种特殊构造函数，具有单个形参，该形参（常用 const 修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显式使用复制构造函数。当将该类型的对象传递给函数或函数返回该类型的对象时，将隐式使用复制构造函数。</p><p><strong>析构函数</strong>是构造函数的互补：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非 static 数据成员的析构函数。</p><p>复制构造函数、赋值操作符和析构函数总称为<strong>复制控制</strong>。</p><h2 id="13-1-复制构造函数"><a href="#13-1-复制构造函数" class="headerlink" title="13.1 复制构造函数"></a>13.1 复制构造函数</h2><p>只有单个形参，而且该形参是对本类类型对象的引用（常用 const 修饰），这样的构造函数称为复制构造函数。与默认构造函数一样，复制构造函数可由编译器隐式调用。复制构造函数可用于：</p><ol><li>根据另一个同类型的对象显式或隐式初始化一个对象。</li><li>复制一个对象，将它作为实参传给一个函数。</li><li>从函数返回时复制一个对象。</li><li>初始化顺序容器中的元素。</li><li>根据元素初始化式列表初始化数组元素。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">A() :i(5) &#123;&#125;;</span><br><span class="line">A(const A&amp;);</span><br><span class="line">int i;</span><br><span class="line">void outA() &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A(const A&amp; a) &#123;</span><br><span class="line">i = 2 * a.i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a, b(a);</span><br><span class="line">a.outA();</span><br><span class="line">b.outA();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-1-1-合成的复制构造函数"><a href="#13-1-1-合成的复制构造函数" class="headerlink" title="13.1.1 合成的复制构造函数"></a>13.1.1 合成的复制构造函数</h3><p>如果我们没有定义复制构造函数，编译器就会为我们合成一个。与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数。合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本。</p><h3 id="13-1-3-禁止复制"><a href="#13-1-3-禁止复制" class="headerlink" title="13.1.3 禁止复制"></a>13.1.3 禁止复制</h3><p>有些类需要完全禁止复制。例如，iostream 类就不允许复制。为了防止复制，类必须显式声明其复制构造函数为 private。然而，类的友元和成员仍可以进行复制。如果想要连友元和成员中的复制也禁止，就可以声明一个（private）复制构造函数但不对其定义。</p><h2 id="13-2-赋值操作符"><a href="#13-2-赋值操作符" class="headerlink" title="13.2 赋值操作符"></a>13.2 赋值操作符</h2><p>与复制构造函数一样，如果类没有定义自己的赋值操作符，则编译器会合成一个。</p><p>大多数操作符可以定义为成员函数或非成员函数。当操作符为成员函数时，它的第一个操作数隐式绑定到 this 指针。有些操作符（包括赋值操作符）必须是定义自己的类的成员。因为赋值必须是类的成员，所以 this 绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为 const 引用传递。 </p><p>合成赋值操作符与合成复制构造函数的操作类似。它会执行逐个成员赋值：右操作数对象的每个成员赋值给左操作数对象的对应成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Myclass &#123;</span><br><span class="line">public:</span><br><span class="line">Myclass(string);</span><br><span class="line">Myclass(Myclass&amp;);</span><br><span class="line">void outstr() &#123;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Myclass&amp; operator=(const Myclass&amp;);</span><br><span class="line">private:</span><br><span class="line">string str1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Myclass&amp; Myclass::operator=(const Myclass&amp; myc1) &#123;</span><br><span class="line">str1 = myc1.str1 + myc1.str1 + myc1.str1;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Myclass::Myclass(string str):str1(str) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Myclass::Myclass(Myclass&amp; myc1) &#123;</span><br><span class="line">str1 = myc1.str1 + myc1.str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Myclass a(&quot;123&quot;);</span><br><span class="line">a.outstr();           //123</span><br><span class="line">Myclass&amp; c = a;</span><br><span class="line">Myclass b(c);</span><br><span class="line">b.outstr();           //123123</span><br><span class="line">b = a;</span><br><span class="line">b.outstr();           //123123123</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-3-析构函数"><a href="#13-3-析构函数" class="headerlink" title="13.3 析构函数"></a>13.3 析构函数</h2><p>析构函数通常用于释放在构造函数或在对象生命期内获取的资源。</p><p>与复制构造函数或赋值操作符不同，编译器总是会为我们合成一个析构函数。<strong>合成析构函数</strong>按对象创建时的逆序撤销每个非 static 成员，因此，它按成员在类中声明次序的逆序撤销成员。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。 </p><p>析构函数与复制构造函数或赋值操作符之间的一个重要区别是，即使我们编写了自己的析构函数，合成析构函数仍然运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十三章-复制控制&quot;&gt;&lt;a href=&quot;#第十三章-复制控制&quot; class=&quot;headerlink&quot; title=&quot;第十三章 复制控制&quot;&gt;&lt;/a&gt;第十三章 复制控制&lt;/h1&gt;&lt;p&gt;当定义一个新类型的时候，需要显式或隐式地指定复制、赋值和撤销该类型的对象时会发生什么——这是通过定义特殊成员：复制构造函数、赋值操作符和析构函数来达到的。如果没有显式定义复制构造函数或赋值操作符，编译器（通常）会为我们定义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson18</title>
    <link href="https://zypsola.com/2018/11/10/C++Primer18/"/>
    <id>https://zypsola.com/2018/11/10/C++Primer18/</id>
    <published>2018-11-09T16:03:18.000Z</published>
    <updated>2019-02-23T16:04:02.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-类"><a href="#第十二章-类" class="headerlink" title="第十二章 类"></a>第十二章 类</h1><p>在 C++ 中，用类来定义自己的抽象数据类型（abstract data types）。通过定义类型来对应所要解决的问题中的各种概念，可以使我们更容易编写、调试和修改程序。</p><a id="more"></a><p>类类型常被称为抽象数据类型。抽象数据类型将数据（即状态）和作用于状态的操作视为一个单元。我们可以抽象地考虑类该做什么，而无须知道类如何去完成这些操作。抽象数据类型是面向对象编程和泛型编程的基础。 </p><h2 id="12-1-类的定义和声明"><a href="#12-1-类的定义和声明" class="headerlink" title="12.1 类的定义和声明"></a>12.1 类的定义和声明</h2><h3 id="12-1-1-类定义"><a href="#12-1-1-类定义" class="headerlink" title="12.1.1 类定义"></a>12.1.1 类定义</h3><p>最简单地说，类就是定义了一个新的类型和一个新作用域。</p><p><strong>类成员</strong>:每个类可以没有成员，也可以定义多个成员，成员可以是数据、函数或类型别名。 所有成员必须在类的内部声明，一旦类定义完成后，就没有任何方式可以增加成员了。 </p><p><strong>构造函数</strong>:构造函数是一个特殊的、与类同名的成员函数，用于给每个数据成员设置适当的初始值。 构造函数一般就使用一个构造函数初始化列表，来初始化对象的数据成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong>:在类内部定义的函数默认为inline。 成员函数有一个附加的隐含实参，将函数绑定到调用函数的对象；将关键字 const 加在形参表之后，就可以将成员函数声明为常量。const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声明和定义中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double avg_price() const;</span><br></pre></td></tr></table></figure><h3 id="12-1-2-数据抽象和封装"><a href="#12-1-2-数据抽象和封装" class="headerlink" title="12.1.2 数据抽象和封装"></a>12.1.2 数据抽象和封装</h3><p>类背后蕴涵的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。 </p><p>在C++中，使用访问标号来定义类的抽象接口和实施封装。类型的数据抽象视图由其 public 成员定义。 private 封装了类型的实现细节。 </p><h2 id="12-2-隐含的-this指针"><a href="#12-2-隐含的-this指针" class="headerlink" title="12.2 隐含的 this指针"></a>12.2 隐含的 this指针</h2><p>成员函数具有一个附加的隐含形参，即指向该类对象的一个指针。这个隐含形参命名为 this，与调用成员函数的对象绑定在一起。成员函数不能定义 this 形参，而是由编译器隐含地定义。如果对类成员的引用没有限定，编译器会将这种引用处理成通过 this 指针的引用。 </p><p>尽管在成员函数内部显式引用 this 通常是不必要的，但有一种情况下必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最<br>常见的情况是在这样的函数中使用 this：该函数返回对调用该函数的对象的引用。 </p><p>在普通的非 const 成员函数中，this 的类型是一个指向类类型的 const 指针。可以改变 this 所指向的值，但不能改变 this 所保存的地址。在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。</p><p><strong>可变数据成员</strong></p><p>有时，我们希望类的数据成员（甚至在 const 成员函数内）可以修改。这可以通过将它们声明为 mutable 来实现。 </p><p>可变数据成员永远都不能为 const，甚至当它是 const 对象的成员时也如此。因此，const 成员函数可以改变 mutable 成员。</p><h2 id="12-3-类作用域"><a href="#12-3-类作用域" class="headerlink" title="12.3 类作用域"></a>12.3 类作用域</h2><p>如果返回类型使用由类定义的类型，则必须使用完全限定名： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123; </span><br><span class="line">   public: </span><br><span class="line">       typedef std::string::size_type index; </span><br><span class="line">       index get_cursor() const; </span><br><span class="line">   &#125;; </span><br><span class="line">   inline Screen::index Screen::get_cursor() const </span><br><span class="line">   &#123; </span><br><span class="line">       return cursor; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="12-4-构造函数"><a href="#12-4-构造函数" class="headerlink" title="12.4 构造函数"></a>12.4 构造函数</h2><p>构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值。</p><p><strong>构造函数可以被重载</strong></p><p><strong>构造函数自动执行</strong></p><p><strong>构造函数不能声明为const</strong></p><h3 id="12-4-1-构造函数初始化式"><a href="#12-4-1-构造函数初始化式" class="headerlink" title="12.4.1 构造函数初始化式"></a>12.4.1 构造函数初始化式</h3><p>构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。构造函数初始化只在构造函数的定义中而不是声明中指定。 </p><p>从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。 不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。 </p><p>有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。 </p><p><strong>成员初始化的次序</strong></p><p>构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。</p><p>初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数。可以使用该类型的任意构造函数。</p><h3 id="12-4-2-默认实参与构造函数"><a href="#12-4-2-默认实参与构造函数" class="headerlink" title="12.4.2 默认实参与构造函数"></a>12.4.2 默认实参与构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book = &quot;&quot;):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="12-4-3-默认构造函数"><a href="#12-4-3-默认构造函数" class="headerlink" title="12.4.3 默认构造函数"></a>12.4.3 默认构造函数</h3><p>只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。 </p><h3 id="12-4-4-隐式类类型转换"><a href="#12-4-4-隐式类类型转换" class="headerlink" title="12.4.4 隐式类类型转换"></a>12.4.4 隐式类类型转换</h3><p>可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.same_isbn(cin);</span><br></pre></td></tr></table></figure><p><strong>抑制由构造函数定义的隐式转换</strong>：可以通过将构造函数声明为 explicit，来防止在需要隐式转换的上下文中使用构造函数。explicit 关键字只能用于类内部的构造函数声明上。在类的定义体外部所做的定义上不再重复它。</p><p><strong>为转换而显式地使用构造函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string null_book = &quot;9-999-99999-9&quot;; </span><br><span class="line">item.same_isbn(Sales_item(null_book))</span><br></pre></td></tr></table></figure><h3 id="12-4-5-类成员的显式初始化"><a href="#12-4-5-类成员的显式初始化" class="headerlink" title="12.4.5 类成员的显式初始化"></a>12.4.5 类成员的显式初始化</h3><p>对于没有定义构造函数并且其全体数据成员均为 public 的类，可以采用与初始化数组元素相同的方式初始化其成员。根据数据成员的声明次序来使用初始化式。</p><h2 id="12-5-友元"><a href="#12-5-友元" class="headerlink" title="12.5 友元"></a>12.5 友元</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字 friend 开始。它只能出现在类定义的内部。友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class A1;</span><br><span class="line">class A2;</span><br><span class="line"></span><br><span class="line">class A1 &#123;</span><br><span class="line">public:</span><br><span class="line">A1() :a(1) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">friend int addA12(A1 a1, A2 a2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A2 &#123;</span><br><span class="line">public:</span><br><span class="line">A2() :a(2) &#123;&#125;;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">friend int addA12(A1 a1, A2 a2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int addA12(A1 a1, A2 a2) &#123;</span><br><span class="line">return a1.a + a2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A1 aa;</span><br><span class="line">A2 ab;</span><br><span class="line">cout &lt;&lt; addA12(aa, ab) &lt;&lt; endl;       //3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-static类成员"><a href="#12-6-static类成员" class="headerlink" title="12.6 static类成员"></a>12.6 static类成员</h2><p>通常，非 static 数据成员存在于类类型的每个对象中。static 数据成员独立于该类的任意对象而存在；每个 static 数据成员是与类关联的对象，并不与该类的对象相关联。</p><p>static 成员函数没有 this 形参，它可以直接访问所属类的 static 成员，但不能直接使用非 static 成员。</p><p>当我们在类的外部定义 static 成员时，无须重复指定 static 保留字，该保留字只出现在类定义体内部的声明处。</p><p>static 数据成员必须在类定义体的外部定义（正好一次）。不像普通数据成员，static 成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><p><strong>抽象数据类型：</strong>使用封装来隐藏其实现的数据结构，允许使用类型的程序员抽象地考虑该类型做什么，而不是具体地考虑类型如何表示。</p></li><li><p><strong>封装：</strong>实现与接口的分离。封闭隐藏了类型的实现细节。在 C++ 中，实施封装可以阻止普通用户访问类的 private 部分。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十二章-类&quot;&gt;&lt;a href=&quot;#第十二章-类&quot; class=&quot;headerlink&quot; title=&quot;第十二章 类&quot;&gt;&lt;/a&gt;第十二章 类&lt;/h1&gt;&lt;p&gt;在 C++ 中，用类来定义自己的抽象数据类型（abstract data types）。通过定义类型来对应所要解决的问题中的各种概念，可以使我们更容易编写、调试和修改程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson17</title>
    <link href="https://zypsola.com/2018/11/07/C++Primer17/"/>
    <id>https://zypsola.com/2018/11/07/C++Primer17/</id>
    <published>2018-11-07T09:21:36.000Z</published>
    <updated>2018-11-09T16:02:51.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章-泛型算法"><a href="#第十一章-泛型算法" class="headerlink" title="第十一章 泛型算法"></a>第十一章 泛型算法</h1><p>标准库并没有为每种容器类型都定义实现这些操作的成员函数，而是定义了一组<strong>泛型算法</strong>：因为它们实现共同的操作，所以称之为“算法”；而“泛型”指的是它们可以操作在多种容器类型上——不但可作用于vector或list这些标准库类型，还可用在内置数组类型、甚至其他类型的序列上。自定义的容器类型只要与标准库兼容，同样可以使用这些泛型算法。 </p><a id="more"></a><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>泛型算法本身从不执行容器操作，只是单独依赖迭代器和迭代器操作实现。</p><p>大多数情况下，每个算法都需要使用（至少）两个迭代器指出该算法操纵的元素范围。第一个迭代器指向第一个元素，而第二个迭代器则指向最后一个元素的下一位置。第二个迭代器所指向的元素［有时被称为超出末端迭代器］本身不是要操作的元素，而被用作终止遍历的哨兵。 </p><h2 id="11-2-初窥算法"><a href="#11-2-初窥算法" class="headerlink" title="11.2 初窥算法"></a>11.2 初窥算法</h2><p>使用泛型算法必须包含 algorithm 头文件，标准库还定义了一组泛化的算术算法，其命名习惯与泛型算法相同。使用这些算法则必须包含 numeric 头文件。</p><p>除了少数例外情况，所有算法都在一段范围内的元素上操作。带有输入范围参数的算法总是使用头两个形参标记该范围。这两个形参是分别指向要处理的第一个元素和最后一个元素的下一位置的迭代器。 </p><p>理解算法的最基本方法是了解该算法是否读元素、写元素或者对元素进行重新排序。</p><h3 id="11-2-1-只读算法"><a href="#11-2-1-只读算法" class="headerlink" title="11.2.1 只读算法"></a>11.2.1 只读算法</h3><p>许多算法只会读取其输入范围内的元素，而不会写这些元素。find 就是一个这样的算法。另一个简单的只读算法是 accumulate，该算法在 numeric 头文件中定义。</p><p>accumulate 带有三个形参。头两个形参指定要累加的元素范围。第三个形参则是累加的初值。用于指定累加起始值的第三个实参是必要的，因为 accumulate 对将要累加的元素类型一无所知，因此，除此之外，没有别的办法创建合适的起始值或者关联的类型。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10, 5);</span><br><span class="line">cout &lt;&lt; static_cast&lt;int&gt;(accumulate(ivec.begin(), ivec.end(), 0)) &lt;&lt; endl;      //50</span><br><span class="line">vector&lt;string&gt; cvec(3, &quot;ab&quot;);</span><br><span class="line">string str = accumulate(cvec.begin(), cvec.end(), static_cast&lt;string&gt;(&quot;ccc&quot;));</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;          //cccababab</span><br></pre></td></tr></table></figure><h3 id="11-2-2-写容器元素的算法"><a href="#11-2-2-写容器元素的算法" class="headerlink" title="11.2.2 写容器元素的算法"></a>11.2.2 写容器元素的算法</h3><p>写入到输入序列的算法本质上是安全的——只会写入与指定输入范围数量相同的元素。 </p><p>fill 带有一对迭代器形参，用于指定要写入的范围，而所写的值是它的第三个形参的副本。fill_n 函数带有的参数包括：一个迭代器、一个计数器以及一个值。该函数从迭代器指向的元素开始，将指定数量的元素设置为给定的值。对指定数目的元素做写入运算，或者写到目标迭代器的算法，都不检查目标的大小是否足以存储要写入的元素。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(10, 5);</span><br><span class="line">fill(ivec.begin(), ivec.end(), 6);</span><br><span class="line">fill_n(ivec.begin(), 5, 10);</span><br><span class="line">cout &lt;&lt; static_cast&lt;int&gt;(accumulate(ivec.begin(), ivec.end(), 0)) &lt;&lt; endl;      //80</span><br></pre></td></tr></table></figure><p><strong>引入back_inserter</strong></p><p>确保算法有足够的元素存储输出数据的一种方法是使用<strong>插入迭代器</strong>。插入迭代器是可以给基础容器添加元素的迭代器。通常，用迭代器给容器元素赋值时，被赋值的是迭代器所指向的元素。而使用插入迭代器赋值时，则会在容器中添加一个新元素，其值等于赋值运算的右操作数的值。使用back_inserter必须包含 iterator 头文件</p><p>back_inserter函数是迭代器适配器。与容器适配器一样，迭代器适配器使用一个对象作为实参，并生成一个适应其实参行为的新对象。</p><p>传递给 back_inserter 的实参是一个容器的引用。back_inserter 生成一个绑定在该容器上的插入迭代器。在试图通过这个迭代器给元素赋值时，赋值运算将调用 push_back 在容器中添加一个具有指定值的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec(5, 4);</span><br><span class="line">fill_n(back_inserter(ivec), 5, 1);       //4 4 4 4 4 1 1 1 1 1</span><br></pre></td></tr></table></figure><p>copy 带有三个迭代器参数：头两个指定输入范围，第三个则指向目标序列的一个元素。传递给 copy 的目标序列必须至少要与输入范围一样大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; ilst(2, 5);</span><br><span class="line">vector&lt;int&gt; ivec(3, 7);</span><br><span class="line">copy(ilst.begin(), ilst.end(), ivec.begin());      //5 5 7</span><br><span class="line">copy(ilst.begin(), ilst.end(), back_inserter(ivec));   //5 5 7 5 5</span><br></pre></td></tr></table></figure><p>replace算法对输入序列做读写操作，将序列中特定的值替换为新的值。该算法带有四个形参：一对指定输入范围的迭代器和两个值。每一个等于第一值的元素替换成第二个值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(ivec.begin(), ivec.end(), 5, 9);</span><br></pre></td></tr></table></figure><h3 id="11-2-3-对容器元素重新排序的算法"><a href="#11-2-3-对容器元素重新排序的算法" class="headerlink" title="11.2.3 对容器元素重新排序的算法"></a>11.2.3 对容器元素重新排序的算法</h3><p>unique 算法带有两个指定元素范围的迭代器参数。该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器，表示无重复的值范围的结束。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a[8] = &#123; 1,3,5,5,3,3,5,1 &#125;;</span><br><span class="line">vector&lt;int&gt; ivec(a, a + 8);</span><br><span class="line">vector&lt;int&gt;::iterator end_uni = unique(ivec.begin(), ivec.end());   //ivec:1,3,5,3,5,1,5,1</span><br><span class="line">vector&lt;int&gt;::iterator iter = ivec.begin();</span><br><span class="line">while (iter != end_uni) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;         //135351</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique 实际上并没有删除任何元素，而是将无重复的元素复制到序列的前端，从而覆盖相邻的重复元素。unique 返回的迭代器指向超出无重复的元素范围末端的下一位置。 </p><p><strong>stable_sort 和 count_if</strong>。使用这些算法，还需要一个配套的实用函数，称为<strong>谓词</strong>。谓词是做某些检测的函数，返回用于条件判断的类型，指出条件是否成立。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool smaller(const int &amp;v1,const int &amp;v2) &#123;</span><br><span class="line">return v1 &lt; v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool more5(const int &amp;v) &#123;</span><br><span class="line">return v &gt; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[8] = &#123; 1,3,6,5,4,8,5,9 &#125;;</span><br><span class="line">vector&lt;int&gt; ivec(a, a + 8);</span><br><span class="line">cout &lt;&lt; count_if(ivec.begin(), ivec.end(), more5) &lt;&lt; endl;   //3</span><br><span class="line">sort(ivec.begin(), ivec.end(), smaller);</span><br><span class="line">vector&lt;int&gt;::iterator iter = ivec.begin();</span><br><span class="line">while (iter != ivec.end()) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;       //13455689</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-再谈迭代器"><a href="#11-3-再谈迭代器" class="headerlink" title="11.3 再谈迭代器"></a>11.3 再谈迭代器</h2><p>标准库所定义的迭代器不依赖于特定的容器。事实上，C++语言还提供了另外三种迭代器： </p><ol><li><p>插入迭代器：这类迭代器与容器绑定在一起，实现在容器中插入元素的功能。 </p></li><li><p>iostream 迭代器：这类迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 </p></li><li><p>反向迭代器：这类迭代器实现向后遍历，而不是向前遍历。所有容器类型都定义了自己的 reverse_iterator 类型，由 rbegin 和 rend 成员函数返回。 </p></li></ol><h3 id="11-3-1-插入迭代器"><a href="#11-3-1-插入迭代器" class="headerlink" title="11.3.1 插入迭代器"></a>11.3.1 插入迭代器</h3><p>back_inserter，创建使用 push_back 实现插入的迭代器。 </p><p>front_inserter，使用 push_front 实现插入。 </p><p>inserter，使用 insert 实现插入操作。除了所关联的容器外，inserter还带有第二实参：指向插入起始位置的迭代器。 </p><h3 id="11-3-2-iostream-迭代器"><a href="#11-3-2-iostream-迭代器" class="headerlink" title="11.3.2 iostream 迭代器"></a>11.3.2 iostream 迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;T&gt; in(strm);      //创建从输入流 strm 中读取 T 类型对象的 istream_iterator 对象 </span><br><span class="line">istream_iterator&lt;T&gt; in;            //istream_iterator 对象的超出末端迭代器 </span><br><span class="line">ostream_iterator&lt;T&gt; in(strm);      //创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象 </span><br><span class="line">ostream_iterator&lt;T&gt; in(strm, delim);     //创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象，在写入过程中使用 delim 作为元素的分隔符。delim 是以空字符结束的字符数组</span><br></pre></td></tr></table></figure><p>这个程序读 cin，并将每个读入的值依次写到 cout 中不同的行中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;string&gt; out_iter(cout, &quot;\n&quot;);</span><br><span class="line">istream_iterator&lt;string&gt; in_iter(cin), eof;</span><br><span class="line">while (in_iter != eof) &#123;</span><br><span class="line">*out_iter++ = *in_iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可能从 ostream_iterator 对象读入，也不可能写到 istream_iterator 对象中。 </p><p>一旦给 ostream_iterator 对象赋了一个值，写入就提交了。赋值后，没有办法再改变这个值。此外，ostream_iterator 对象中每个不同的值都只能正好输出一次。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; cin_it(cin), end_of_stream;</span><br><span class="line">vector&lt;int&gt; vec(cin_it, end_of_stream);       //输入：3 109 45 89 6 34 12 90 34 23 56 23 8 89 23</span><br><span class="line">sort(vec.begin(), vec.end());</span><br><span class="line">ostream_iterator&lt;int&gt; output(cout, &quot; &quot;);</span><br><span class="line">unique_copy(vec.begin(), vec.end(), output);      //6 8 12 23 34 45 56 89 90 109</span><br></pre></td></tr></table></figure><h3 id="11-3-3-反向迭代器"><a href="#11-3-3-反向迭代器" class="headerlink" title="11.3.3 反向迭代器"></a>11.3.3 反向迭代器</h3><p>反向迭代器是一种反向遍历容器的迭代器。也就是，从最后一个元素到第一个元素遍历容器。反向迭代器将自增（和自减）的含义反过来了：对于反向迭代器，++ 运算将访问前一个元素，而 – 运算则访问下一个元素。 </p><p>流迭代器不能创建反向迭代器。</p><h3 id="11-3-4-const-迭代器"><a href="#11-3-4-const-迭代器" class="headerlink" title="11.3.4 const 迭代器"></a>11.3.4 const 迭代器</h3><p>不希望使用这个迭代器来修改容器中的元素。 </p><h3 id="11-3-5-五种迭代器"><a href="#11-3-5-五种迭代器" class="headerlink" title="11.3.5 五种迭代器"></a>11.3.5 五种迭代器</h3><p>输入迭代器：读，不能写；只支持自增运算<br>输出迭代器：写，不能读；只支持自增运算<br>前向迭代器：读和写；只支持自增运算<br>双向迭代器：读和写；支持自增和自减运算<br>随机访问迭代器：读和写；支持完整的迭代器算术运算 </p><h2 id="11-4-泛型算法的结构"><a href="#11-4-泛型算法的结构" class="headerlink" title="11.4 泛型算法的结构"></a>11.4 泛型算法的结构</h2><p>大多数算法采用下面四种形式之一： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg (beg, end, other parms); </span><br><span class="line">alg (beg, end, dest, other parms); </span><br><span class="line">alg (beg, end, beg2, other parms); </span><br><span class="line">alg (beg, end, beg2, end2, other parms)</span><br></pre></td></tr></table></figure><p>其中，alg 是算法的名字，beg 和 end 指定算法操作的元素范围。其他形参：dest、beg2 和 end2，它们都是迭代器。有些算法还带有其他的非迭代器形参。</p><h2 id="11-5-容器特有的算法"><a href="#11-5-容器特有的算法" class="headerlink" title="11.5 容器特有的算法"></a>11.5 容器特有的算法</h2><p>list 容器上的迭代器是双向的，而不是随机访问类型。由于 list 容器不支持随机访问，因此，在此容器上不能使用需要随机访问迭代器的算法。这些算法包括 sort 及其相关的算法。还有一些其他的泛型算法，如 merge、remove、reverse 和 unique，虽然可以用在 list 上，但却付出了性能上的代价。</p><p><strong>list 容器特有的操作</strong></p><p>对于 list 对象，应该优先使用 list 容器特有的成员版本，而不是泛型算法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst.merge(lst2) </span><br><span class="line">lst.merge(lst2, comp)</span><br></pre></td></tr></table></figure><p>将 lst2 的元素合并到 lst 中。这两个 list 容器对象都必须排序。lst2 中的元素将被删除。合并后，lst2 为空。返回 void 类型。第一个版本使用 &lt; 操作符，而第二个版本则使用 comp 指定的比较运算 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lst.remove(val) </span><br><span class="line">lst.remove_if(unaryPred)</span><br></pre></td></tr></table></figure><p>调用 lst.erase 删除所有等于指定值或使指定的谓词函数返回非零值的元素。返回 void 类型 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十一章-泛型算法&quot;&gt;&lt;a href=&quot;#第十一章-泛型算法&quot; class=&quot;headerlink&quot; title=&quot;第十一章 泛型算法&quot;&gt;&lt;/a&gt;第十一章 泛型算法&lt;/h1&gt;&lt;p&gt;标准库并没有为每种容器类型都定义实现这些操作的成员函数，而是定义了一组&lt;strong&gt;泛型算法&lt;/strong&gt;：因为它们实现共同的操作，所以称之为“算法”；而“泛型”指的是它们可以操作在多种容器类型上——不但可作用于vector或list这些标准库类型，还可用在内置数组类型、甚至其他类型的序列上。自定义的容器类型只要与标准库兼容，同样可以使用这些泛型算法。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson16</title>
    <link href="https://zypsola.com/2018/11/06/C++Primer16/"/>
    <id>https://zypsola.com/2018/11/06/C++Primer16/</id>
    <published>2018-11-06T13:26:16.000Z</published>
    <updated>2018-11-07T09:19:53.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-关联容器"><a href="#第十章-关联容器" class="headerlink" title="第十章 关联容器"></a>第十章 关联容器</h1><p><strong>关联容器</strong>和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。 </p><a id="more"></a><p>关联容器（Associative containers）支持通过键来高效地查找和读取元素。两个基本的关联容器类型是 map、set。map 的元素以键－值（key-value）对的形式组织：键用作元素在 map 中的索引，而值则表示所存储和读取的数据。set 仅包含一个键，并有效地支持关于某个键是否存在的查询。 </p><p>set 和 map 类型的对象所包含的元素都具有不同的键，不允许为同一个键添加第二个元素。如果一个键必须对应多个实例，则需使用 multimap 或 multiset，这两种类型允许多个元素拥有相同的键。 </p><h2 id="10-1-引言：pair类型"><a href="#10-1-引言：pair类型" class="headerlink" title="10.1 引言：pair类型"></a>10.1 引言：pair类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;         创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用值初始化</span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2); 创建一个 pair 对象，它的两个元素分别是 T1 和 T2 ，其中 first 成员初始化为 v1，而 second 成员初始化为 v2 </span><br><span class="line">make_pair(v1, v2)        以 v1 和 v2 值创建一个新 pair 对象，其元素类型分别是 v1 和 v2 的类型 </span><br><span class="line">p1 &lt; p2    两个 pair 对象之间的小于运算，其定义遵循字典次序：如果 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second，则返回 true </span><br><span class="line">p1 == p2   如果两个 pair 对象的 first 和 second 成员依次相等，则这两个对象相等。该运算使用其元素的 == 操作符 </span><br><span class="line">p.first    返回 p 中名为 first 的（公有）数据成员 </span><br><span class="line">p.second   返回 p 的名为 second 的（公有）数据成员</span><br></pre></td></tr></table></figure><p>与其他标准库类型不同，对于 pair 类，可以直接访问其数据成员：其成员都是仅有的，分别命名为 first 和 second。只需使用普通的点操作符——成员访问标志即可访问其成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, string&gt; b = make_pair(4, &quot;afsd&quot;);  </span><br><span class="line">cout &lt;&lt; b.first &lt;&lt; b.second &lt;&lt; endl;   //4afsd</span><br><span class="line">b = pair&lt;int, string&gt;(6, &quot;ggg&quot;);</span><br><span class="line">cout &lt;&lt; b.first &lt;&lt; b.second &lt;&lt; endl;   //6ggg</span><br></pre></td></tr></table></figure><h2 id="10-2-关联容器"><a href="#10-2-关联容器" class="headerlink" title="10.2 关联容器"></a>10.2 关联容器</h2><p>关联容器共享大部分但并非全部的顺序容器操作。关联容器不提供 front、 push_front、 pop_front、back、push_back 以及 pop_back 操作。 </p><ol><li><p>三种构造函数：C<t> c; C<t> c1(c2);  C<t> c(b, e); 关联容器不能通过容器大小来定义，因为这样的话就无法知道键所对应的值是什么。 </t></t></t></p></li><li><p>关系运算。</p></li><li><p>begin、end、rbegin 和 rend 操作。 </p></li><li><p>swap 和赋值操作。但关联容器不提供 assign 函数。</p></li><li><p>clear 和 erase 操作，但关联容器的 erase 运算返回 void 类型。 </p></li><li><p>关于容器大小的操作。但 resize 函数不能用于关联容器。</p></li></ol><h2 id="10-3-map类型"><a href="#10-3-map类型" class="headerlink" title="10.3 map类型"></a>10.3 map类型</h2><p>map 是键－值对的集合。map 类型通常可理解为关联数组（associative array）：可使用键作为下标来获取一个值，正如内置数组类型一样。而关联的本质在于元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取。 </p><h3 id="10-3-1-map对象的定义"><a href="#10-3-1-map对象的定义" class="headerlink" title="10.3.1 map对象的定义"></a>10.3.1 map对象的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;k, v&gt; m;         创建一个名为 m 的空 map 对象，其键和值的类型分别为 k 和 v</span><br><span class="line">map&lt;k, v&gt; m(m2);     创建 m2 的副本 m，m 与 m2 必须有相同的键类型和值类型 </span><br><span class="line">map&lt;k, v&gt; m(b, e);   创建 map 类型的对象 m，存储迭代器 b 和 e 标记的范围内所有元素的副本。元素的类型必须能转换为 pair&lt;const k, v&gt;</span><br></pre></td></tr></table></figure><p>在使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。默认情况下，标准库使用键类型定义的 &lt; 操作符来实现键（key type）的比较。</p><p>所用的比较函数必须在键类型上定义严格弱排序（strict weak ordering）。所谓的严格弱排序可理解为键类型数据上的“小于”关系，虽然实际上可以选择将比较函数设计得更复杂。但无论这样的比较函数如何定义，当用于一个键与自身的比较时，肯定会导致 false 结果。此外，在比较两个键时，不能出现相互“小于”的情况，而且，如果 k1“小于”k2，k2“小于”k3，则 k1 必然“小于”k3。对于两个键，如果它们相互之间都不存在“小于”关系，则容器将之视为相同的键。用做 map 对象的键时，可使用任意一个键值来访问相应的元素。 </p><h3 id="10-3-2-map定义的类型"><a href="#10-3-2-map定义的类型" class="headerlink" title="10.3.2 map定义的类型"></a>10.3.2 map定义的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;K, V&gt;::key_type    在 map 容器中，用做索引的键的类型 </span><br><span class="line">map&lt;K, V&gt;::mapped_type 在 map 容器中，键所关联的值的类型 </span><br><span class="line">map&lt;K, V&gt;::value_type  一个 pair 类型，它的 first 元素具有 const map&lt;K, V&gt;::key_type 类型，而 second 元素则为 map&lt;K, V&gt;::mapped_type 类型</span><br></pre></td></tr></table></figure><p>value_type 是 pair 类型，它的值成员可以修改，但键成员不能修改。 </p><p>对迭代器进行解引用时，将获得一个引用，指向容器中一个 value_type 类型的值。对于 map 容器，其 value_type 是 pair 类型。</p><h3 id="10-3-3-给map添加元素"><a href="#10-3-3-给map添加元素" class="headerlink" title="10.3.3 给map添加元素"></a>10.3.3 给map添加元素</h3><p>可使用 insert 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。</p><h3 id="10-3-4-使用下标访问map对象"><a href="#10-3-4-使用下标访问map对象" class="headerlink" title="10.3.4 使用下标访问map对象"></a>10.3.4 使用下标访问map对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m[&quot;abc&quot;] = 5;</span><br><span class="line">m[&quot;Abc&quot;] = 3;</span><br><span class="line">map&lt;string, int&gt;::iterator iter = m.begin();</span><br><span class="line">cout &lt;&lt; (*iter).first &lt;&lt; (*iter).second &lt;&lt; endl;     //Abc3</span><br><span class="line">cout &lt;&lt; m.size() &lt;&lt; endl;                            //2</span><br></pre></td></tr></table></figure><p>map 的下标也使用索引（键）来获取该键所关联的值。如果该键已在容器中，则 map 的下标运算与 vector 的下标运算行为相同：返回该键所关联的值。只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。</p><h3 id="10-3-5-map-insert-的使用"><a href="#10-3-5-map-insert-的使用" class="headerlink" title="10.3.5 map::insert 的使用"></a>10.3.5 map::insert 的使用</h3><ol><li><p>m.insert(e)        e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则插入一个值为 e.second 的新元素；如果该键在 m 中已存在，则保持 m 不变。该函数返回一个 pair 类型对象，包含指向键为 e.first 的元素的 map 迭代器，以及一个 bool 类型的对象，表示是否插入了该元素 </p></li><li><p>m.insert(beg, end) beg 和 end 是标记元素范围的迭代器，其中的元素必须为 m.value_type 类型的键－值对。对于该范围内的所有元素，如果它的键在 m 中不存在，则将该键及其关联的值插入到 m。返回 void 类型 </p></li><li><p>m.insert(iter, e)  e 是一个用在 m 上的 value_type 类型的值。如果键（e.first）不在 m 中，则创建新元素，并以迭代器 iter 为起点搜索新元素存储的位置。返回一个迭代器，指向 m 中具有给定键的元素 </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef map&lt;string, int&gt;::value_type valType;</span><br><span class="line">map&lt;string, int&gt; m;</span><br><span class="line">m.insert(map&lt;string, int&gt;::value_type(&quot;afd&quot;, 7));</span><br><span class="line">m.insert(make_pair(&quot;4df&quot;, 1));</span><br><span class="line">m.insert(valType(&quot;123&quot;, 9));</span><br></pre></td></tr></table></figure><h3 id="10-3-6-查找并读取map中的元素"><a href="#10-3-6-查找并读取map中的元素" class="headerlink" title="10.3.6 查找并读取map中的元素"></a>10.3.6 查找并读取map中的元素</h3><p>下标操作符给出了读取一个值的最简单方法，但是，使用下标存在一个很危险的副作用：如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。 </p><p>map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.count(k)  返回m中k的出现次数 </span><br><span class="line">m.find(k)   如果m容器中存在按k索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代</span><br></pre></td></tr></table></figure><p>对于 map 对象，count 成员的返回值只能是 0 或 1。map 容器只允许一个键对应一个实例，所以 count 可有效地表明一个键是否存在。</p><h3 id="10-3-7-从-map-对象中删除元素"><a href="#10-3-7-从-map-对象中删除元素" class="headerlink" title="10.3.7 从 map 对象中删除元素"></a>10.3.7 从 map 对象中删除元素</h3><p>map 容器的 erase 操作返回 void。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.erase(k)     删除 m 中键为 k 的元素。返回被删除元素的个数。对于 map 容器，该值必然是 0 或 1。如果返回 0，则表示欲删除的元素在 map 不存在。 </span><br><span class="line">m.erase(p)     从 m 中删除迭代器 p 所指向的元素。p 必须指向 m 中确实存在的元素，而且不能等于 m.end()。返回 void </span><br><span class="line">m.erase(b, e)  从 m 中删除一段范围内的元素，该范围由迭代器对 b 和 e 标记。b 和 e 必须标记 m 中的一段有效范围：即 b 和 e 都必须指向 m 中的元素或最后一个元素的下一个位置。而且，b 和 e 要么相等（此时删除的范围为空），要么 b 所指向的元素必须出现在 e 所指向的元素之前。返回 void 类型</span><br></pre></td></tr></table></figure><h2 id="10-4-set"><a href="#10-4-set" class="headerlink" title="10.4 set"></a>10.4 set</h2><p>set 容器只是单纯的键的集合。</p><p>set 容器支持大部分的 map 操作，set 不支持下标操作符，而且没有定义 mapped_type 类型。在 set 容器中，value_type 不是 pair 类型，而是与 key_type 相同的类型。它们指的都是 set 中存储的元素类型。</p><p><strong>从set中获取元素</strong></p><p>set 容器不提供下标操作符。为了通过键从 set 中获取元素，可使用 find 运算。如果只需简单地判断某个元素是否存在，同样可以使用 count 运算，返回 set 中该键对应的元素个数。当然，对于 set 容器，count 的返回值只能是 1（该元素存在）或 0（该元素不存在）。</p><p>set 中的键也为 const。在获得指向 set 中某元素的迭代器后，只能对其做读操作，而不能做写操作。</p><h2 id="10-5-multimap和multiset类型"><a href="#10-5-multimap和multiset类型" class="headerlink" title="10.5. multimap和multiset类型"></a>10.5. multimap和multiset类型</h2><p>multiset和multimap类型允许一个键对应多个实例。multimap 和 multiset 所支持的操作分别与 map 和 set 的操作相同，只有一个例外：multimap 不支持下标运算。不能对 multimap 对象使用下标操作，因为在这类容器中，某个键可能对应多个值。</p><h3 id="10-5-1-元素的添加和删除"><a href="#10-5-1-元素的添加和删除" class="headerlink" title="10.5.1 元素的添加和删除"></a>10.5.1 元素的添加和删除</h3><p>由于键不要求是唯一的，因此每次调用 insert 总会添加一个元素。</p><p>带有一个键参数的 erase 版本将删除拥有该键的所有元素，并返回删除元素的个数。而带有一个或一对迭代器参数的版本只删除指定的元素，并返回 void 类型。</p><h3 id="10-5-2-在multimap和multiset中查找元素"><a href="#10-5-2-在multimap和multiset中查找元素" class="headerlink" title="10.5.2 在multimap和multiset中查找元素"></a>10.5.2 在multimap和multiset中查找元素</h3><p>count 函数求出某键出现的次数，而 find 操作则返回一个迭代器，指向第一个拥有正在查找的键的实例。</p><p><strong>lower_bound 和 upper_bound</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.lower_bound(k)  返回一个迭代器，指向键不小于 k 的第一个元素 </span><br><span class="line">m.upper_bound(k)  返回一个迭代器，指向键大于 k 的第一个元素 </span><br><span class="line">m.equal_range(k)  返回一个迭代器的 pair 对象，它的 first 成员等价于 m.lower_bound(k)。而 second 成员则等价于 m.upper_bound(k)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第十章-关联容器&quot;&gt;&lt;a href=&quot;#第十章-关联容器&quot; class=&quot;headerlink&quot; title=&quot;第十章 关联容器&quot;&gt;&lt;/a&gt;第十章 关联容器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;关联容器&lt;/strong&gt;和顺序容器的本质差别在于：关联容器通过键（key）存储和读取元素，而顺序容器则通过元素在容器中的位置顺序存储和访问元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson15</title>
    <link href="https://zypsola.com/2018/11/05/C++Primer15/"/>
    <id>https://zypsola.com/2018/11/05/C++Primer15/</id>
    <published>2018-11-05T15:43:41.000Z</published>
    <updated>2018-11-06T14:49:49.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><p>容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是<strong>顺序容器</strong>。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。 </p><a id="more"></a><p>标准库定义了三种顺序容器类型：<strong>vector</strong>(支持快速随机访问)、<strong>list</strong>(支持快速插入/删除)和<strong>deque</strong>(双端队列)。它们的差别在于访问元素的方式，以及添加或删除元素相关操作的运行代价。标准库还提供了三种容器适配器。实际上，适配器是根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。顺序容器适配器包括<strong>stack</strong>(后进先出LIFO堆栈)、<strong>queue</strong>(先进先出FIFO队列)和<strong>priority_queue</strong>(有优先级管理的队列)类型。</p><h2 id="9-1-顺序容器的定义"><a href="#9-1-顺序容器的定义" class="headerlink" title="9.1 顺序容器的定义"></a>9.1 顺序容器的定义</h2><p>所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。在大多数的程序中，使用默认构造函数能达到最佳运行时性能，并且使容器更容易使用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C&lt;T&gt; c;    创建一个的空容器，适用于所有容器。 </span><br><span class="line">C c(c2);   创建容器 c2 的副本；c 和 c2 必须具有相同的容器类型，相同类型的元素。适用于所有容器。 </span><br><span class="line">C c(b, e); 创建 c，其元素是迭代器 b 和 e 标示的范围内元素的副本。适用于所有容器。 </span><br><span class="line">C c(n, t); 用 n 个值为 t 的元素创建容器 c，其中值 t 必须是容器类型 C 的元素类型的值，或者是可转换为该类型的值。 只适用于顺序容器。 </span><br><span class="line">C c(n);    创建有 n 个值初始化元素的容器 c。 只适用于顺序容器。</span><br></pre></td></tr></table></figure><p><strong>初始化为一段元素的副本</strong></p><p>尽管不能直接将一种容器内的元素复制给另一种容器，但系统允许通过传递一对迭代器间接实现该实现该功能。使用迭代器时，不要求容器类型相同。容器内的元素类型也可以不相同，只要它们相互兼容，能够将要复制的元素转换为所构建的新容器的元素类型，即可实现复制。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char *words[] = &#123; &quot;asd&quot;,&quot;gfd&quot;,&quot;qwe&quot; &#125;;</span><br><span class="line">vector&lt;string&gt; svec(words, words + sizeof(words) / sizeof(char*));</span><br><span class="line">vector&lt;string&gt;::iterator iter = svec.begin();</span><br><span class="line">list&lt;string&gt; slist(svec.begin(), svec.end());</span><br><span class="line">list&lt;string&gt;::iterator iter2 = slist.begin();</span><br><span class="line">while (iter != svec.end() &amp;&amp; iter2 != slist.end())&#123;</span><br><span class="line">cout &lt;&lt; *iter++ &lt;&lt; *iter2++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>容器内元素的类型约束</strong></p><p>大多数类型都可用作容器的元素类型。容器元素类型必须满足以下两个约束：元素类型必须支持赋值运算；元素类型的对象必须可以复制。除了引用类型外，所有内置<br>或复合类型都可用做元素类型。此外，关联容器的键类型还需满足其他的约束。IO 库类型不支持复制或赋值。因此，不能创建存放 IO 类型对象的容器。</p><h2 id="9-2-迭代器和迭代器范围"><a href="#9-2-迭代器和迭代器范围" class="headerlink" title="9.2 迭代器和迭代器范围"></a>9.2 迭代器和迭代器范围</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*iter       返回迭代器 iter 所指向的元素的引用 </span><br><span class="line">iter-&gt;mem   对 iter 进行解引用，等效于(*iter).mem</span><br><span class="line">iter++;++iter;iter--;--iter;==;!=</span><br></pre></td></tr></table></figure><p><strong>vector和deque容器的迭代器提供额外的运算</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iter + n;iter - n;</span><br><span class="line">iter += n;iter -= iter;</span><br><span class="line">iter1 - iter2;</span><br><span class="line">&gt;,&gt;=,&lt;,&lt;=;</span><br></pre></td></tr></table></figure><h3 id="9-2-1-迭代器范围"><a href="#9-2-1-迭代器范围" class="headerlink" title="9.2.1 迭代器范围"></a>9.2.1 迭代器范围</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C.begin();C.end();</span><br></pre></td></tr></table></figure><h3 id="9-2-2-使迭代器失效的容器操作"><a href="#9-2-2-使迭代器失效的容器操作" class="headerlink" title="9.2.2 使迭代器失效的容器操作"></a>9.2.2 使迭代器失效的容器操作</h3><p>一些容器操作会修改容器的内在状态或移动容器内的元素。这样的操作使所有指向被移动的元素的迭代器失效，也可能同时使其他迭代器失效。使用无效迭代器是没有定义的，可能会导致与悬垂指针相同的问题。 </p><h2 id="9-3-每种顺序容器都提供了一组有用的类型定义以及以下操作"><a href="#9-3-每种顺序容器都提供了一组有用的类型定义以及以下操作" class="headerlink" title="9.3 每种顺序容器都提供了一组有用的类型定义以及以下操作"></a>9.3 每种顺序容器都提供了一组有用的类型定义以及以下操作</h2><p>在容器中添加元素。<br>在容器中删除元素。<br>设置容器大小。<br>（如果有的话）获取容器内的第一个和最后一个元素。</p><h3 id="9-3-1-容器定义的类型别名"><a href="#9-3-1-容器定义的类型别名" class="headerlink" title="9.3.1 容器定义的类型别名"></a>9.3.1 容器定义的类型别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size_type   无符号整型，足以存储此容器类型的最大可能容器长度 </span><br><span class="line">iterator    此容器类型的迭代器类型 </span><br><span class="line">const_iterator    元素的只读迭代器类型 </span><br><span class="line">reverse_iterator  按逆序寻址元素的迭代器 </span><br><span class="line">const_reverse_iterator  元素的只读（不能写）逆序迭代器 </span><br><span class="line">difference_type   足够存储两个迭代器差值的有符号整型，可为负数 </span><br><span class="line">value_type        元素类型 </span><br><span class="line">reference         元素的左值类型，是 value_type&amp; 的同义词 </span><br><span class="line">const_reference   元素的常量左值类型，等效于 const value_type&amp;</span><br></pre></td></tr></table></figure><h3 id="9-3-2-begin和end成员"><a href="#9-3-2-begin和end成员" class="headerlink" title="9.3.2 begin和end成员"></a>9.3.2 begin和end成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.begin()   返回一个迭代器，指向 c 的第一个元素 </span><br><span class="line">c.end()     返回一个迭代器，指向 c 的最后一个元素的下一位置 </span><br><span class="line">c.rbegin()  返回一个逆序迭代器，指向 c 的最后一个元素 </span><br><span class="line">c.rend()    返回一个逆序迭代器，指向 c 的第一个元素前面的位置</span><br></pre></td></tr></table></figure><p>这些操作返回什么类型取决于容器是否为 const。如果容器不是 const，则这些操作返回 iterator 或 reverse_iterator 类型。如果容器是 const，则其返回类型要加上 const_ 前缀，也就是 const_iterator 和 const_reverse_iterator 类型。</p><h3 id="9-3-3-在顺序容器中添加元素"><a href="#9-3-3-在顺序容器中添加元素" class="headerlink" title="9.3.3 在顺序容器中添加元素"></a>9.3.3 在顺序容器中添加元素</h3><p>所有顺序容器都支持push_back操作，提供在容器尾部插入一个元素的功能。</p><p>除了 push_back 运算，list 和 deque 容器类型还提供了类似的操作：push_front。这个操作实现在容器首部插入新元素的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.push_back(t)   在容器 c 的尾部添加值为 t 的元素。返回 void 类型 </span><br><span class="line">c.push_front(t)  在容器 c 的前端添加值为 t 的元素。返回 void 类型，只适用于 list 和 deque 容器类型 </span><br><span class="line">c.insert(p,t)    在迭代器 p 所指向的元素前面插入值为 t 的新元素。返回指向新添加元素的迭代器</span><br><span class="line">c.insert(p,n,t)  在迭代器 p 所指向的元素前面插入 n 个值为 t 的新元素。返回 void 类型</span><br><span class="line">c.insert(p,b,e)  在迭代器 p 所指向的元素前面插入由迭代器 b 和 e 标记的范围内的元素。返回 void 类型</span><br></pre></td></tr></table></figure><h3 id="9-3-4-关系操作符"><a href="#9-3-4-关系操作符" class="headerlink" title="9.3.4 关系操作符"></a>9.3.4 关系操作符</h3><p>所有的容器类型都支持用关系操作符来实现两个容器的比较。比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。容器的比较使用了元素类型定义的同<br>一个关系操作符：两个容器做 != 比较使用了其元素类型定义的 != 操作符。如果容器的元素类型不支持某种操作符，则该容器就不能做这种比较运算。 </p><p>如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。 </p><p>如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。 </p><p>如果两个容器都不是对文的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。 </p><h3 id="9-3-5-容器大小的操作"><a href="#9-3-5-容器大小的操作" class="headerlink" title="9.3.5 容器大小的操作"></a>9.3.5 容器大小的操作</h3><p>所有容器类型都提供四种与容器大小相关的操。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.size()       返回容器 c 中的元素个数。返回类型为 c::size_type </span><br><span class="line">c.max_size()   返回容器 c 可容纳的最多元素个数，返回类型为 c::size_type </span><br><span class="line">c.empty()      返回标记容器大小是否为 0 的布尔值 </span><br><span class="line">c.resize(n)    调整容器 c 的长度大小，使其能容纳 n 个元素，如果 n &lt; c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素 </span><br><span class="line">c.resize(n,t)  调整容器 c 的长度大小，使其能容纳 n 个元素。所有新添加的元素值都为 t</span><br></pre></td></tr></table></figure><h3 id="9-3-6-访问元素"><a href="#9-3-6-访问元素" class="headerlink" title="9.3.6 访问元素"></a>9.3.6 访问元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.back()   返回容器 c 的最后一个元素的引用。如果 c 为空，则该操作未定义 </span><br><span class="line">c.front()  返回容器 c 的第一个元素的引用。如果 c 为空，则该操作未定义</span><br><span class="line">c[n]       返回下标为 n 的元素的引用 如果 n &lt;0 或 n &gt;= c.size()，则该操作未定义，只适用于vector和deque</span><br><span class="line">c.at(n)    返回下标为 n 的元素的引用。如果下标越界，则该操作未定义，只适用于vector和deque</span><br></pre></td></tr></table></figure><h3 id="9-3-7-删除元素"><a href="#9-3-7-删除元素" class="headerlink" title="9.3.7 删除元素"></a>9.3.7 删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.erase(p)    删除p所指向的元素，返回一个迭代器，它指向被删除元素后面的元素。如果p指向容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置 </span><br><span class="line">c.erase(b,e)  删除b和e所标记的范围内所有的元素，返回一个迭代器，它指向被删除元素段后面的元素。如果e本身就是指向超出末端的下一位置的迭代器，则返回的迭代器也指向容器的超出末端的下一位置</span><br><span class="line">c.clear()     删除容器c内的所有元素。返回 void </span><br><span class="line">c.pop_back()  删除容器c的最后一个元素。返回 void。如果c为空容器，则该函数未定义 </span><br><span class="line">c.pop_front() 删除容器c的第一个元素。返回 void。如果c为空容器，则该函数未定义，只适用于 list 或 deque 容器</span><br></pre></td></tr></table></figure><h3 id="9-3-8-赋值与swap"><a href="#9-3-8-赋值与swap" class="headerlink" title="9.3.8 赋值与swap"></a>9.3.8 赋值与swap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2        删除容器 c1 的所有元素，然后将 c2 的元素复制给 c1。c1 和c2 的类型（包括容器类型和元素类型）必须相同 </span><br><span class="line">c1.swap(c2)    交换内容：c1 中存放的是 c2 原来的元素，c2 中存放的则是 c1 原来的元素。c1 和 c2 的类型必须相同。该函数的执行速度通常要比将 c2 复制到 c1 的操作快 </span><br><span class="line">c.assign(b,e)  重新设置 c 的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器 </span><br><span class="line">c.assign(n,t)  将容器 c 重新设置为存储 n 个值为 t 的元素</span><br></pre></td></tr></table></figure><p>swap操作不会删除或插入任何元素，而且保证在常量时间内实现交换。由于容器内没有移动任何元素，因此迭代器不会失效。 </p><h2 id="9-4-vector容器的自增长"><a href="#9-4-vector容器的自增长" class="headerlink" title="9.4 vector容器的自增长"></a>9.4 vector容器的自增长</h2><p>为了支持快速的随机访问，vector 容器的元素以连续的方式存放：每一个元素都紧挨着前一个元素存储。 </p><p>为了使 vector 容器实现快速的内存分配，其实际分配的容量要比当前所需的空间多一些。vector 容器预留了这些额外的存储区，用于存放新添加的元素。</p><p>在实际应用中，比起 list 和 deque 容器，vector 的增长效率通常会更高。 </p><h3 id="9-4-1-capacity和reserve成员"><a href="#9-4-1-capacity和reserve成员" class="headerlink" title="9.4.1 capacity和reserve成员"></a>9.4.1 capacity和reserve成员</h3><p>vector容器处理内存分配的细节是其实现的一部分。然而，该实现部分是由vector的接口支持的。vector类提供了两个成员函数：capacity和reserve使程序员可与vector容器内存分配的实现部分交互工作。capacity 操作获取在容器需要分配更多的存储空间之前能够存储的元素总数，而reserve操作则告诉vector容器应该预留多少个元素的存储空间。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; svec(10);</span><br><span class="line">cout &lt;&lt; svec.capacity() &lt;&lt; endl;     //10</span><br><span class="line">svec.reserve(50);</span><br><span class="line">cout &lt;&lt; svec.capacity() &lt;&lt; endl;     //50</span><br></pre></td></tr></table></figure><h2 id="9-5-容器的选用"><a href="#9-5-容器的选用" class="headerlink" title="9.5 容器的选用"></a>9.5 容器的选用</h2><p>程序使用这些操作的程序将决定应该选择哪种类型的容器。vector和deque容器提供了对元素的快速随机访问，但付出的代价是，在容器的任意位置插入或删除元素，比在容器尾部插入和删除的开销更大。list类型在任何位置都能快速插入和删除，但付出的代价是元素的随机访问开销较大。 </p><p><strong>插入操作如何影响容器的选择</strong></p><p>list 容器表示不连续的内存区域，允许向前和向后逐个遍历元素。在任何位置都可高效地 insert 或 erase 一个元素。插入或删除 list 容器中的一个元素不需要移动任何其他元素。另一方面，list 容器不支持随机访问，访问某个元素要求遍历涉及的其他元素。 </p><p>对于 vector 容器，除了容器尾部外，其他任何位置上的插入（或删除）操作都要求移动被插入（或删除）元素右边所有的元素。</p><p>deque 容器拥有更加复杂的数据结构。从 deque 队列的两端插入和删除元素都非常快。在容器中间插入或删除付出的代价将更高。</p><p><strong>元素的访问如何影响容器的选择</strong></p><p>vector 和 deque 容器都支持对其元素实现高效的随机访问。由于 vector 容器的每次访问都是距离其起点的固定偏移，因此其随机访问非常有效率。在 list 容器中，上述跳跃访问会变得慢很多。在 list 容器的元素之间移动的唯一方法是顺序跟随指针。</p><h2 id="再谈string类型"><a href="#再谈string类型" class="headerlink" title="再谈string类型"></a>再谈string类型</h2><p>string 类型还支持大多数顺序容器操作。在某些方面，可将 string 类型视为字符容器。除了一些特殊操作，string 类型提供与 vector 容器相同的操作。string 类型与 vector 容器不同的是，它不支持以栈方式操纵容器：在 string 类型中不能使用 front、back 和 pop_back 操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = &quot;123&quot;;</span><br><span class="line">string::iterator iter = str.begin();</span><br><span class="line">while (iter != str.end()) &#123;</span><br><span class="line">cout &lt;&lt; *iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只适用于string类型的操作"><a href="#只适用于string类型的操作" class="headerlink" title="只适用于string类型的操作"></a>只适用于string类型的操作</h3><p><strong>子串操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.substr(pos, n) 返回一个 string 类型的字符串，它包含 s 中从下标 pos 开始的 n 个字符 </span><br><span class="line">s.substr(pos)    返回一个 string 类型的字符串，它包含从下标 pos 开始到 s 末尾的所有字符 </span><br><span class="line">s.substr()       返回 s 的副本</span><br></pre></td></tr></table></figure><p><strong>append和replace</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.append( args)           将 args 串接在 s 后面。返回 s 引用 </span><br><span class="line">s.replace(pos, len, args) 删除 s 中从下标 pos 开始的 len 个字符，用 args 指定的字符替换之。返回 s 的引用，在这个版本中，args 不能为 b2，e2 </span><br><span class="line">s.replace(b, e, args)     删除迭代器 b 和 e 标记范围内所有的字符，用 args 替换之。返回 s 的引用，在这个版本中，args 不能为 s2，pos2，len2</span><br></pre></td></tr></table></figure><p><strong>append和replace的args</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s2              string 类型的字符串 s2 </span><br><span class="line">s2, pos2, len2  字符串 s2 中从下标 pos2 开始的 len2 个字符 </span><br><span class="line">cp              指针 cp 指向的以空字符结束的数组 </span><br><span class="line">cp, len2        cp 指向的以空字符结束的数组中前 len2 个字符 </span><br><span class="line">n, c            字符 c 的 n 个副本 </span><br><span class="line">b2, e2          迭代器 b2 和 e2 标记的范围内所有字符</span><br></pre></td></tr></table></figure><p><strong>find</strong></p><p>string 类提供了6种查找函数，每种函数以不同形式的 find 命名。这些操作全都返回 string::size_type 类型的值，以下标形式标记查找匹配所发生的位置；或者返回一个名为 string::npos 的特殊值，说明查找没有匹配。string 类将 npos 定义为保证大于任何有效下标的值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.find( args)   在 s 中查找 args 的第一次出现 </span><br><span class="line">s.rfind( args)  在 s 中查找 args 的最后一次出现 </span><br><span class="line">s.find_first_of( args)   在 s 中查找 args 的任意字符的第一次出现 </span><br><span class="line">s.find_last_of( args)    在 s 中查找 args 的任意字符的最后一次出现</span><br><span class="line">s.find_first_not_of( args)  在 s 中查找第一个不属于 args 的字符 </span><br><span class="line">s.find_last_not_of( args)   在 s 中查找最后一个不属于 args 的字符</span><br></pre></td></tr></table></figure><p><strong>find的args</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c, pos      在 s 中，从下标 pos 标记的位置开始，查找字符 c。pos 的默认值为 0 </span><br><span class="line">s2, pos     在 s 中，从下标 pos 标记的位置开始，查找 string 对象 s2。pos 的默认值为 0 </span><br><span class="line">cp, pos     在 s 中，从下标 pos 标记的位置形参，查找指针 cp 所指向的 C 风格的以空字符结束的字符串。pos 的默认值为 0 </span><br><span class="line">cp, pos, n  在 s 中，从下标 pos 标记的位置开始，查找指针 cp 所指向数组的前 n 个字符。pos 和 n 都没有默认值</span><br></pre></td></tr></table></figure><p><strong>查找任意字符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string numbers = &quot;0123456789&quot;;</span><br><span class="line">string str = &quot;ab5bz9&quot;;</span><br><span class="line">cout &lt;&lt; str.find_first_of(numbers);      //2</span><br></pre></td></tr></table></figure><p><strong>compare 函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.compare(s2)                        比较 s 和 s2 </span><br><span class="line">s.compare(pos1, n1, s2)              让 s 中从 pos 下标位置开始的 n1 个字符与 s2 做比较 </span><br><span class="line">s.compare(pos1, n1, s2, pos2, n2)    让 s 中从 pos1 下标位置开始的 n1 个字符与 s2 中从 pos2 下标位置开始的 n2 个字符做比较 </span><br><span class="line">s.compare(cp)               比较 s 和 cp 所指向的以空字符结束的字符串 </span><br><span class="line">s.compare(pos1, n1, cp)     让 s 中从 pos1 下标位置开始的 n1 个字符与 cp 所指向的字符串做比较 </span><br><span class="line">s.compare(pos1, n1, cp, n2) 让 s 中从 pos1 下标位置开始的 n1 个字符与 cp 所指向的字符串的前 n2 个字符做比较</span><br></pre></td></tr></table></figure><h2 id="9-7-容器适配器"><a href="#9-7-容器适配器" class="headerlink" title="9.7 容器适配器"></a>9.7 容器适配器</h2><p>除了顺序容器，标准库还提供了三种顺序容器适配器：<strong>queue</strong>、<strong>priority_queue</strong>和<strong>stack</strong>。适配器(adaptor)是标准库中通用的概念，包括容器适配器、迭代器适配器和函数适配器。本质上，适配器是使一事物的行为类似于另一事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;    // stack adaptor </span><br><span class="line">#include &lt;queue&gt;    // both queue and priority_queue adaptors</span><br></pre></td></tr></table></figure><p><strong>适配器的初始化</strong></p><p>所有适配器都定义了两个构造函数：默认构造函数用于创建空对象，而带一个容器参数的构造函数将参数容器的副本作为其基础值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deq(10);</span><br><span class="line">stack&lt;int&gt; mystack(deq);</span><br></pre></td></tr></table></figure><p><strong>覆盖基础容器类型</strong></p><p>默认的 stack 和 queue 都基于 deque 容器实现，而 priority_queue 则在 vector 容器上实现。在创建适配器时，通过将一个顺序容器指定为适配器的第二个类型实参，可覆盖其关联的基础容器类型： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vec(10);</span><br><span class="line">stack&lt;int,vector&lt;int&gt;&gt; mystack(vec);</span><br></pre></td></tr></table></figure><p>对于给定的适配器，其关联的容器必须满足一定的约束条件。stack 适配器所关联的基础容器可以是任意一种顺序容器类型。因此，stack 栈可以建立在 vector、list 或者 deque 容器之上。而 queue 适配器要求其关联的基础容器必须提供 push_front 运算，因此只能建立在 list 容器上，而不能建立在 vector 容器上。priority_queue 适配器要求提供随机访问功能，因此可建立在 vector 或 deque 容器上，但不能建立在 list 容器上。 </p><h3 id="9-7-1-栈适配器"><a href="#9-7-1-栈适配器" class="headerlink" title="9.7.1 栈适配器"></a>9.7.1 栈适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.empty()     如果栈为空，则返回 true，否则返回 stack</span><br><span class="line">s.size()      返回栈中元素的个数 </span><br><span class="line">s.pop()       删除栈顶元素的值，但不返回其值 </span><br><span class="line">s.top()       返回栈顶元素的值，但不删除该元素</span><br><span class="line">s.push(item)  在栈顶压入新元素</span><br></pre></td></tr></table></figure><h3 id="9-7-2-队列和优先级队列"><a href="#9-7-2-队列和优先级队列" class="headerlink" title="9.7.2 队列和优先级队列"></a>9.7.2 队列和优先级队列</h3><p>priority_queue 允许用户为队列中存储的元素设置优先级。这种队列不是直接将新元素放置在队列尾部，而是放在比它优先级低的元素前面。标准库默认使用元素类型的 &lt; 操作符来确定它们之间的优先级关系。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q.empty()     如果队列为空，则返回 true，否则返回 false </span><br><span class="line">q.size()      返回队列中元素的个数 </span><br><span class="line">q.pop()       删除队首元素，但不返回其值 </span><br><span class="line">q.front()     返回队首元素的值，但不删除该元素 该操作只适用于队列 </span><br><span class="line">q.back()      返回队尾元素的值，但不删除该元素 该操作只适用于队列 </span><br><span class="line">q.top()       返回具有最高优先级的元素值，但不删除该元素 该操作只适用于优先级队列 </span><br><span class="line">q.push(item)  对于 queue，在队尾压入一个新元素，对于 priority_quue，在基于优先级的适当位置插入新元素</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第九章-顺序容器&quot;&gt;&lt;a href=&quot;#第九章-顺序容器&quot; class=&quot;headerlink&quot; title=&quot;第九章 顺序容器&quot;&gt;&lt;/a&gt;第九章 顺序容器&lt;/h1&gt;&lt;p&gt;容器容纳特定类型对象的集合。标准库 vector 类型是一种顺序容器。它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是&lt;strong&gt;顺序容器&lt;/strong&gt;。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson14</title>
    <link href="https://zypsola.com/2018/11/02/C++Primer14/"/>
    <id>https://zypsola.com/2018/11/02/C++Primer14/</id>
    <published>2018-11-02T12:54:55.000Z</published>
    <updated>2018-11-05T15:42:29.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-标准IO库"><a href="#第八章-标准IO库" class="headerlink" title="第八章 标准IO库"></a>第八章 标准IO库</h1><p>C++ 的输入／输出由标准库提供。标准库定义了一族类型，支持对文件和控制窗口等设备的读写（IO）。还定义了其他一些类型，使 string 对象能够像文件一样操作，从而使我们无须 IO 就能实现数据与字符之间的转换。这些 IO 类型都定义了如何读写内置数据类型的值。</p><a id="more"></a><h2 id="8-1-面向对象的标准库"><a href="#8-1-面向对象的标准库" class="headerlink" title="8.1 面向对象的标准库"></a>8.1 面向对象的标准库</h2><p>IO 类型在三个独立的头文件中定义：iostream 定义读写控制窗口的类型，fstream 定义读写已命名文件的类型，而 sstream 所定义的类型则用于读写存储在内存中的 string 对象。在 fstream 和 sstream 里定义的每种类型都是从 iostream 头文件中定义的相关类型派生而来。</p><p><strong>国际字符的支持</strong></p><p>标准库还定义了一组相关的类型，支持 wchar_t 类型。每个类都加上“w”前缀，以此与 char 类型的版本区分开来。</p><p><strong>IO 对象不可复制或赋值</strong></p><p>形参或返回类型也不能为流类型。如果需要传递或返回 IO 对象，则必须传递或返回指向该对象的指针或引用。</p><p>一般情况下，如果要传递IO对象以便对它进行读写，可用非const引用的方式传递这个流对象。对IO对象的读写会改变它的状态，因此引用必须是非const的。 </p><h2 id="8-2-条件状态"><a href="#8-2-条件状态" class="headerlink" title="8.2 条件状态"></a>8.2 条件状态</h2><p>IO 标准库管理一系列<strong>条件状态</strong>（condition state）成员，用来标记给定的 IO 对象是否处于可用状态，或者碰到了哪种特定的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">strm::iostate     机器相关的整型名，由各个 iostream 类定义，用于定义条件状态 </span><br><span class="line">strm::badbit      strm::iostate 类型的值，用于指出被破坏的流 </span><br><span class="line">strm::failbit     strm::iostate 类型的值，用于指出失败的 IO 操作 </span><br><span class="line">strm::eofbit      strm::iostate 类型的值，用于指出流已经到达文件结束符</span><br><span class="line">strm::goodbit     strm::iostate 类型的值，用于指出流未处于错误状态</span><br><span class="line">s.eof()           如果设置了流 s 的 eofbit 值，则该函数返回 true </span><br><span class="line">s.fail()          如果设置了流 s 的 failbit 值，则该函数返回 true </span><br><span class="line">s.bad()           如果设置了流 s 的 badbit 值，则该函数返回 true </span><br><span class="line">s.good()          如果流 s 处于有效状态，则该函数返回 true </span><br><span class="line">s.clear()         将流 s 中的所有状态值都重设为有效状态/复位，返回void</span><br><span class="line">s.clear(flag)     将流 s 中的某个指定条件状态设置为有效/复位。flag 的类型是strm::iostate，返回void</span><br><span class="line">s.setstate(flag)  将流 s 中对应条件状态位置位。flag 的类型是 strm::iostate，返回void</span><br><span class="line">s.rdstate()       返回流 s 的当前条件，返回值类型为 strm::iostate</span><br></pre></td></tr></table></figure><p>IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能，这个类型应作为一个位集合来使用。</p><p>badbit表示系统级错误，如不可恢复的读写错误，通常，一旦badbit被置位，流就无法使用了。发生可恢复错误后，failbit被置位，如期望读数值却读出一个字符等错误。如果到达文件结束位置，eofbit与failbit都会被置位。goodbit的值为0表示流未发生错误。若badbit、failbit和eofbit任何一个被置位，则检测流状态的条件会失败。</p><h2 id="8-3-输出缓冲区的管理"><a href="#8-3-输出缓冲区的管理" class="headerlink" title="8.3 输出缓冲区的管理"></a>8.3 输出缓冲区的管理</h2><p>每个 IO 对象管理一个缓冲区，用于存储程序读写的数据。</p><p>下面几种情况将导致缓冲区的内容被刷新，即写入到真实的输出设备或者文件： </p><ol><li><p>程序正常结束。作为main函数的return操作的一部分，将清空所有输出缓冲区。</p></li><li><p>缓冲区满时，缓冲区将会在写下一个值之前刷新。 </p></li><li><p>用操纵符显式地刷新缓冲区，例如行结束符endl。</p></li><li><p>在每次输出操作执行完后，用unitbuf操作符设置流的内部状态，从而清空缓冲区。默认cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</p></li><li><p>一个输出流可能被关联到另一个流。此时，当读写被关联的流时，关联到的流的缓冲区会被刷新，如默认cin与cerr都关联到cout。</p></li></ol><p>我们的程序已经使用过endl操纵符，用于输出一个换行符并刷新缓冲区。除此之外，C++语言还提供了另外两个类似的操纵符。第一个经常使用的flush，用于刷新流，但不在输出中添加任何字符。第二个则是比较少用的ends，这个操纵符在缓冲区中插入空字符null，然后后刷新它。</p><p><strong>unitbuf操纵符</strong></p><p>若需要每次输出操作后都刷新缓冲区，可使用unitbuf操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf &lt;&lt; &quot;first&quot; &lt;&lt; &quot; second&quot; &lt;&lt; nounitbuf; </span><br><span class="line">//等价于：</span><br><span class="line">cout &lt;&lt; &quot;first&quot; &lt;&lt; flush &lt;&lt; &quot; second&quot; &lt;&lt; flush</span><br></pre></td></tr></table></figure><p>nounitbuf 操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。</p><p><strong>关联输入输出流</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ostream *old_tie = cin.tie();  //返回指向原关联流的指针</span><br><span class="line">cin.tie(&amp;cerr);</span><br></pre></td></tr></table></figure><h2 id="8-4-文件输入输出"><a href="#8-4-文件输入输出" class="headerlink" title="8.4 文件输入输出"></a>8.4 文件输入输出</h2><p>fstream 头文件定义了三种支持文件 IO 的类型： </p><ol><li>ifstream，由 istream 派生而来，提供读文件的功能。 </li><li>ofstream，由 ostream 派生而来，提供写文件的功能。 </li><li>fstream，由 iostream 派生而来，提供读写同一个文件的功能。 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fstream file(&quot;123.txt&quot;);</span><br><span class="line">file.close();</span><br><span class="line">file.open(&quot;123.txt&quot;);</span><br><span class="line">file &lt;&lt; 12345;      //写入12345</span><br></pre></td></tr></table></figure><p>当一个fstream对象被销毁时，close会自动被调用。</p><p><strong>文件模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in        以读方式打开</span><br><span class="line">out       以写方式打开</span><br><span class="line">app       每次写操作前定位到文件末尾</span><br><span class="line">ate       打开文件后立即定位到文件末尾</span><br><span class="line">trunc     打开文件时清空已存在的文件流</span><br><span class="line">binary    以二进制模式进行 IO 操作</span><br></pre></td></tr></table></figure><p>如果需要重用文件流读写多个文件，必须在读另一个文件之前调用 clear 清除该流的状态。 </p><h2 id="8-5-字符串流"><a href="#8-5-字符串流" class="headerlink" title="8.5 字符串流"></a>8.5 字符串流</h2><p>stringstream strm;    创建自由的 stringstream 对象<br>stringstream strm(s); 创建存储 s 的副本的 stringstream 对象，其中 s 是 string 类型的对象<br>strm.str()  返回 strm 中存储的 string 类型对象<br>strm.str(s) 将 string 类型的 s 复制给 strm，返回 void </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ostringstream ostr;</span><br><span class="line">ostr &lt;&lt; 123;</span><br><span class="line">string line, word;</span><br><span class="line">while (getline(cin, line)) &#123;            //输入：ad fes</span><br><span class="line">istringstream strstream(line);</span><br><span class="line">while (strstream &gt;&gt; word) &#123;</span><br><span class="line">ostr &lt;&lt; word;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ostr.str();           //123adfes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第八章-标准IO库&quot;&gt;&lt;a href=&quot;#第八章-标准IO库&quot; class=&quot;headerlink&quot; title=&quot;第八章 标准IO库&quot;&gt;&lt;/a&gt;第八章 标准IO库&lt;/h1&gt;&lt;p&gt;C++ 的输入／输出由标准库提供。标准库定义了一族类型，支持对文件和控制窗口等设备的读写（IO）。还定义了其他一些类型，使 string 对象能够像文件一样操作，从而使我们无须 IO 就能实现数据与字符之间的转换。这些 IO 类型都定义了如何读写内置数据类型的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson13</title>
    <link href="https://zypsola.com/2018/11/01/C++Primer13/"/>
    <id>https://zypsola.com/2018/11/01/C++Primer13/</id>
    <published>2018-11-01T15:49:11.000Z</published>
    <updated>2018-11-02T12:53:42.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><h2 id="7-8-重载函数"><a href="#7-8-重载函数" class="headerlink" title="7.8 重载函数"></a>7.8 重载函数</h2><p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为<strong>重载函数</strong>。 </p><a id="more"></a><p>任何程序都仅有一个 main 函数的实例。main 函数不能重载。 </p><p>如果两个函数声明的返回类型和形参表完全匹配，则将第二个函数声明视为第一个的重复声明。如果两个函数的形参表完全相同，但返回类型不同，则第二个声明是错误的。</p><p>有些看起来不相同的形参表本质上是相同的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(const Account &amp;acct); </span><br><span class="line">   Record lookup(const Account&amp;);</span><br><span class="line"></span><br><span class="line">   typedef Phone Telno; </span><br><span class="line">   Record lookup(const Phone&amp;); </span><br><span class="line">   Record lookup(const Telno&amp;);</span><br><span class="line"></span><br><span class="line">   Record lookup(const Phone&amp;, const Name&amp;);</span><br><span class="line">   Record lookup(const Phone&amp;, const Name&amp; = &quot;&quot;); </span><br><span class="line"></span><br><span class="line">   Record lookup(Phone); </span><br><span class="line">   Record lookup(const Phone);</span><br></pre></td></tr></table></figure><h3 id="7-8-1-重载与作用域"><a href="#7-8-1-重载与作用域" class="headerlink" title="7.8.1 重载与作用域"></a>7.8.1 重载与作用域</h3><p>一般的作用域规则同样适用于重载函数名。如果局部地声明一个函数，则该函数将屏蔽而不是重载在外层作用域中声明的同名函数。由此推论，每一个版本的重载函数都应在同一个作用域中声明。 </p><h3 id="7-8-2-函数匹配与实参转换"><a href="#7-8-2-函数匹配与实参转换" class="headerlink" title="7.8.2 函数匹配与实参转换"></a>7.8.2 函数匹配与实参转换</h3><p>函数<strong>重载确定</strong>，即<strong>函数匹配</strong>是将函数调用与重载函数集合中的一个函数相关联的过程。通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参做比较，编译器实现该调用与函数的匹配。匹配结果有三种可能： </p><ol><li><p>编译器找到与实参<strong>最佳匹配</strong>的函数，并生成调用该函数的代码。 </p></li><li><p>找不到形参与函数调用的实参匹配的函数，在这种情况下，编译器将给出编译错误信息。 </p></li><li><p>存在多个与实参匹配的函数，但没有一个是明显的最佳选择。这种情况也是，该调用具有<strong>二义性</strong>。 </p></li></ol><h3 id="7-8-3-重载确定的三个步骤"><a href="#7-8-3-重载确定的三个步骤" class="headerlink" title="7.8.3 重载确定的三个步骤"></a>7.8.3 重载确定的三个步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void f(); </span><br><span class="line">void f(int); </span><br><span class="line">void f(int, int); </span><br><span class="line">void f(double, double = 3.14); </span><br><span class="line">f(5.6);  // calls void f(double, double)</span><br></pre></td></tr></table></figure><p>函数重载确定的第一步是确定该调用所考虑的重载函数集合，该集合中的函数称为<strong>候选函数</strong>。</p><p>第二步是从候选函数中选择一个或多个函数，它们能够用该调用中指定的实参来调用。因此，选出来的函数称为<strong>可行函数</strong>。可行函数必须满足两个条件：第一，函数的形参个数与该调用的实参个数相同；第二，每一个实参的类型必须与对应形参的类型匹配，或者可被隐式转换为对应的形参类型。 </p><p>如果函数具有默认实参，则调用该函数时，所用的实参可能比实际需要的少。默认实参也是实参，在函数匹配过程中，它的处理方式与其他实参一样。 </p><p>函数重载确定的第三步是确定与函数调用中使用的实际参数匹配最佳的可行函数。这个过程考虑函数调用中的每一个实参，选择对应形参与之最匹配的一个或多个可行函数。其原则是实参类型与形参类型越接近则匹配越佳。因此，实参类型与形参类型之间的精确类型匹配比需要转换的匹配好。 </p><p>如果函数调用使用了两个或两个以上的显式实参，则函数匹配会更加复杂。假设有两样的名为 f 的函数，分析下面的函数调用： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(42, 2.56);</span><br></pre></td></tr></table></figure><p>在本例中，可行函数是 f(int, int) 和 f(double, double)。接下来，编译器通过依次检查每一个实参来决定哪个或哪些函数匹配最佳。如果有且仅有一个函数满足下列条件，则匹配成功： </p><ol><li><p>其每个实参的匹配都不劣于其他可行函数需要的匹配。 </p></li><li><p>至少有一个实参的匹配优于其他可行函数提供的匹配。 </p></li></ol><p>这个调用有二义性：每个可行函数都对函数调用的一个实参实现更好的匹配。编译器将产生错误。解决这样的二义性，可通过显式的强制类型转换强制函数匹配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(static_cast&lt;double&gt;(42), 2.56);  // calls f(double, double) </span><br><span class="line">f(42, static_cast&lt;int&gt;(2.56));     // calls f(int, int)</span><br></pre></td></tr></table></figure><h3 id="7-8-4-实参类型转换"><a href="#7-8-4-实参类型转换" class="headerlink" title="7.8.4 实参类型转换"></a>7.8.4 实参类型转换</h3><p>为了确定最佳匹配，编译器将实参类型到相应形参类型转换划分等级。转换等级以降序排列如下： </p><ol><li><p>精确匹配。实参与形参类型相同。 </p></li><li><p>通过类型提升实现的匹配。 </p></li><li><p>通过标准转换实现的匹配。 </p></li><li><p>通过类类型转换实现的匹配。 </p></li></ol><p>必须注意的一个重点是较小的整型提升为 int 型。假设有两个函数，一个的形参为 int 型，另一个的形参则是 short 型。对于任意整型的实参值，int 型版本都是优于 short 型版本的较佳匹配，即使从形式上看 short 型版本的匹配较佳:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void ff(int); </span><br><span class="line">void ff(short); </span><br><span class="line">ff(&apos;a&apos;);    // char promotes to int, so matches ff(int)</span><br></pre></td></tr></table></figure><p>字面值常量 3.14 的类型为 double。这种类型既可转为 long 型也可转为 float 型。由于两者都是可行的标准转换，因此该调用具有二义性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern void manip(long); </span><br><span class="line">extern void manip(float); </span><br><span class="line">manip(3.14);  // error: ambiguous call</span><br></pre></td></tr></table></figure><p><strong>参数匹配和枚举类型</strong></p><p>回顾枚举类型enum，我们知道这种类型的对象只能用同一枚举类型的另一个对象或一个枚举成员进行初始化。整数对象即使具有与枚举元素相同的值也不能用于调用期望获得枚举类型实参的函数。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Tokens &#123;INLINE = 128, VIRTUAL = 129&#125;; </span><br><span class="line">void ff(Tokens); </span><br><span class="line">void ff(int); </span><br><span class="line">int main() &#123; </span><br><span class="line">    Tokens curTok = INLINE; </span><br><span class="line">    ff(128);    // exactly matches ff(int) </span><br><span class="line">    ff(INLINE); // exactly matches ff(Tokens) </span><br><span class="line">    ff(curTok); // exactly matches ff(Tokens) </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然无法将整型值传递给枚举类型的形参，但可以将枚举值传递给整型形参。此时，枚举值被提升为 int 型或更大的整型。具体的提升类型取决于枚举成员的值。</p><p><strong>重载和const形参</strong></p><p>仅当形参是引用或指针时，形参是否为 const 才有影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun(int &amp;a)&#123;return ++a;&#125;</span><br><span class="line">int fun(const int &amp;a) &#123;return a;&#125;</span><br><span class="line"></span><br><span class="line">const int a(5);</span><br><span class="line">int b(5);</span><br><span class="line">cout &lt;&lt; fun(a) &lt;&lt; endl;   //5</span><br><span class="line">cout &lt;&lt; fun(b) &lt;&lt; endl;   //6</span><br></pre></td></tr></table></figure><p>不能基于指针本身是否为 const 来实现函数的重载： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *a)</span><br><span class="line">int fun(int *const a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fun(int *a)&#123;return ++*a;&#125;</span><br><span class="line">int fun(const int *a) &#123;return *a;&#125;</span><br><span class="line"></span><br><span class="line">const int a(5);</span><br><span class="line">int b(5);</span><br><span class="line">cout &lt;&lt; fun(&amp;a) &lt;&lt; endl;   //5</span><br><span class="line">cout &lt;&lt; fun(&amp;b) &lt;&lt; endl;   //6</span><br></pre></td></tr></table></figure><h2 id="7-9-指向函数的指针"><a href="#7-9-指向函数的指针" class="headerlink" title="7.9 指向函数的指针"></a>7.9 指向函数的指针</h2><p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int(*pf)(int, int);</span><br><span class="line"></span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pf = &amp;sum;      //or pf = sum;</span><br><span class="line">cout &lt;&lt; pf(3, 4) &lt;&lt; endl;   //7</span><br><span class="line">cout &lt;&lt; (*pf)(3, 4) &lt;&lt; endl;  //7</span><br></pre></td></tr></table></figure><p><strong>用 typedef 简化函数指针的定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef int(*pf)(int, int);</span><br><span class="line"></span><br><span class="line">int sum(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pf p = &amp;sum;    //or pf p = sum;</span><br><span class="line">cout &lt;&lt; p(3, 4) &lt;&lt; endl;    //7</span><br><span class="line">cout &lt;&lt; (*p)(3, 4) &lt;&lt; endl;   //7</span><br></pre></td></tr></table></figure><p><strong>函数指针形参</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int sum2(int v1, int v2, int a(int, int)) &#123;     //or int (*a)(int, int) or pf a</span><br><span class="line">return a(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pf p = sum;</span><br><span class="line">cout &lt;&lt; sum2(3, 4, p) &lt;&lt; endl;   //7</span><br></pre></td></tr></table></figure><p><strong>返回指向函数的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int(*sum3())(int, int) &#123;     //or pf sum3() &#123;...&#125;</span><br><span class="line">pf p = sum;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">pf p = sum;</span><br><span class="line">cout &lt;&lt; sum2(3, 4, sum3()) &lt;&lt; endl;   //7</span><br></pre></td></tr></table></figure><p><strong>指向重载函数的指针</strong></p><p>C++ 语言允许使用函数指针指向重载的函数。指针的类型必须与重载函数的一个版本精确匹配。如果没有精确匹配的函数，则对该指针的初始化或赋值都将导致编译错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第七章-函数&quot;&gt;&lt;a href=&quot;#第七章-函数&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数&quot;&gt;&lt;/a&gt;第七章 函数&lt;/h1&gt;&lt;h2 id=&quot;7-8-重载函数&quot;&gt;&lt;a href=&quot;#7-8-重载函数&quot; class=&quot;headerlink&quot; title=&quot;7.8 重载函数&quot;&gt;&lt;/a&gt;7.8 重载函数&lt;/h2&gt;&lt;p&gt;出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为&lt;strong&gt;重载函数&lt;/strong&gt;。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson12</title>
    <link href="https://zypsola.com/2018/10/31/C++Primer12/"/>
    <id>https://zypsola.com/2018/10/31/C++Primer12/</id>
    <published>2018-10-31T09:09:24.000Z</published>
    <updated>2018-11-01T15:48:57.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h1><p>函数可以看作程序员定义的操作。与内置操作符相同的是，每个函数都会实现一系列的计算，然后（大多数时候）生成一个计算结果。但与操作符不同的是，函数有自己的函数名，而且操作数没有数量限制。与操作符一样，函数可以重载，这意味着同样的函数名可以对应多个不同的函数。 </p><a id="more"></a><h2 id="7-1-函数的定义"><a href="#7-1-函数的定义" class="headerlink" title="7.1 函数的定义"></a>7.1 函数的定义</h2><p>函数由函数名以及一组操作数类型唯一地表示。函数的操作数，也即<strong>形参</strong>。函数执行的运算在<strong>函数体</strong>中定义。每个函数都有<strong>返回类型</strong>。 </p><p><strong>函数的调用</strong></p><p>C++ 语言使用<strong>调用操作符</strong>（圆括号）实现函数的调用。调用操作符的操作数是函数名和一组（可能为空）由逗号分隔的<strong>实参</strong>。</p><p>函数调用做了两件事情：用对应的实参初始化函数的形参，并将控制权转移给被调用函数。主调函数挂起，被调函数开始执行。函数的运行以形参的（隐式）定义和初始化开始。</p><h3 id="7-1-1-函数返回类型"><a href="#7-1-1-函数返回类型" class="headerlink" title="7.1.1 函数返回类型"></a>7.1.1 函数返回类型</h3><p>函数的返回类型可以是内置类型、类类型、复合类型、void。</p><p>函数不能返回另一个函数或者内置数组类型。</p><h3 id="7-1-2-函数形参表"><a href="#7-1-2-函数形参表" class="headerlink" title="7.1.2 函数形参表"></a>7.1.2 函数形参表</h3><p>函数形参表可以为空，但不能省略。没有任何形参的函数可以用空形参表或含有单个关键字 void 的形参表来表示。</p><p>如果两个参数具有相同的类型，则其类型必须重复声明。</p><h2 id="7-2-参数传递"><a href="#7-2-参数传递" class="headerlink" title="7.2 参数传递"></a>7.2 参数传递</h2><p>形参的初始化与变量的初始化一样：如果形参具有非引用类型，则复制实参的值，如果形参为引用类型，则它只是实参的别名。 </p><h3 id="7-2-1-非引用形参"><a href="#7-2-1-非引用形参" class="headerlink" title="7.2.1 非引用形参"></a>7.2.1 非引用形参</h3><p>普通的非引用类型的参数通过复制对应的实参实现初始化。</p><p><strong>指针形参</strong></p><p>如果函数形参是非 const 类型的指针，则函数可通过指针实现赋值，修改指针所指向对象的值。</p><p>如果保护指针指向的值，则形参需定义为指向 const 对象的指针。</p><h3 id="7-2-2-引用形参"><a href="#7-2-2-引用形参" class="headerlink" title="7.2.2 引用形参"></a>7.2.2 引用形参</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;v1, int &amp;v2) </span><br><span class="line">&#123; </span><br><span class="line">    int tmp = v2; </span><br><span class="line">    v2 = v1; </span><br><span class="line">    v1 = tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用引用形参返回额外的信息</strong></p><p><strong>利用const引用避免复制</strong></p><p>如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为 const 引用。 </p><p><strong>传递指针的引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ptrswap(int *&amp;v1, int *&amp;v2) </span><br><span class="line">&#123; </span><br><span class="line">    int *tmp = v2; </span><br><span class="line">    v2 = v1; </span><br><span class="line">    v1 = tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-3-vector和其他容器类型的形参"><a href="#7-2-3-vector和其他容器类型的形参" class="headerlink" title="7.2.3 vector和其他容器类型的形参"></a>7.2.3 vector和其他容器类型的形参</h3><p>从避免复制 vector 的角度出发，应考虑将形参声明为引用类型，C++ 倾向于通过传递指向容器中元素的迭代器来传递容器。</p><h3 id="7-2-4-数组形参"><a href="#7-2-4-数组形参" class="headerlink" title="7.2.4 数组形参"></a>7.2.4 数组形参</h3><p>数组有两个特殊的性质：一是不能复制数组；二是使用数组名字时，数组名会自动转化为指向其第一个元素的指针。</p><p><strong>数组形参的定义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(int *a)</span><br><span class="line">void fun(int a[])</span><br><span class="line">void fun(int a[10])</span><br></pre></td></tr></table></figure><p>以上三种定义是等价的，形参类型都是 int*。</p><p>编译器忽略为任何数组形参指定的长度。当编译器检查数组形参关联的实参时，它只会检查实参是不是指针、指针的类型和数组元素的类型时是否匹配，而不会检查数组的长度。 </p><p><strong>通过引用传递数组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void fun(int (&amp;a)[10])</span><br></pre></td></tr></table></figure><p>数组形参可声明为数组的引用。如果形参是数组的引用，数组大小成为形参和实参类型的一部分。编译器检查数组的实参的大小与形参的大小是否匹配。</p><p><strong>多维数组的传递</strong></p><p>所谓多维数组实际是指数组的数组。 </p><p>多维数组的元素本身就是数组。除了第一维以外的所有维的长度都是元素类型的一部分，必须明确指定:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(int (*a)[10])</span><br><span class="line">void fun(int a[][10])</span><br><span class="line">void fun(int a[5][10])</span><br></pre></td></tr></table></figure><h3 id="7-2-5-传递给函数的数组的处理"><a href="#7-2-5-传递给函数的数组的处理" class="headerlink" title="7.2.5 传递给函数的数组的处理"></a>7.2.5 传递给函数的数组的处理</h3><p>任何处理数组的程序都要确保程序停留在数组的边界内。</p><p><strong>使用标准库规范:</strong>传递指向数组第一个和最后一个元素的下一个位置的指针。</p><p><strong>显式传递表示数组大小的形参</strong>。</p><h3 id="7-2-6-main-处理命令行选项"><a href="#7-2-6-main-处理命令行选项" class="headerlink" title="7.2.6 main: 处理命令行选项"></a>7.2.6 main: 处理命令行选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">int main(int argc, char **argv)</span><br></pre></td></tr></table></figure><p>第二个形参 argv 是一个 C 风格字符串数组。第一个形参 argc 则用于传递该数组中字符串的个数。</p><h2 id="7-3-return语句"><a href="#7-3-return语句" class="headerlink" title="7.3 return语句"></a>7.3 return语句</h2><p>return 语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。</p><p>返回类型不是 void 的函数必须返回一个值，但此规则有一个例外情况：允许主函数 main 没有返回值就可结束。如果程序控制执行到主函数 main 的最后一个语句都还没有返回，那么编译器会隐式地插入返回 0 的语句。 </p><p>为了使返回值独立于机器，cstdlib 头文件定义了两个预处理变量，分别用于表示程序运行成功和失败： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdlib&gt; </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    if (some_failure) </span><br><span class="line">        return EXIT_FAILURE; </span><br><span class="line">    else </span><br><span class="line">        return EXIT_SUCCESS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>返回引用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int &amp;fun(int &amp;a) &#123;</span><br><span class="line">return ++a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不能返回局部对象的引用</strong></p><p>返回引用的函数返回一个左值。因此，这样的函数可用于任何要求使用左值的地方。</p><p>如果不希望引用返回值被修改，返回值应该声明为 const。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int &amp;fun1(int &amp;a)</span><br></pre></td></tr></table></figure><p><strong>递归</strong></p><p>直接或间接调用自己的函数称为<strong>递归函数</strong>。</p><h2 id="7-4-函数声明"><a href="#7-4-函数声明" class="headerlink" title="7.4 函数声明"></a>7.4 函数声明</h2><p>与变量的定义类似，函数的声明也可以和函数的定义分离；一个函数只能定义一次，但是可声明多次。 </p><p>函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型，但是不必对形参命名。这三个元素被称为<strong>函数原型</strong>，函数原型描述了函数的接口。</p><p><strong>在头文件中提供函数声明</strong></p><p>变量可在头文件中声明而在源文件中定义。同理，函数也应当在头文件中声明，并在源文件中定义。 </p><p>定义函数的源文件应包含声明该函数的头文件。</p><p>将提供函数声明头文件包含在定义该函数的源文件中，可使编译器能检查该函数的定义和声明时是否一致。</p><h3 id="7-4-1-默认实参"><a href="#7-4-1-默认实参" class="headerlink" title="7.4.1 默认实参"></a>7.4.1 默认实参</h3><p>默认实参是通过给形参表中的形参提供明确的初始值来指定的。程序员可为一个或多个形参定义默认值。但是，如果有一个形参具有默认实参，那么，它后面所有的形参都必须有默认实参。</p><p>函数调用的实参按位置解析，默认实参只能用来替换函数调用缺少的尾部实参。</p><p>设计带有默认实参的函数，其中部分工作就是排列形参，使最少使用默认实参的形参排在最前，最可能使用默认实参的形参排在最后。 </p><p><strong>指定默认实参的约束</strong></p><p>既可以在函数声明也可以在函数定义中指定默认实参。但是，在一个文件中，只能为一个形参指定默认实参一次。</p><p>通常，应在函数声明中指定默认实参，并将该声明放在合适的头文件中。 </p><p>如果在函数定义的形参表中提供默认实参，那么只有在包含该函数定义的源文件中调用该函数时，默认实参才是有效的。 </p><h2 id="7-5-局部对象"><a href="#7-5-局部对象" class="headerlink" title="7.5 局部对象"></a>7.5 局部对象</h2><p>在 C++ 语言中，每个名字都有作用域，而每个对象都有生命期。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。 </p><h3 id="7-5-1-自动对象"><a href="#7-5-1-自动对象" class="headerlink" title="7.5.1 自动对象"></a>7.5.1 自动对象</h3><p>只有当定义它的函数被调用时才存在的对象称为<strong>自动对象</strong>。自动对象在每次调用函数时创建和撤销。 </p><h3 id="7-5-2-静态局部对象"><a href="#7-5-2-静态局部对象" class="headerlink" title="7.5.2 静态局部对象"></a>7.5.2 静态局部对象</h3><p>一个变量如果位于函数的作用域内，但生命期跨越了这个函数的多次调用。则应该将这样的对象定义为 static（静态的）。 </p><p>static 局部对象确保不迟于在程序执行流程第一次经过该对象的定义语句时进行初始化。这种对象一旦被创建，在程序结束前都不会撤销。当定义静态局部对象的函数结束时，静态局部对象不会撤销。</p><h2 id="7-6-内联函数"><a href="#7-6-内联函数" class="headerlink" title="7.6 内联函数"></a>7.6 内联函数</h2><p><strong>inline函数避免函数调用的开销</strong></p><p>一般来说，内联机制适用于优化小的、只有几行的而且经常被调用的函数。</p><p><strong>把inline函数放入头文件</strong></p><p>内联函数应该在头文件中定义，这一点不同于其他函数。 </p><h2 id="7-7-类的成员函数"><a href="#7-7-类的成员函数" class="headerlink" title="7.7 类的成员函数"></a>7.7 类的成员函数</h2><h3 id="7-7-1-定义成员函数的函数体"><a href="#7-7-1-定义成员函数的函数体" class="headerlink" title="7.7.1 定义成员函数的函数体"></a>7.7.1 定义成员函数的函数体</h3><p>类的所有成员都必须在类定义的花括号里面声明，此后，就不能再为类增加任何成员。类的成员函数既可以在类的定义内也可以在类的定义外定义。</p><p>编译器隐式地将在类内定义的成员函数当作内联函数。</p><p><strong>成员函数含有额外的、隐含的形参</strong></p><p>每个成员函数都有一个额外的、隐含的形参将该成员函数与调用该函数的类对象捆绑在一起。</p><p><strong>this指针的引入</strong></p><p>每个成员函数（除了 static 成员函数外）都有一个额外的、隐含的形参 this。在调用成员函数时，形参 this 初始化为调用函数的对象的地址。为了理解成员函数的调用，可考虑下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total.same_isbn(trans);</span><br></pre></td></tr></table></figure><p>就如编译器这样重写这个函数调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item::same_isbn(&amp;total, trans);</span><br></pre></td></tr></table></figure><p><strong>const成员函数的引入</strong></p><p>现在，可以理解跟在 Sales_item 成员函数声明的形参表后面的 const 所起的作用了：const 改变了隐含的 this 形参的类型。在调用 total.same_isbn(trans) 时，隐含的 this 形参将是一个指向 total 对象的 const Sales_Item* 类型的指针。</p><p>用这种方式使用 const 的函数称为常量成员函数。由于 this 是指向 const 对象的指针，const 成员函数不能修改调用该函数的对象。因此，函数 avg_price 和函数 same_isbn 只能读取而不能修改调用它们的对象的数据成员。 </p><p>const 对象、指向 const 对象的指针或引用只能用于调用其 const 成员函数，如果尝试用它们来调用非 const 成员函数，则是错误的。 </p><p><strong>this指针的使用</strong></p><p>在成员函数中，不必显式地使用 this 指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用，都被假定为通过指针 this 实现的引用。</p><h3 id="7-7-2-在类外定义成员函数"><a href="#7-7-2-在类外定义成员函数" class="headerlink" title="7.7.2 在类外定义成员函数"></a>7.7.2 在类外定义成员函数</h3><p>在类的定义外面定义成员函数必须指明它们是类的成员。</p><h3 id="7-7-3-编写-Sales-item-类的构造函数"><a href="#7-7-3-编写-Sales-item-类的构造函数" class="headerlink" title="7.7.3 编写 Sales_item 类的构造函数"></a>7.7.3 编写 Sales_item 类的构造函数</h3><p><strong>构造函数</strong>是特殊的成员函数，与其他成员函数不同，构造函数和类同名，而且没有返回类型。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。 </p><p><strong>构造函数的定义</strong>：和其他成员函数一样，构造函数也必须在类中声明，但是可以在类中或类外定义。</p><p>构造函数是放在类的 public 部分的。通常构造函数会作为类的接口的一部分，这个例子也是这样。毕竟，我们希望使用类 Sales_item 的代码可以定义和初始化类 Sales_item 的对象。</p><p><strong>构造函数和初始化列表</strong></p><p>构造函数的初始化列表为类的一个或多个数据成员指定初值。它跟在构造函数的形参表之后，以冒号开始。构造函数的初始化式是一系列成员名，每个成员后面是括在圆括号中的初始值。多个成员的初始化用逗号分隔。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(const std::string &amp;book):</span><br><span class="line">          isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第七章-函数&quot;&gt;&lt;a href=&quot;#第七章-函数&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数&quot;&gt;&lt;/a&gt;第七章 函数&lt;/h1&gt;&lt;p&gt;函数可以看作程序员定义的操作。与内置操作符相同的是，每个函数都会实现一系列的计算，然后（大多数时候）生成一个计算结果。但与操作符不同的是，函数有自己的函数名，而且操作数没有数量限制。与操作符一样，函数可以重载，这意味着同样的函数名可以对应多个不同的函数。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson11</title>
    <link href="https://zypsola.com/2018/10/29/C++Primer11/"/>
    <id>https://zypsola.com/2018/10/29/C++Primer11/</id>
    <published>2018-10-29T12:51:31.000Z</published>
    <updated>2018-10-31T09:17:42.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-语句"><a href="#第六章-语句" class="headerlink" title="第六章 语句"></a>第六章 语句</h1><p>语句类似于自然语言中的句子。C++ 语言既有只完成单一任务的简单语句，也有作为一个单元执行的由一组语句组成的复合语句。和大多数语言一样，C++ 也提供了实现条件分支结构的语句以及重复地执行同一段代码的循环结构。本章将详细讨论 C++ 所支持的语句。</p><a id="more"></a><p>通常情况下，语句是顺序执行的。但是，除了最简单的程序外，只有顺序执行往往并不足够。为此，C++ 定义了一组控制流语句，允许有条件地执行或者重复地执行某部分功能。if 和 switch 语句提供了条件分支结构，而 for、while 和 do while 语句则支持重复执行的功能。后几种语句常称为循环或者迭代语句。 </p><h2 id="6-1-简单语句"><a href="#6-1-简单语句" class="headerlink" title="6.1 简单语句"></a>6.1 简单语句</h2><p><strong>空语句</strong></p><p>程序语句最简单的形式是空语句，它使用以下的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="6-2-声明语句"><a href="#6-2-声明语句" class="headerlink" title="6.2 声明语句"></a>6.2 声明语句</h2><p>在 C++ 中，对象或类的定义或声明也是语句。尽管定义语句这种说法也许更准确些，但定义语句经常被称为声明语句。</p><h2 id="6-3-复合语句"><a href="#6-3-复合语句" class="headerlink" title="6.3 复合语句"></a>6.3 复合语句</h2><p><strong>复合语句</strong>，通常被称为<strong>块</strong>，是用一对花括号括起来的语句序列（也可能是空的）。块标识了一个作用域，在块中引入的名字只能在该块内部或嵌套在块中的子块里访问。</p><h2 id="6-4-语句作用域"><a href="#6-4-语句作用域" class="headerlink" title="6.4 语句作用域"></a>6.4 语句作用域</h2><p>在语句的控制结构中定义的变量，仅在定义它们的块语句结束前有效。这种变量的作用域限制在语句体内。通常，语句体本身就是一个块语句，其中也可能包含了其他的块。一个在控制结构里引入的名字是该语句的局部变量，其作用域局限在语句内部。 </p><h2 id="6-5-if语句"><a href="#6-5-if语句" class="headerlink" title="6.5 if语句"></a>6.5 if语句</h2><p><strong>if语句</strong>根据特定表达式是否为真来有条件地执行另一个语句。if 语句有两种形式：其中一种带 else 分支而另一种则没有。</p><p><strong>悬垂else</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (a)</span><br><span class="line">if (b);</span><br><span class="line">else &#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有语言的 if 语句都普通存在着潜在的二义性。这种情况往往称为悬垂 else 问题，产生于一个语句包含的 if 子句多于 else 子句时：对于每一个 else，究竟它们归属哪个 if 语句？ </p><p>C++ 中悬垂 else 问题带来的二义性，通过将 else 匹配给最后出现的尚未匹配的 if 子句来解决。</p><h2 id="6-6-switch语句"><a href="#6-6-switch语句" class="headerlink" title="6.6 switch语句"></a>6.6 switch语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char a;</span><br><span class="line">switch (a)</span><br><span class="line">&#123;</span><br><span class="line">case &apos;a&apos;:break;</span><br><span class="line">case &apos;b&apos;:break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表达式与其中一个 case 标号的值匹配，则程序将从该标号后面的第一个语句开始依次执行各个语句，直到 switch 结束或遇到 break 语句为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (ch)</span><br><span class="line">&#123;</span><br><span class="line">case &apos;a&apos;: case &apos;e&apos;: case &apos;i&apos;: case &apos;o&apos;: case &apos;u&apos;: &#123;</span><br><span class="line">++vowelCnt;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case 标号必须是整型常量表达式,如果两个 case 标号具有相同的值，同样也会导致编译时的错误。</p><h2 id="6-7-while-语句"><a href="#6-7-while-语句" class="headerlink" title="6.7 while 语句"></a>6.7 while 语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whlie(cond)&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-8-for-循环语句"><a href="#6-8-for-循环语句" class="headerlink" title="6.8 for 循环语句"></a>6.8 for 循环语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 for 语句的 init-statement 中定义多个对象；但是不管怎么样，该处只能出现一个语句，因此所有的对象必须具有相同的一般类型。</p><h2 id="6-9-do-while"><a href="#6-9-do-while" class="headerlink" title="6.9 do while"></a>6.9 do while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">//...</span><br><span class="line">&#125; while (cond);</span><br></pre></td></tr></table></figure><p>不可以在循环条件cond中定义变量。</p><h2 id="6-10-break-语句"><a href="#6-10-break-语句" class="headerlink" title="6.10 break 语句"></a>6.10 break 语句</h2><p>用于结束最近的 while、do while、for 或 switch 语句，并将程序的执行权传递给紧接在被终止语句之后的语句。</p><h2 id="6-11-continue-语句"><a href="#6-11-continue-语句" class="headerlink" title="6.11 continue 语句"></a>6.11 continue 语句</h2><p>导致最近的循环语句的当次迭代提前结束。</p><h2 id="6-12-goto-语句"><a href="#6-12-goto-语句" class="headerlink" title="6.12 goto 语句"></a>6.12 goto 语句</h2><p>goto 语句提供了函数内部的无条件跳转，实现从 goto 语句跳转到同一函数内某个带标号的语句。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">goto lable;</span><br><span class="line">lable:;</span><br></pre></td></tr></table></figure><p>goto 语句不能跨越变量的定义语句向前跳转。向前跳过未执行的变量定义语句，意味着变量可能在没有定义的情况下使用。</p><p>向后跳过已经执行的变量定义语句则是合法的。向后跳回到一个变量定义之前，则会使系统撤销这个变量，然后再重新创建它。</p><h2 id="6-13-try-块和异常处理"><a href="#6-13-try-块和异常处理" class="headerlink" title="6.13 try 块和异常处理"></a>6.13 try 块和异常处理</h2><p>异常机制提供程序中错误检测与错误处理部分之间的通信。C++ 的异常处理中包括： </p><ol><li><p><strong>throw 表达式</strong>，错误检测部分使用这种表达式来说明遇到了不可处理的错误。可以说，throw <strong>引发</strong>了异常条件。 </p></li><li><p><strong>try 块</strong>，错误处理部分使用它来处理异常。try 语句块以 try 关键字开始，并以一个或多个 catch 子句结束。在 try 块中执行的代码所抛出（throw）的异常，通常会被其中一个 catch 子句处理。由于它们“处理”异常，catch 子句也称为处理代码。 </p></li><li><p>由标准库定义的一组<strong>异常类</strong>，用来在 throw 和相应的 catch 之间传递有关的错误信息。 </p></li></ol><h3 id="6-13-1-throw-表达式"><a href="#6-13-1-throw-表达式" class="headerlink" title="6.13.1 throw 表达式"></a>6.13.1 throw 表达式</h3><p>系统通过 throw 表达式抛出异常。throw 表达式由关键字 throw 以及尾随的表达式组成，通常以分号结束，这样它就成为了表达式语句。throw 表达式的类型决定了所抛出异常的类型。 </p><h3 id="6-13-2-try-块"><a href="#6-13-2-try-块" class="headerlink" title="6.13.2 try 块"></a>6.13.2 try 块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">try &#123;</span><br><span class="line">if (a) &#123;</span><br><span class="line">throw runtime_error(&quot;aaaaaaaa!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (runtime_error err) &#123;</span><br><span class="line">cout &lt;&lt; err.what();         //aaaaaaaa!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数在寻找处理代码的过程中退出</strong></p><p>在复杂的系统中，程序的执行路径也许在遇到抛出异常的代码之前，就已经经过了多个 try 块。例如，一个 try 块可能调用了包含另一 try 块的函数，它的 try 块又调用了含有 try 块的另一个函数，如此类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int aa()</span><br><span class="line">&#123;</span><br><span class="line">int a = 1;</span><br><span class="line">try &#123;</span><br><span class="line">if (a) &#123;</span><br><span class="line">throw runtime_error(&quot;aaaa!&quot;);</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (logic_error err) &#123;</span><br><span class="line">cout &lt;&lt; err.what() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">return !a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (int b = aa()) &#123;</span><br><span class="line">cout &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">throw runtime_error(&quot;bbbb!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (runtime_error err) &#123;</span><br><span class="line">cout &lt;&lt; err.what() &lt;&lt; err.what() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aa()中a=1时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa!aaaa!</span><br></pre></td></tr></table></figure><p>aa()中a=0时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:0</span><br><span class="line">b:1</span><br><span class="line">bbbb!bbbb!</span><br></pre></td></tr></table></figure><p>抛出一个异常时，首先要搜索的是抛出异常的函数。如果没有找到匹配的 catch，则终止这个函数的执行，并在调用这个函数的函数中寻找相配的 catch。如果仍然没有找到相应的处理代码，该函数同样要终止，搜索调用它的函数。如此类推，继续按执行路径回退，直到找到适当类型的 catch 为止。 </p><p>如果不存在处理该异常的 catch 子句，程序的运行就要跳转到名为 terminate 的标准库函数，该函数在 exception 头文件中定义。这个标准库函数的行为依赖于系统，通常情况下，它的执行将导致程序非正常退出。 </p><h3 id="6-13-3-标准异常"><a href="#6-13-3-标准异常" class="headerlink" title="6.13.3 标准异常"></a>6.13.3 标准异常</h3><ol><li><p>exception 头文件定义了最常见的异常类，它的类名是 exception。这个类只通知异常的产生，但不会提供更多的信息。 </p></li><li><p>stdexcept 头文件定义了几种常见的异常类。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">runtime_error     运行时错误：仅在运行时才能检测到问题 </span><br><span class="line">range_error       运行时错误：生成的结果超出了有意义的值域范围 </span><br><span class="line">overflow_error    运行时错误：计算上溢 </span><br><span class="line">underflow_error   运行时错误：计算下溢 </span><br><span class="line">logic_error       逻辑错误：可在运行前检测到问题 </span><br><span class="line">domain_error      逻辑错误：参数的结果值不存在 </span><br><span class="line">invalid_argument  逻辑错误：不合适的参数 </span><br><span class="line">length_error      逻辑错误：试图生成一个超出该类型最大长度的对象</span><br><span class="line">out_of_range      逻辑错误：使用一个超出有效范围的值</span><br></pre></td></tr></table></figure><ol start="3"><li><p>new 头文件定义了 bad_alloc 异常类型，提供因无法分配内在而由 new 抛出的异常。 </p></li><li><p>type_info 头文件定义了 bad_cast 异常类型。</p></li></ol><h2 id="6-14-使用预处理器进行调试"><a href="#6-14-使用预处理器进行调试" class="headerlink" title="6.14 使用预处理器进行调试"></a>6.14 使用预处理器进行调试</h2><p>程序所包含的调试代码仅在开发过程中执行。当应用程序已经完成，并且准备提交时，就会将调试代码关闭。可使用 <strong>NDEBUG</strong> 预处理变量实现有条件的调试代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef NDEBUG </span><br><span class="line">cerr &lt;&lt; &quot;err&quot; &lt;&lt; endl; </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如果 NDEBUG 已经定义了，那么程序执行时将会跳过 #ifndef 和 #endif 之间的代码。 </p><p>预处理器还定义了其余四种在调试时非常有用的常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__FILE__ 文件名 </span><br><span class="line">__LINE__ 当前行号 </span><br><span class="line">__TIME__ 文件被编译的时间 </span><br><span class="line">__DATE__ 文件被编译的日期</span><br></pre></td></tr></table></figure><p>另一个常见的调试技术是使用 NDEBUG 预处理变量以及 <strong>assert</strong> 预处理宏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(expr)</span><br></pre></td></tr></table></figure><p>只要 NDEBUG 未定义，assert 宏就求解条件表达式 expr，如果结果为 false，assert 输出信息并且终止程序的执行。如果该表达式有一个非零（true），则 assert 不做任何操作。 </p><p>与异常不同（异常用于处理程序执行时预期要发生的错误），使用 assert 来测试“不可能发生”的条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六章-语句&quot;&gt;&lt;a href=&quot;#第六章-语句&quot; class=&quot;headerlink&quot; title=&quot;第六章 语句&quot;&gt;&lt;/a&gt;第六章 语句&lt;/h1&gt;&lt;p&gt;语句类似于自然语言中的句子。C++ 语言既有只完成单一任务的简单语句，也有作为一个单元执行的由一组语句组成的复合语句。和大多数语言一样，C++ 也提供了实现条件分支结构的语句以及重复地执行同一段代码的循环结构。本章将详细讨论 C++ 所支持的语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson10</title>
    <link href="https://zypsola.com/2018/10/24/C++Primer10/"/>
    <id>https://zypsola.com/2018/10/24/C++Primer10/</id>
    <published>2018-10-24T07:07:09.000Z</published>
    <updated>2018-11-07T16:06:02.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-表达式"><a href="#第五章-表达式" class="headerlink" title="第五章 表达式"></a>第五章 表达式</h1><p>表达式由一个或多个<strong>操作数</strong>通过<strong>操作符</strong>组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。</p><a id="more"></a><p>除了特殊用法外，表达式的结果是右值，可以读取该结果值，但是不允许对它进行赋值。 </p><p>C++提供了一元操作符和二元操作符两种操作符。作用在一个操作数上的操作符称为一元操作符,如取地址操作符（&amp;）和解引用操作符（*）；而二元操作符则作用于两个操作数上。除此之外，C++ 还提供了一个使用三个操作数的三元操作符。</p><p>对于操作数为内置或复合类型的二元操作符，通常要求它的两个操作数具有相同的数据类型，或者其类型可以转换为同一种数据类型。</p><p>要理解由多个操作符组成的表达式，必须先理解操作符的<strong>优先级</strong>、<strong>结合性</strong>和操作数的<strong>求值顺序</strong>。</p><h2 id="5-1-算术操作符"><a href="#5-1-算术操作符" class="headerlink" title="5.1 算术操作符"></a>5.1 算术操作符</h2><p>按优先级来对操作符进行分组——一元操作符优先级最高，其次是乘、除操作，接着是二元的加、减法操作。高优先级的操作符要比低优先级的结合得更紧密。这些算术操作符都是左结合，这就意味着当操作符的优先级相同时，这些操作符从左向右依次与操作数结合。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+      一元正号    + expr </span><br><span class="line">-      一元负号    - expr </span><br><span class="line">*      乘法      expr * expr</span><br><span class="line">/      除法      expr / expr</span><br><span class="line">%      求余      expr % expr</span><br><span class="line">+      加法      expr + expr</span><br><span class="line">-      减法      expr - expr</span><br></pre></td></tr></table></figure><p>如果两个操作数为正，除法（/）和求模（%）操作的结果也是正数（或零）；如果两个操作数都是负数，除法操作的结果为正数（或零），而求模操作的结果则为负数（或零）；如果只有一个操作数为负数，这两种操作的结果取决于机器；求模结果的符号也取决于机器，而除法操作的值则是负数（或零）： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-21 % -8; //  ok: result is -5 </span><br><span class="line">21 % -5;  //  machine-dependent: result is 1 or -4 </span><br><span class="line">-21 / -8; //  ok: result is 2 </span><br><span class="line">21 / -5;  //  machine-dependent: result is -4 or -5</span><br></pre></td></tr></table></figure><h2 id="5-2-关系操作符和逻辑操作符"><a href="#5-2-关系操作符和逻辑操作符" class="headerlink" title="5.2 关系操作符和逻辑操作符"></a>5.2 关系操作符和逻辑操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!        逻辑非     !expr </span><br><span class="line">&lt;        小于       expr &lt; expr</span><br><span class="line">&lt;=       小于等于   expr &lt;= expr</span><br><span class="line">&gt;        大于       expr &gt; expr</span><br><span class="line">&gt;=       大于等于   expr &gt;= expr</span><br><span class="line">==       相等       expr == expr</span><br><span class="line">!=       不等       expr != expr</span><br><span class="line">&amp;&amp;       逻辑与     expr &amp;&amp; expr</span><br><span class="line">||       逻辑或     expr || expr</span><br></pre></td></tr></table></figure><p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们常常称这种求值策略为“短路求值（short-circuit evaluation）”。 </p><h2 id="5-3-位操作符"><a href="#5-3-位操作符" class="headerlink" title="5.3 位操作符"></a>5.3 位操作符</h2><p>位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能。另外，这类操作符还可用于 bitset 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~    bitwise NOT（位求反）  ~expr </span><br><span class="line">&lt;&lt;    left shift（左移）    expr1 &lt;&lt; expr2</span><br><span class="line">&gt;&gt;    right shift（右移）   expr1 &gt;&gt; expr2</span><br><span class="line">&amp;    bitwise AND（位与）    expr1 &amp; expr2</span><br><span class="line">^    bitwise XOR（位异或）  expr1 ^ expr2</span><br><span class="line">|    bitwise OR（位或）     expr1 | expr2</span><br></pre></td></tr></table></figure><p>位操作符操纵的整数的类型可以是有符号的也可以是无符号的。如果操作数为负数，则位操作符如何处理其操作数的符号位依赖于机器。</p><p>移位操作的右操作数不可以是负数，而且必须是严格小于左操作数位数的值。否则，操作的效果未定义。 </p><h2 id="5-4-赋值操作符"><a href="#5-4-赋值操作符" class="headerlink" title="5.4 赋值操作符"></a>5.4 赋值操作符</h2><p>赋值操作符的左操作数必须是非 const 的左值。</p><h3 id="5-4-1-赋值操作的右结合性"><a href="#5-4-1-赋值操作的右结合性" class="headerlink" title="5.4.1 赋值操作的右结合性"></a>5.4.1 赋值操作的右结合性</h3><p>C++语言允许将这多个赋值操作写在一个表达式中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">float b;</span><br><span class="line">a = b = 4.345;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;     //result: 4 4.345</span><br></pre></td></tr></table></figure><h3 id="5-4-2-赋值操作具有低优先级"><a href="#5-4-2-赋值操作具有低优先级" class="headerlink" title="5.4.2 赋值操作具有低优先级"></a>5.4.2 赋值操作具有低优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i; </span><br><span class="line">while ((i = get_value()) != 42) &#123; </span><br><span class="line">    // do something ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。 </p><h3 id="5-4-3-复合赋值操作符"><a href="#5-4-3-复合赋值操作符" class="headerlink" title="5.4.3 复合赋值操作符"></a>5.4.3 复合赋值操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+=   -=   *=   /=   %=   // arithmetic operators </span><br><span class="line">&lt;&lt;= &gt;&gt;=   &amp;=   ^=   |=   // bitwise operators</span><br></pre></td></tr></table></figure><h2 id="5-5-增和自减操作符"><a href="#5-5-增和自减操作符" class="headerlink" title="5.5 增和自减操作符"></a>5.5 增和自减操作符</h2><p>自增（++）和自减（–）操作符为对象加 1 或减 1 操作提供了方便简短的实现方式。它们有前置和后置两种使用形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, j; </span><br><span class="line">j = ++i; // j = 1, i = 1</span><br><span class="line">j = i++; // j = 1, i = 2</span><br></pre></td></tr></table></figure><p>前置操作返回加 1 后的值，所以返回对象本身，这是左值。而后置操作返回的则是右值。 </p><p><strong>在单个表达式中组合使用解引用和自增操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123; 10,20,30 &#125;,&#123; 40,50,60 &#125; &#125;;</span><br><span class="line">int(*p)[3] = a;</span><br><span class="line">cout &lt;&lt; **p &lt;&lt; endl;    //result: 10</span><br><span class="line">cout &lt;&lt; *((*p) + 1) &lt;&lt; endl;    //result: 20</span><br><span class="line">cout &lt;&lt; *((*++p) + 1) &lt;&lt; endl;  //result: 50</span><br></pre></td></tr></table></figure><h2 id="5-6-箭头操作符"><a href="#5-6-箭头操作符" class="headerlink" title="5.6 箭头操作符"></a>5.6 箭头操作符</h2><p>C++ 语言为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（-&gt;）。点操作符用于获取类类型对象的成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.same_isbn(item2);</span><br></pre></td></tr></table></figure><p>如果有一个指向 Sales_item 对象的指针（或迭代器），则在使用点操作符前，需对该指针（或迭代器）进行解引用： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item *sp = &amp;item1; </span><br><span class="line">(*sp).same_isbn(item2);</span><br></pre></td></tr></table></figure><p>必须用圆括号把解引用括起来，因为解引用的优先级低于点操作符。</p><p>C++ 为在点操作符后使用的解引用操作定义了一个同义词：箭头操作符（-&gt;）。假设有一个指向类类型对象的指针（或迭代器），下面的表达式相互等价： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p).foo;</span><br><span class="line">p-&gt;foo;</span><br></pre></td></tr></table></figure><h2 id="5-7-条件操作符"><a href="#5-7-条件操作符" class="headerlink" title="5.7 条件操作符"></a>5.7 条件操作符</h2><p>条件操作符是 C++ 中唯一的三元操作符，它允许将简单的 if-else 判断语句嵌入表达式中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure><p>无论如何，cond 总是要被计算的。然后，条件为 true 时计算 expr1 ，否则计算 expr2 。expr1 和 expr2 中只有一个表达式被计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1, j = 2, k = 3;</span><br><span class="line">int maxij = i &gt; j ? i : j;</span><br><span class="line">int maxijk = i &gt; j ?</span><br><span class="line">i &gt; k ? i : k :</span><br><span class="line">j &gt; k ? j : k;</span><br></pre></td></tr></table></figure><h2 id="5-8-sizeof操作符"><a href="#5-8-sizeof操作符" class="headerlink" title="5.8 sizeof操作符"></a>5.8 sizeof操作符</h2><p>sizeof 操作符的作用是返回一个对象或类型名的长度，返回值的类型为 size_t，长度的单位是字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof (type name); </span><br><span class="line">sizeof (expr); </span><br><span class="line">sizeof expr;</span><br></pre></td></tr></table></figure><p>将 sizeof 应用在表达式 expr 上，将获得该表达式的结果的类型长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double a[10];</span><br><span class="line">double *p = a;</span><br><span class="line">cout &lt;&lt; sizeof(double) &lt;&lt; endl   //8</span><br><span class="line">&lt;&lt; sizeof a &lt;&lt; endl          //80</span><br><span class="line">&lt;&lt; sizeof *p &lt;&lt; endl         //8</span><br><span class="line">&lt;&lt; sizeof(4 + 1.2) &lt;&lt; endl   //8</span><br><span class="line">&lt;&lt; sizeof p &lt;&lt; endl;         //4</span><br></pre></td></tr></table></figure><h2 id="5-9-逗号操作符"><a href="#5-9-逗号操作符" class="headerlink" title="5.9 逗号操作符"></a>5.9 逗号操作符</h2><p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。如果最右边的操作数是左值，则逗号表达式的值也是左值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   int a = (222 + 333, 66);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;          //66</span><br><span class="line">int b = 55;</span><br><span class="line">(b++, a = 77)++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        //78 56</span><br></pre></td></tr></table></figure><h2 id="5-10-复合表达式的求值"><a href="#5-10-复合表达式的求值" class="headerlink" title="5.10 复合表达式的求值"></a>5.10 复合表达式的求值</h2><p>含有两个或更多操作符的表达式称为<strong>复合表达式</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (ia[index++] &lt; ia[index])</span><br></pre></td></tr></table></figure><p>此表达式的行为没有明确定义。问题在于：&lt; 操作符的左右操作数都使用了 index 变量，但是，左操作数更改了该变量的值。假设 index 初值为 0，编译器可以用下面两种方式之一求该表达式的值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (ia[0] &lt; ia[0]) // execution if rhs is evaluated first </span><br><span class="line">if (ia[0] &lt; ia[1]) // execution if lhs is evaluated first</span><br></pre></td></tr></table></figure><h2 id="5-11-new-和-delete-表达式"><a href="#5-11-new-和-delete-表达式" class="headerlink" title="5.11 new 和 delete 表达式"></a>5.11 new 和 delete 表达式</h2><p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new 表达式返回指向新创建对象的指针，我们通过该指针来访问此对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pi = new int;</span><br></pre></td></tr></table></figure><p><strong>动态创建对象的初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *pi = new int(1024); </span><br><span class="line">string *ps = new string(10, &apos;9&apos;);</span><br></pre></td></tr></table></figure><p><strong>动态创建对象的默认初始化</strong></p><p>如果不提供显式初始化，动态创建的对象与在函数内定义的变量初始化方式相同。对于类类型的对象，用该类的默认构造函数初始化；而内置类型的对象则无初始化。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = new int();     //初始化为0</span><br><span class="line">int *p2 = new int;       //未初始化</span><br></pre></td></tr></table></figure><p><strong>撤销动态创建的对象</strong></p><p>动态创建的对象用完后，程序员必须显式地将该对象占用的内存返回给自由存储区。C++ 提供了 delete 表达式释放指针所指向的地址空间。 </p><p>如果指针指向不是用 new 分配的内存地址，则在该指针上使用 delete 是不合法的。 </p><p><strong>零值指针的删除</strong></p><p>如果指针的值为 0，则在其上做 delete 操作是合法的，但这样做没有任何意义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ip = 0; </span><br><span class="line">delete ip;</span><br></pre></td></tr></table></figure><p>C++ 保证：删除 0 值的指针是安全的。</p><p><strong>在delete之后，重设指针的值</strong></p><p>执行语句delete p; 后，p 变成没有定义。在很多机器上，尽管 p 没有定义，但仍然存放了它之前所指向对象的地址，然而 p 所指向的内存已经被释放，因此 p 不再有效。 </p><p>删除指针后，该指针变成悬垂指针。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。 </p><p>一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清楚地表明指针不再指向任何对象。 </p><p><strong>const对象的动态分配和回收</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int *pci = new const int(1024)</span><br></pre></td></tr></table></figure><p>与其他常量一样，动态创建的 const 对象必须在创建时初始化，并且一经初始化，其值就不能再修改。</p><p>对于类类型的 const 动态对象，如果该类提供了默认的构造函数，则此对象可隐式初始化： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const string *pcs = new const string;</span><br></pre></td></tr></table></figure><h2 id="5-12-类型转换"><a href="#5-12-类型转换" class="headerlink" title="5.12 类型转换"></a>5.12 类型转换</h2><p>在 C++ 中，某些类型之间存在相关的依赖关系。若两种类型相关，则可在需要某种类型的操作数位置上，使用该类型的相关类型对象或值。如果两个类型之间可以相互转换，则称这两个类型相关。 </p><h3 id="5-12-1-何时发生隐式类型转换"><a href="#5-12-1-何时发生隐式类型转换" class="headerlink" title="5.12.1 何时发生隐式类型转换"></a>5.12.1 何时发生隐式类型转换</h3><ol><li>在混合类型的表达式中，其操作数被转换为相同的类型</li><li>用作条件的表达式被转换为 bool 类型</li><li>用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量的类型</li></ol><p>另外，在函数调用中也可能发生隐式类型转换。</p><h3 id="5-12-2-算术转换"><a href="#5-12-2-算术转换" class="headerlink" title="5.12.2 算术转换"></a>5.12.2 算术转换</h3><p>算术转换规则定义了一个类型转换层次，该层次规定了操作数应按什么次序转换为表达式中最宽的类型。</p><p>若表达式中使用了unsigned数值，所定义的转换规则需保护操作数的精度。unsigned 操作数的转换依赖于机器中整型的相对大小，因此，这类转换本质上依赖于机器。 </p><h3 id="5-12-3-其他隐式转换"><a href="#5-12-3-其他隐式转换" class="headerlink" title="5.12.3 其他隐式转换"></a>5.12.3 其他隐式转换</h3><p><strong>指针转换</strong></p><p>在使用数组时，大多数情况下数组都会自动转换为指向第一个元素的指针。</p><p>指向任意数据类型的指针都可转换为 void* 类型；整型数值常量 0 可转换为任意指针类型。 </p><p><strong>转换为bool类型</strong></p><p>算术值和指针值都可以转换为 bool 类型。如果指针或算术值为 0，则其 bool 值为 false ，而其他值则为 true。</p><p><strong>算术类型与bool类型的转换</strong></p><p>可将算术对象转换为 bool 类型，bool 对象也可转换为 int 型。将算术类型转换为 bool 型时，零转换为 false ，而其他值则转换为 true 。将 bool 对象转换为算术类型时，true 变成 1，而 false 则为 0。</p><p><strong>转换与枚举类型</strong></p><p>C++ 自动将枚举类型的对象或枚举成员转换为整型，其转换结果可用于任何要求使用整数值的地方。</p><h3 id="5-12-4-显式转换"><a href="#5-12-4-显式转换" class="headerlink" title="5.12.4 显式转换"></a>5.12.4 显式转换</h3><p>显式转换也称为强制类型转换（cast），包括以下列名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。 </p><h3 id="5-12-5-何时需要强制类型转换"><a href="#5-12-5-何时需要强制类型转换" class="headerlink" title="5.12.5 何时需要强制类型转换"></a>5.12.5 何时需要强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">double b = 3.99;</span><br><span class="line">cout &lt;&lt; a*static_cast&lt;int&gt;(b) &lt;&lt; endl;    //9</span><br><span class="line">cout &lt;&lt; a*b &lt;&lt; endl;           //11.97</span><br></pre></td></tr></table></figure><p>显式使用强制类型转换的另一个原因是：可能存在多种转换时，需要选择一种特定的类型转换。</p><h3 id="5-12-6-命名的强制类型转换"><a href="#5-12-6-命名的强制类型转换" class="headerlink" title="5.12.6 命名的强制类型转换"></a>5.12.6 命名的强制类型转换</h3><p><strong>dynamic_cast</strong>:支持运行时识别指针或引用所指向的对象。</p><p><strong>const_cast</strong>:转换掉表达式的 const 性质。例如，假设有函数 string_copy，只有唯一的参数，为 char* 类型，我们对该函数只读不写。在访问该函数时，最好的选择是修改它让它接受 const char* 类型的参数。如果不行，可通过 const_cast 用一个 const 值调用 string_copy 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char* sc(char *p1)</span><br><span class="line">&#123;</span><br><span class="line">p1 = new char(&apos;c&apos;);</span><br><span class="line">char *p2 = p1;</span><br><span class="line">return p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const char *p = new char(&apos;a&apos;);</span><br><span class="line">char *p2 = sc(const_cast&lt;char*&gt;(p));</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *p2 &lt;&lt; endl;       //a c</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>static_cast</strong>:编译器隐式执行的任何类型转换都可以由 static_cast 显式完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a(1.23);</span><br><span class="line">void *p = &amp;a;</span><br><span class="line">cout &lt;&lt; *(static_cast&lt;double*&gt;(p)) &lt;&lt; endl;   //1.23</span><br></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong>:reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *ip = new int(65);</span><br><span class="line">char *cp = reinterpret_cast&lt;char*&gt;(ip);</span><br><span class="line">cout &lt;&lt; *cp &lt;&lt; endl;    //A</span><br></pre></td></tr></table></figure><h3 id="5-12-7-旧式强制类型转换"><a href="#5-12-7-旧式强制类型转换" class="headerlink" title="5.12.7 旧式强制类型转换"></a>5.12.7 旧式强制类型转换</h3><p>在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现。</p><p>旧式强制转换符号有下列两种形式： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (expr); // Function-style cast notation </span><br><span class="line">(type) expr; // C-language-style cast notation</span><br></pre></td></tr></table></figure><p>旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第五章-表达式&quot;&gt;&lt;a href=&quot;#第五章-表达式&quot; class=&quot;headerlink&quot; title=&quot;第五章 表达式&quot;&gt;&lt;/a&gt;第五章 表达式&lt;/h1&gt;&lt;p&gt;表达式由一个或多个&lt;strong&gt;操作数&lt;/strong&gt;通过&lt;strong&gt;操作符&lt;/strong&gt;组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson9</title>
    <link href="https://zypsola.com/2018/10/23/C++Primer9/"/>
    <id>https://zypsola.com/2018/10/23/C++Primer9/</id>
    <published>2018-10-23T15:29:47.000Z</published>
    <updated>2018-10-24T06:55:58.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-数组和指针"><a href="#第四章-数组和指针" class="headerlink" title="第四章 数组和指针"></a>第四章 数组和指针</h1><h2 id="4-3-C风格字符串"><a href="#4-3-C风格字符串" class="headerlink" title="4.3 C风格字符串"></a>4.3 C风格字符串</h2><p>字符串字面值的类型就是const char 类型的数组。实际上，C 风格字符串既不能确切地归结为 C 语言的类型，也不能归结为 C++ 语言的类型，而是以空字符 null 结束的字符数组。</p><a id="more"></a><p>C++ 语言通过(const)char*类型的指针来操纵 C 风格字符串。一般来说，我们使用指针的算术操作来遍历 C 风格字符串，每次对指针进行测试并递增 1，直到到达结束符 null 为止： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const char *cp = &quot;12345&quot;;</span><br><span class="line">while (*cp) &#123;    //真值表明这是除 null 外的任意字符</span><br><span class="line">cout &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br><span class="line">//result: 12345</span><br></pre></td></tr></table></figure><p><strong>C 风格字符串的标准库函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strlen(s)       返回 s 的长度，不包括字符串结束符 null </span><br><span class="line">strcmp(s1, s2)  比较两个字符串 s1 和 s2 是否相同。若 s1 与 s2 相等，返回 0；若 s1 大于 s2，返回正数；若 s1 小于 s2，则返回负数 </span><br><span class="line">strcat(s1, s2)  将字符串 s2 连接到 s1 后，并返回 s1 </span><br><span class="line">strcpy(s1, s2)     将 s2 复制给 s1，并返回 s1 </span><br><span class="line">strncat(s1, s2, n) 将 s2 的前 n 个字符连接到 s1 后面，并返回 s1 </span><br><span class="line">strncpy(s1, s2, n) 将 s2 的前 n 个字符复制给 s1，并返回 s1</span><br></pre></td></tr></table></figure><p>C++ 语言提供普通的关系操作符实现标准库类型 string 的对象的比较。这些操作符也可用于比较指向 C 风格字符串的指针，但效果却很不相同：实际上，此时比较的是指针上存放的地址值，而并非它们所指向的字符串。</p><h3 id="4-3-1-创建动态数组"><a href="#4-3-1-创建动态数组" class="headerlink" title="4.3.1 创建动态数组"></a>4.3.1 创建动态数组</h3><p>数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须知道其长度，数组只在定义它的块语句内存在。实际的程序往往不能忍受这样的限制——它们需要在运行时动态地分配数组。虽然数组长度是固定的，但动态分配的数组不必在编译时知道其长度，可以（通常也是）在运行时才确定数组长度。与数组变量不同，动态分配的数组将一直存在，直到程序显式释放它为止。 </p><p>每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的<strong>自由存储区</strong>或<strong>堆</strong>。</p><p>C 语言程序使用一对标准库函数 <strong>malloc</strong> 和 <strong>free</strong> 在自由存储区中分配存储空间，而 C++ 语言则使用 <strong>new</strong> 和 <strong>delete</strong> 表达式实现相同的功能。 </p><p><strong>动态数组的定义</strong></p><p>数组变量通过指定类型、数组名和维数来定义。而动态分配数组时，只需指定类型和数组长度，不必为数组对象命名，new 表达式返回指向新分配数组的第一个元素的指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int size</span><br><span class="line">cin &gt;&gt; size;</span><br><span class="line">int *p = new int[size];</span><br></pre></td></tr></table></figure><p><strong>初始化动态分配的数组</strong></p><p>动态分配数组时，如果数组元素具有类类型，将使用该类的默认构造函数实现初始化；如果数组元素是内置类型，则无初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *psa = new string[10]; // array of 10 empty strings </span><br><span class="line">int *pia = new int[10];       // array of 10 uninitialized ints</span><br></pre></td></tr></table></figure><p>也可使用跟在数组长度后面的一对空圆括号，对数组元素做值初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p = new int[10] (); // array of 10 zero</span><br></pre></td></tr></table></figure><p>圆括号要求编译器对数组做值初始化。对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。 </p><p><strong>const 对象的动态数组</strong></p><p>如果我们在自由存储区中创建的数组存储了内置类型的 const 对象，则必须为这个数组提供初始化：因为数组元素都是 const 对象，无法赋值。实现这个要求的唯一方法是对数组做值初始化： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int *pci = new const int[100]();</span><br><span class="line">const string *pcs = new const string[100];    //将使用 string 类的默认构造函数初始化数组元素</span><br></pre></td></tr></table></figure><p>已创建的常量元素不允许修改——因此这样的数组实际上用处不大。</p><p><strong>允许动态分配空数组</strong></p><p>C++ 虽然不允许定义长度为 0 的数组变量，但明确指出，调用 new 动态创建长度为 0 的数组是合法的： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char arr[0];            // error: cannot define zero-length array </span><br><span class="line">char *cp = new char[0]; // ok: but cp can&apos;t be dereferenced</span><br></pre></td></tr></table></figure><p>用 new 动态创建长度为 0 的数组时，new 返回有效的非零指针。该指针与 new 返回的其他指针不同，不能进行解引用操作，因为它毕竟没有指向任何元素。</p><p><strong>动态空间的释放</strong></p><p>动态分配的内存最后必须进行释放，否则，内存最终将会逐渐耗尽。如果不再需要使用动态创建的数组，程序员必须显式地将其占用的存储空间返还给程序的自由存储区。C++ 语言为指针提供 delete [] 表达式释放指针所指向的数组空间： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure><p>在关键字 delete 和指针之间的空方括号对是必不可少的：它告诉编译器该指针指向的是自由存储区中的数组，而并非单个对象。 </p><h3 id="4-3-2-新旧代码的兼容"><a href="#4-3-2-新旧代码的兼容" class="headerlink" title="4.3.2 新旧代码的兼容"></a>4.3.2 新旧代码的兼容</h3><p><strong>混合使用标准库类string和C风格字符串</strong></p><p>可用字符串字面值初始化 string 类对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello&quot;);</span><br><span class="line">char s1[10] = &quot;123456&quot;;</span><br><span class="line">string s2(s1);</span><br></pre></td></tr></table></figure><p>无法使用 string 对象初始化字符指针,但是，string 类提供了一个名为 c_str 的成员函数，以实现我们的要求： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;123456&quot;);</span><br><span class="line">const char *const ps = s.c_str();</span><br></pre></td></tr></table></figure><p><strong>使用数组初始化vector对象</strong></p><p>使用数组初始化 vector 对象，必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">vector&lt;int&gt; b(a + 1, a + 4);    //size of b:3;b:2,3,4</span><br></pre></td></tr></table></figure><h2 id="4-4-多维数组"><a href="#4-4-多维数组" class="headerlink" title="4.4 多维数组"></a>4.4 多维数组</h2><p><strong>多维数组的初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123;</span><br><span class="line">&#123;1,2,3&#125;,</span><br><span class="line">&#123;4,5,6&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; 1,2,3,4,5,6 &#125;;</span><br></pre></td></tr></table></figure><p>下面的声明只初始化了每行的第一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123;1&#125;,&#123;4&#125; &#125;;</span><br><span class="line">//1 0 0</span><br><span class="line">//4 0 0</span><br></pre></td></tr></table></figure><h3 id="4-4-1-指针和多维数组"><a href="#4-4-1-指针和多维数组" class="headerlink" title="4.4.1 指针和多维数组"></a>4.4.1 指针和多维数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123;10,20,30&#125;,&#123;40,50,60&#125; &#125;;</span><br><span class="line">int(*p)[3] = a;</span><br><span class="line">cout &lt;&lt; **p &lt;&lt; endl;    //result: 10</span><br><span class="line">p = &amp;a[1];</span><br><span class="line">cout &lt;&lt; *((*p) + 1) &lt;&lt; endl;    //result: 50</span><br></pre></td></tr></table></figure><p><strong>用 typedef 简化指向多维数组的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int int_array[3];</span><br><span class="line">int a[2][3] = &#123; &#123;10,20,30&#125;,&#123;40,50,60&#125; &#125;;</span><br><span class="line">int_array *p = a;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-数组和指针&quot;&gt;&lt;a href=&quot;#第四章-数组和指针&quot; class=&quot;headerlink&quot; title=&quot;第四章 数组和指针&quot;&gt;&lt;/a&gt;第四章 数组和指针&lt;/h1&gt;&lt;h2 id=&quot;4-3-C风格字符串&quot;&gt;&lt;a href=&quot;#4-3-C风格字符串&quot; class=&quot;headerlink&quot; title=&quot;4.3 C风格字符串&quot;&gt;&lt;/a&gt;4.3 C风格字符串&lt;/h2&gt;&lt;p&gt;字符串字面值的类型就是const char 类型的数组。实际上，C 风格字符串既不能确切地归结为 C 语言的类型，也不能归结为 C++ 语言的类型，而是以空字符 null 结束的字符数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson8</title>
    <link href="https://zypsola.com/2018/10/23/C++Primer8/"/>
    <id>https://zypsola.com/2018/10/23/C++Primer8/</id>
    <published>2018-10-23T07:58:31.000Z</published>
    <updated>2018-10-23T15:52:57.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-数组和指针"><a href="#第四章-数组和指针" class="headerlink" title="第四章 数组和指针"></a>第四章 数组和指针</h1><p>C++ 语言提供了两种类似于 vector 和迭代器类型的低级复合类型——<strong>数组</strong>和<strong>指针</strong>。与 vector 类型相似，数组也可以保存某种类型的一组对象；而它们的区别在于，数组的长度是固定的。数组一经创建，就不允许添加新的元素。指针则可以像迭代器一样用于遍历和检查数组中的元素。 </p><a id="more"></a><p>现代 C++ 程序应尽量使用 vector 和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。</p><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组是由类型名、标识符和维数组成的复合数据类型，类型名规定了存放在数组中的元素的类型，而维数则指定数组中包含的元素个数。 </p><h3 id="4-1-1-数组的定义和初始化"><a href="#4-1-1-数组的定义和初始化" class="headerlink" title="4.1.1 数组的定义和初始化"></a>4.1.1 数组的定义和初始化</h3><p>数组的维数必须用值大于等于 1 的常量表达式定义。此常量表达式只能包含整型字面值常量、枚举常量或者用常量表达式初始化的整型 const 对象。非 const 变量以及要到运行阶段才知道其值的 const 变量都不能用于定义数组的维数。 </p><p><strong>显式初始化数组元素</strong></p><p>显式初始化的数组不需要指定数组的维数值，编译器会根据列出的元素个数来确定数组的长度： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123; 1,2,3 &#125;;</span><br><span class="line">cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; &quot; &quot; &lt;&lt; a[2] &lt;&lt; &quot; &quot;</span><br><span class="line"> &lt;&lt; a[3] &lt;&lt; &quot; &quot; &lt;&lt; a[4] &lt;&lt; endl;    //输出结果： 1 2 3 0 0</span><br><span class="line">int b[] = &#123; 1,2,3 &#125;;</span><br></pre></td></tr></table></figure><p><strong>特殊的字符数组</strong></p><p>字符数组既可以用一组由花括号括起来、逗号隔开的字符字面值进行初始化，也可以用一个字符串字面值进行初始化。然而，要注意这两种初始化形式并不完全相同，字符串字面值包含一个额外的空字符（null）用于结束字符串。当使用字符串字面值来初始化创建的新数组时，将在新数组中加入空字符： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a1[] = &#123; &apos;1&apos;,&apos;2&apos;,&apos;3&apos; &#125;;</span><br><span class="line">char a2[] = &#123; &apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;\0&apos; &#125;;</span><br><span class="line">char a3[] = &quot;123&quot;;</span><br><span class="line">cout &lt;&lt; a1 &lt;&lt; endl &lt;&lt; a2 &lt;&lt; endl &lt;&lt; a3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123烫烫烃蚉鉎</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>使用一组字符字面值初始化字符数组时，一定要记得添加结束字符串的空字符。</p><p><strong>不允许数组直接复制和赋值</strong></p><p>与 vector 不同，一个数组不能用另外一个数组初始化，也不能将一个数组赋值给另一个数组，这些操作都是非法的。</p><h3 id="4-1-2-数组操作"><a href="#4-1-2-数组操作" class="headerlink" title="4.1.2 数组操作"></a>4.1.2 数组操作</h3><p>与 vector 元素一样，数组元素可用下标操作符来访问，数组元素也是从 0 开始计数。</p><p>使用数组时，必须保证其下标值在正确范围之内，即数组在该下标位置应对应一个元素。 </p><h2 id="4-2-指针的引入"><a href="#4-2-指针的引入" class="headerlink" title="4.2 指针的引入"></a>4.2 指针的引入</h2><h3 id="4-2-1-什么是指针"><a href="#4-2-1-什么是指针" class="headerlink" title="4.2.1 什么是指针"></a>4.2.1 什么是指针</h3><p>指针的概念很简单：指针用于指向对象。具体来说，指针保存的是另一个对象的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;); </span><br><span class="line">string *sp = &amp;s; // sp holds the address of s</span><br></pre></td></tr></table></figure><p>第二条语句定义了一个指向 string 类型的指针 sp，并初始化 sp 使其指向 string 类型的对象 s。*sp 中的 * 操作符表明 sp 是一个指针变量，&amp;s 中的 &amp; 符号是取地址操作符，当此操作符用于一个对象上时，返回的是该对象的存储地址。</p><p>C++ 语言使用 * 符号把一个标识符声明为指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;   *pvec;      // pvec can point to a vector&lt;int&gt; </span><br><span class="line">int           *ip1, *ip2; // ip1 and ip2 can point to an int </span><br><span class="line">string        *pstring;   // pstring can point to a string </span><br><span class="line">double        *dp;        // dp can point to a double</span><br></pre></td></tr></table></figure><p>理解指针声明语句时，请从右向左阅读。语句把 pstring 定义为一个指向 string 类型对象的指针变量。</p><p>在声明语句中，符号 * 可用在指定类型的对象列表的任何位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double dp, *dp2; /</span><br></pre></td></tr></table></figure><p><strong>另一种声明指针的风格</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps; // legal but can be misleading</span><br></pre></td></tr></table></figure><p>也就是说，该语句把 ps 定义为一个指向 string 类型对象的指针。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps1, ps2;</span><br></pre></td></tr></table></figure><p>实际上只把 ps1 定义为指针，而 ps2 并非指针，只是一个普通的 string 对象而已。如果需要在一个声明语句中定义两个指针，必须在每个变量标识符前再加符号 * 声明： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ing* ps1, *ps2;</span><br></pre></td></tr></table></figure><p><strong>指针可能的取值</strong></p><p>一个有效的指针必然是以下三种状态之一：保存一个特定对象的地址；指向某个对象后面的另一对象；或者是 0 值。若指针保存 0 值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它。</p><p><strong>指针初始化和赋值操作的约束</strong></p><p>对指针进行初始化或赋值只能使用以下四种类型的值： </p><ol><li>0 值常量表达式。</li><li>类型匹配的对象的地址。</li><li>另一对象末的下一地址。</li><li>同类型的另一个有效指针。</li></ol><p>除了使用数值 0 或在编译时值为 0 的 const 量外，还可以使用 C++ 语言从 C 语言中继承下来的预处理器变量 NULL，其值为 0。如果在代码中使用了这个预处理器变量，则编译时会自动被数值 0 替换。因此，把指针初始化为 NULL 等效于初始化为 0 值。</p><p><strong>void*指针</strong></p><p>C++ 提供了一种特殊的指针类型 void*，它可以保存任何类型对象的地址： 表明该指针与一地址值相关，但不清楚存储在此地址上的对象的类型。 </p><p>void* 指针只支持几种有限的操作：与另一个指针进行比较；向函数传递 void* 指针或从函数返回 void* 指针；给另一个 void* 指针赋值。不允许使用 void* 指针操纵它所指向的对象。</p><h3 id="4-2-3-指针操作"><a href="#4-2-3-指针操作" class="headerlink" title="4.2.3 指针操作"></a>4.2.3 指针操作</h3><p>指针提供间接操纵其所指对象的功能。与对迭代器进行解引用操作一样，对指针进行解引用可访问它所指的对象，* 操作符（解引用操作符）将获取指针所指的对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;); </span><br><span class="line">string *sp = &amp;s;</span><br><span class="line">cout  &lt;&lt;*sp;</span><br></pre></td></tr></table></figure><p>解引用操作符返回指定对象的左值，利用这个功能可修改指针所指对象的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*sp = &quot;goodbye&quot;;</span><br></pre></td></tr></table></figure><p><strong>指向指针的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024; </span><br><span class="line">int *pi = &amp;ival; // pi points to an int </span><br><span class="line">int **ppi = &amp;pi; // ppi points to a pointer to int</span><br></pre></td></tr></table></figure><h3 id="4-2-4-使用指针访问数组元素"><a href="#4-2-4-使用指针访问数组元素" class="headerlink" title="4.2.4 使用指针访问数组元素"></a>4.2.4 使用指针访问数组元素</h3><p>C++ 语言中，指针和数组密切相关。特别是在表达式中使用数组名时，该名字会自动转换为指向数组第一个元素的指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,2,4,6,8&#125;; </span><br><span class="line">int *ip = ia; // ip points to ia[0] </span><br><span class="line">ip = &amp;ia[4]; // ip points to last element in ia</span><br></pre></td></tr></table></figure><p>指针的算术操作只有在原指针和计算出来的新指针都指向同一个数组的元素，或指向该数组存储空间的下一单元时才是合法的。</p><p>两个指针减法操作的结果是标准库类型（library type）ptrdiff_t 的数据。</p><p>在指针上加一个整型数值，其结果仍然是指针。允许在这个结果上直接进行解引用操作，而不必先把它赋给一个新指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123; 2,3,4,5,6 &#125;;</span><br><span class="line">cout &lt;&lt; *(a + 4) &lt;&lt; endl;   //result: 6</span><br></pre></td></tr></table></figure><p><strong>下标和指针</strong></p><p>使用下标访问数组时，实际上是使用下标访问指针,在使用下标访问数组时，实际上是对指向数组元素的指针做下标操作。只要指针指向数组元素，就可以对它进行下标操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123; 2,3,4,5,6 &#125;;</span><br><span class="line">int *p = &amp;a[2];</span><br><span class="line">cout &lt;&lt; p[-2] &lt;&lt; endl;   //result: 2</span><br></pre></td></tr></table></figure><h3 id="4-2-5-指针和const限定符"><a href="#4-2-5-指针和const限定符" class="headerlink" title="4.2.5 指针和const限定符"></a>4.2.5 指针和const限定符</h3><p><strong>指向const对象的指针</strong></p><p>如果指针指向 const 对象，则不允许用指针来改变其所指的 const 值。为了保证这个特性，C++ 语言强制要求指向 const 对象的指针也必须具有 const 特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double *cptr;</span><br></pre></td></tr></table></figure><p>这里的 cptr 是一个指向 double 类型 const 对象的指针，const 限定了 cptr 指针所指向的对象类型，而并非 cptr 本身。也就是说，cptr 本身并不是const。在定义时不需要对它进行初始化，如果需要的话，允许给 cptr 重新赋值，使其指向另一个 const 对象。但不能通过 cptr 修改其所指对象的值。</p><p>把一个 const 对象的地址赋给一个普通的、非 const 对象的指针也会导致编译时的错误。</p><p>允许把非 const 对象的地址赋给指向 const 对象的指针。</p><p>在实际的程序中，指向 const 的指针常用作函数的形参。将形参定义为指向 const 的指针，以此确保传递给函数的实际对象在函数中不因为形参而被修改。 </p><p><strong>const指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int errNumb = 0; </span><br><span class="line">int *const curErr = &amp;errNumb;</span><br></pre></td></tr></table></figure><p>与其他 const 量一样，const 指针的值不能修改，const 指针也必须在定义时初始化。</p><p><strong>指向const对象的const指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14159; </span><br><span class="line">const double *const pi_ptr = &amp;pi;</span><br></pre></td></tr></table></figure><p>既不能修改所指向对象的值，也不允许修改该指针的指向。</p><p><strong>指针和typedef</strong></p><p>在 typedef中使用指针往往会带来意外的结果。假设给出以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef string *pstring; </span><br><span class="line">const pstring cstr;</span><br></pre></td></tr></table></figure><p>这个定义等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *const cstr;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-数组和指针&quot;&gt;&lt;a href=&quot;#第四章-数组和指针&quot; class=&quot;headerlink&quot; title=&quot;第四章 数组和指针&quot;&gt;&lt;/a&gt;第四章 数组和指针&lt;/h1&gt;&lt;p&gt;C++ 语言提供了两种类似于 vector 和迭代器类型的低级复合类型——&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;指针&lt;/strong&gt;。与 vector 类型相似，数组也可以保存某种类型的一组对象；而它们的区别在于，数组的长度是固定的。数组一经创建，就不允许添加新的元素。指针则可以像迭代器一样用于遍历和检查数组中的元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
      <category term="数组" scheme="https://zypsola.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson7</title>
    <link href="https://zypsola.com/2018/10/23/C++Primer7/"/>
    <id>https://zypsola.com/2018/10/23/C++Primer7/</id>
    <published>2018-10-23T02:50:46.000Z</published>
    <updated>2018-10-23T10:00:09.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><h2 id="3-5-标准库-bitset"><a href="#3-5-标准库-bitset" class="headerlink" title="3.5 标准库 bitset"></a>3.5 标准库 bitset</h2><p>有些程序要处理二进制位的有序集，每个位可能包含 0（关）1（开）值。位是用来保存一组项或条件的 yes/no 信息（有时也称标志）的简洁方法。标准库提供的 bitset 类简化了位集的处理。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;bitset&gt; </span><br><span class="line">using std::bitset</span><br></pre></td></tr></table></figure><h3 id="3-5-1-bitset对象的定义和初始化"><a href="#3-5-1-bitset对象的定义和初始化" class="headerlink" title="3.5.1 bitset对象的定义和初始化"></a>3.5.1 bitset对象的定义和初始化</h3><p>似于 vector，bitset 类是一种类模板；而与 vector 不一样的是 bitset 类型对象的区别仅在其长度而不在其类型。在定义 bitset 时，要明确 bitset 含有多少位，须在尖括号内给出它的长度值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;n&gt; b;             //b 有 n 位，每位都 0 </span><br><span class="line">bitset&lt;n&gt; b(u);          //b 是 unsigned long 型 u 的一个副本 </span><br><span class="line">bitset&lt;n&gt; b(s);          //b 是 string 对象 s 中含有的位串的副本 </span><br><span class="line">bitset&lt;n&gt; b(s, pos, n);  //b 是 s 中从位置 pos 开始的&amp;nbps;n 个位的副本。</span><br><span class="line">bitset&lt;32&gt; bitvec;       //32bits, all 0</span><br></pre></td></tr></table></figure><p>给出的长度值必须是常量表达式。长度值值必须定义为整型字面值常量或是已用常量值初始化的整型的 const 对象。 </p><p>bitset 中的位是没有命名的，只能按位置来访问。位集合的位置编号从 0 开始，因此，bitvec 的位序是从 0 到 31。以 0 位开始的位串是低阶位（low-order），以 31 位结束的位串是高阶位（high-order）。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt; a(4);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0100</span><br><span class="line">0010</span><br></pre></td></tr></table></figure><h3 id="用unsigned值初始化bitset对象"><a href="#用unsigned值初始化bitset对象" class="headerlink" title="用unsigned值初始化bitset对象"></a><strong>用unsigned值初始化bitset对象</strong></h3><p>当用 unsigned long 值作为 bitset 对象的初始值时，该值将转化为二进制的位模式。而 bitset 对象中的位集作为这种位模式的副本。如果 bitset 类型长度大于 unsigned long 值的二进制位数，则其余的高阶位将置为 0；如果 bitset 类型长度小于 unsigned long 值的二进制位数，则只使用 unsigned 值中的低阶位，超过 bistset 类型长度的高阶位将被丢弃。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt; a(19);</span><br><span class="line">bitset&lt;6&gt; b(19);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0011</span><br><span class="line">010011</span><br></pre></td></tr></table></figure><h3 id="用string对象初始化bitset对象"><a href="#用string对象初始化bitset对象" class="headerlink" title="用string对象初始化bitset对象"></a><strong>用string对象初始化bitset对象</strong></h3><p>当用 string 对象初始化 bitset 对象时，string 对象直接表示为位模式。从 string 对象读入位集的顺序是从右向左： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str(&quot;1100&quot;);</span><br><span class="line">bitset&lt;8&gt; bita(str);</span><br><span class="line">bitset&lt;8&gt; bitb(&quot;0111&quot;);</span><br><span class="line">cout &lt;&lt; bita &lt;&lt; endl &lt;&lt; bitb &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00001100</span><br><span class="line">00000111</span><br></pre></td></tr></table></figure><p>不一定要把整个 string 对象都作为 bitset 对象的初始值。相反，可以只用某个子串作为初始值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str(&quot;010110111011010&quot;);</span><br><span class="line">bitset&lt;16&gt; bita(str, 1, 8);</span><br><span class="line">bitset&lt;16&gt; bitb(str, str.size() - 9);</span><br><span class="line">cout &lt;&lt; bita &lt;&lt; endl &lt;&lt; bitb &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000010110111</span><br><span class="line">0000000111011010</span><br></pre></td></tr></table></figure></p><p>如果省略第三个参数则意味着取从开始位置一直到 string 末尾的所有字符。</p><h3 id="3-5-2-bitset对象上的操作"><a href="#3-5-2-bitset对象上的操作" class="headerlink" title="3.5.2 bitset对象上的操作"></a>3.5.2 bitset对象上的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b.any()      b 中是否存在置为 1 的二进制位？ </span><br><span class="line">b.none()     b 中不存在置为 1 的二进制位吗？ </span><br><span class="line">b.count()    b 中置为 1 的二进制位的个数 </span><br><span class="line">b.size()     b 中二进制位的个数 </span><br><span class="line">b[pos]       访问 b 中在 pos 处二进制位 </span><br><span class="line">b.test(pos)  b 中在 pos 处的二进制位置为 1 么？ </span><br><span class="line">b.set()      把 b 中所有二进制位都置为 1  </span><br><span class="line">b.set(pos)   把 b 中在 pos 处的二进制位置为 1</span><br><span class="line">b.reset()    把 b 中所有二进制位都置为 0 </span><br><span class="line">b.reset(pos) 把 b 中在 pos 处的二进制位置为 0 </span><br><span class="line">b.flip()     把 b 中所有二进制位逐位取反 </span><br><span class="line">b.flip(pos)  把 b 中在 pos 处的二进制位取反 </span><br><span class="line">b.to_ulong() 用 b 中同样的二进制位返回一个 unsigned long 值 </span><br><span class="line">os &lt;&lt; b      把 b 中的位集输出到 os 流</span><br></pre></td></tr></table></figure><p>count 操作的返回类型是标准库中命名为 size_t 类型。它是一个与机器相关的 unsigned 类型。</p><p><strong>访问bitset对象中的位</strong></p><p>可以用下标操作符来读或写某个索引位置的二进制位。</p><p>bitset 类也支持内置的位操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bita = bita &amp; bitb;</span><br><span class="line">cout &lt;&lt; bita &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000010010010</span><br></pre></td></tr></table></figure><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><p><strong>abstract data type（抽象数据类型）:</strong>隐藏其实现的数据类型。使用抽象数据类型时，只需要了解该类型所支持的操作。</p></li><li><p><strong>class template（类模板）:</strong>一个可创建许多潜在类类型的蓝图。使用类模板时，必须给出实际的类型和值。例如，vector 类型是保存给定类型对象的模板。创建一个 vector 对象时，必须指出这个 vector 对象所保存的元素的类型。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;h2 id=&quot;3-5-标准库-bitset&quot;&gt;&lt;a href=&quot;#3-5-标准库-bitset&quot; class=&quot;headerlink&quot; title=&quot;3.5 标准库 bitset&quot;&gt;&lt;/a&gt;3.5 标准库 bitset&lt;/h2&gt;&lt;p&gt;有些程序要处理二进制位的有序集，每个位可能包含 0（关）1（开）值。位是用来保存一组项或条件的 yes/no 信息（有时也称标志）的简洁方法。标准库提供的 bitset 类简化了位集的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
      <category term="bitset" scheme="https://zypsola.com/tags/bitset/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson6</title>
    <link href="https://zypsola.com/2018/10/22/C++Primer6/"/>
    <id>https://zypsola.com/2018/10/22/C++Primer6/</id>
    <published>2018-10-22T13:22:19.000Z</published>
    <updated>2018-11-02T11:53:54.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><h2 id="3-3-标准库-vector-类型"><a href="#3-3-标准库-vector-类型" class="headerlink" title="3.3 标准库 vector 类型"></a>3.3 标准库 vector 类型</h2><p><strong>vector</strong> 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为<strong>容器</strong>，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt; </span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure><p>vector 是一个<strong>类模板（class template）</strong>。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。因此，我们可以定义保存 string 对象的 vector，或保存 int 值的 vector，又或是保存自定义的类类型对象（如 Sales_items 对象）的 vector。</p><p>声明从类模板产生的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以 vector 为例，必须说明 vector 保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;               // ivec holds objects of type int </span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;   // holds Sales_items</span><br></pre></td></tr></table></figure><p>vector 不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，vector&lt;int&gt; 和 vector&lt;string&gt; 都是数据类型。</p><h3 id="3-3-1-vector对象的定义和初始化"><a href="#3-3-1-vector对象的定义和初始化" class="headerlink" title="3.3.1 vector对象的定义和初始化"></a>3.3.1 vector对象的定义和初始化</h3><p>vector 类定义了好几种构造函数，用来定义和初始化 vector 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;        \\vector 保存类型为 T 对象。 默认构造函数 v1 为空。 </span><br><span class="line">vector&lt;T&gt; v2(v1);    \\v2 是 v1 的一个副本。 </span><br><span class="line">vector&lt;T&gt; v3(n, i);  \\v3 包含 n 个值为 i 的元素。 </span><br><span class="line">vector&lt;T&gt; v4(n);     \\v4 含有值初始化的元素的 n 个副本。</span><br></pre></td></tr></table></figure><p><strong>创建确定个数的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec1;           // ivec1 holds objects of type int </span><br><span class="line">vector&lt;int&gt; ivec2(ivec1);    // ok: copy elements of ivec1 into ivec2 </span><br><span class="line">vector&lt;string&gt; svec(ivec1);  // error: svec holds strings, not ints </span><br><span class="line">vector&lt;int&gt; ivec4(10, -1);       // 10 elements, each initialized to -1 </span><br><span class="line">vector&lt;string&gt; svec(10, &quot;hi!&quot;);  // 10 strings, each initialized to &quot;hi!&quot;</span><br></pre></td></tr></table></figure><p>虽然可以对给定元素个数的 vector 对象预先分配内存，但更有效的方法是先初始化一个空 vector 对象，然后再动态地增加元素。</p><p><strong>值初始化</strong></p><p>如果没有指定元素的初始化式，那么标准库将自行提供一个元素初始值进行值初始化（value initializationd）。这个由库生成的初始值将用来初始化容器中的每个元素，具体值为何，取决于存储在 vector 中元素的数据类型。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fvec(10); // 10 elements, each initialized to 0 </span><br><span class="line">vector&lt;string&gt; svec(10); // 10 elements, each an empty string</span><br></pre></td></tr></table></figure><p>一些有自定义构造函数但没有默认构造函数的类，在初始化这种类型的 vector 对象时，程序员就不能仅提供元素个数，还需要提供元素初始值。 </p><h3 id="3-3-2-vector对象的操作"><a href="#3-3-2-vector对象的操作" class="headerlink" title="3.3.2 vector对象的操作"></a>3.3.2 vector对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v.empty()       如果 v 为空，则返回 true，否则返回 false。 </span><br><span class="line">v.size()        返回 v 中元素的个数。 </span><br><span class="line">v.push_back(t)  在 v 的末尾增加一个值为 t 的元素。 </span><br><span class="line">v[n]            返回 v 中位置为 n 的元素。 </span><br><span class="line">v1 = v2         把 v1 的元素替换为 v2 中元素的副本。 </span><br><span class="line">v1 == v2        如果 v1 与 v2 相等，则返回 true。 </span><br><span class="line">!=, &lt;, &lt;=,  &gt;, and &gt;=       保持这些操作符惯有的含义。</span><br></pre></td></tr></table></figure><p>成员函数 size 返回相应 vector 类定义的 size_type 的值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::size_type       // ok </span><br><span class="line">vector::size_type            // error</span><br></pre></td></tr></table></figure><p><strong>下标操作不添加元素</strong></p><h2 id="3-4-迭代器简介"><a href="#3-4-迭代器简介" class="headerlink" title="3.4 迭代器简介"></a>3.4 迭代器简介</h2><p>除了使用下标来访问 vector 对象的元素外，标准库还提供了另一种访问元素的方法：使用<strong>迭代器（iterator）</strong>。迭代器是一种检查容器内元素并遍历元素的数据类型。 </p><p>标准库为每一种标准容器（包括 vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代 C++ 程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的 vector 类型也是这样。 </p><p><strong>容器的iterator类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator iter;</span><br></pre></td></tr></table></figure><p>这符语句定义了一个名为 iter 的变量，它的数据类型是 vector&lt;int&gt; 定义的 iterator 类型。每个标准库容器类型都定义了一个名为 iterator 的成员，这里的 iterator 与迭代器实际类型的含义相同。 </p><p><strong>begin和end操作</strong></p><p>由 begin 返回的迭代器指向第一个元素;由 end 操作返回的迭代器指向 vector 的“末端元素的下一个”。如果 vector 为空，begin 返回的迭代器与 end 返回的迭代器相同。 </p><p>由 end 操作返回的迭代器并不指向 vector 中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完 vector 中所有元素。 </p><p><strong>vector迭代器的自增和解引用运算</strong></p><p>迭代器类型可使用<strong>解引用操作符</strong>（dereference operator）（*）来访问迭代器所指向的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*iter = 0;</span><br></pre></td></tr></table></figure><p>由于 end 操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。 </p><p>另一对可执行于迭代器的操作就是比较：用 == 或 != , &gt; , &lt; , &lt;= , &gt;= 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。 </p><p><strong>const_iterator</strong></p><p>前面的程序用 vector::iterator 改变 vector 中的元素值。每种容器类型还定义了一种名为 const_iterator 的类型，该类型只能用于读取容器内元素，但不能改变其值。 </p><p>不要把 const_iterator 对象与 const 的 iterator 对象混淆起来。声明一个 const 迭代器时，必须初始化迭代器。一旦被初始化后，就不能改变它的值。</p><p>const_iterator 对象可以用于 const vector 或非 const vector，因为不能改写元素值。const 迭代器这种类型几乎没什么用处：一旦它被初始化后，只能用它来改写其指向的元素，但不能使它指向任何其他元素。 </p><h3 id="3-4-1-迭代器的算术操作"><a href="#3-4-1-迭代器的算术操作" class="headerlink" title="3.4.1 迭代器的算术操作"></a>3.4.1 迭代器的算术操作</h3><p>除了一次移动迭代器的一个元素的增量操作符外，vector 迭代器（其他标准库容器迭代器很少）也支持其他的算术操作。这些操作称为迭代器算术操作（iterator arithmetic）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter + n;</span><br><span class="line">iter - n;</span><br><span class="line">iter1 - iter2;</span><br></pre></td></tr></table></figure><p>该表达式用来计算两个迭代器对象的距离，该距离是名为 difference_type 的 signed 类型 size_type 的值，这里的 difference_type 是 signed 类型，因为减法运算可能产生负数的结果。该类型可以保证足够大以存储任何两个迭代器对象间的距离。两个迭代器相加的操作是未定义的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::difference_type dis;</span><br></pre></td></tr></table></figure><p>任何改变 vector 长度的操作都会使已存在的迭代器失效。例如，在调用 push_back 之后，就不能再信赖指向 vector 的迭代器的值了。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;h2 id=&quot;3-3-标准库-vector-类型&quot;&gt;&lt;a href=&quot;#3-3-标准库-vector-类型&quot; class=&quot;headerlink&quot; title=&quot;3.3 标准库 vector 类型&quot;&gt;&lt;/a&gt;3.3 标准库 vector 类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;vector&lt;/strong&gt; 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为&lt;strong&gt;容器&lt;/strong&gt;，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
      <category term="vecter" scheme="https://zypsola.com/tags/vecter/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson5</title>
    <link href="https://zypsola.com/2018/10/22/C++Primer5/"/>
    <id>https://zypsola.com/2018/10/22/C++Primer5/</id>
    <published>2018-10-22T05:06:25.000Z</published>
    <updated>2018-10-22T13:24:51.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><p>除第二章介绍的基本数据类型外，C++ 还定义了一个内容丰富的抽象数据类型标准库。其中最重要的标准库类型是 <strong>string</strong> 和 <strong>vector</strong>，它们分别定义了大小可变的字符串和集合。string 和 vector 往往将迭代器用作配套类型（companion type），用于访问 string 中的字符，或者 vector 中的元素。这些标准库类型是语言组成部分中更基本的那些数据类型（如数组和指针）的抽象。</p><a id="more"></a><p>另一种标准库类型 bitset，提供了一种抽象方法来操作位的集合。与整型值上的内置位操作符相比，bitset 类类型提供了一种更方便的处理位的方式。 </p><h2 id="3-1-命名空间的-using-声明"><a href="#3-1-命名空间的-using-声明" class="headerlink" title="3.1 命名空间的 using 声明"></a>3.1 命名空间的 using 声明</h2><p>从标准输入读取数据时，就用 std::cin。这些名字都用了:: 操作符，该操作符是作用域操作符。它的含义是右操作数的名字可以在左操作数的作用域中找到。</p><p>C++ 提供了更简洁的方式来使用命名空间成员。本节将介绍一种最安全的机制：<strong>using 声明</strong>。</p><p>using 声明的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace::name;</span><br></pre></td></tr></table></figure><p>一旦使用了 using 声明，我们就可以直接引用名字，而不需要再引用该名字的命名空间。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using std::cin; </span><br><span class="line">using std::string; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    string s;       // ok: string is now a synonym for std::string </span><br><span class="line">    cin &gt;&gt; s;       // ok: cin is now a synonym for std::cin </span><br><span class="line">    cout &lt;&lt; s;      // error: no using declaration; we must use full name </span><br><span class="line">    std::cout &lt;&lt; s; // ok: explicitly use cout from namepsace std </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种情况下，必须总是使用完全限定的标准库名字：<strong>在头文件中</strong>。理由是头文件的内容会被预处理器复制到程序中。用 #include 包含文件时，相当于头文件中的文本将成为我们编写的文件的一部分。如果在头文件中放置 using 声明，就相当于在包含该头文件 using 的每个程序中都放置了同一 using，不论该程序是否需要 using 声明。 </p><h2 id="3-2-标准库-string-类型"><a href="#3-2-标准库-string-类型" class="headerlink" title="3.2 标准库 string 类型"></a>3.2 标准库 string 类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt; </span><br><span class="line">using std::string;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-string对象的定义和初始化"><a href="#3-2-1-string对象的定义和初始化" class="headerlink" title="3.2.1 string对象的定义和初始化"></a>3.2.1 string对象的定义和初始化</h3><p>string 标准库支持几个构造函数。当没有明确指定对象初始化式时，系统将使用默认构造函数。</p><p><strong>string 类型常用的构造函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;           //默认构造函数，s1 为空串</span><br><span class="line">string s2(s1);       //将 s2 初始化为 s1 的一个副本</span><br><span class="line">string s3(&quot;value&quot;);  //将 s3 初始化为一个字符串字面值副本</span><br><span class="line">string s4(n, &apos;c&apos;);   //将 s4 初始化为字符 &apos;c&apos; 的 n 个副本</span><br></pre></td></tr></table></figure><p>因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。</p><h3 id="3-2-2-string-对象的读写"><a href="#3-2-2-string-对象的读写" class="headerlink" title="3.2.2 string 对象的读写"></a>3.2.2 string 对象的读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;          // empty string </span><br><span class="line">cin &gt;&gt; s;          // read whitespace-separated string into s </span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; // write s to the output</span><br></pre></td></tr></table></figure><p>从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符： </p><ol><li>读取并忽略开头所有的空白字符（如空格，换行符，制表符）。</li><li>读取字符直至再次遇到空白字符，读取终止。</li></ol><p><strong>读入未知数目的string对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string sss;</span><br><span class="line">while (cin &gt;&gt; sss)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sss &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用getline读取整行文本</strong></p><p>另外还有一个有用的 string IO 操作：getline。这个函数接受两个参数：一个输入流对象和一个 string 对象。getline 函数从输入流的下一行读取，并保存读取的内容到不包括换行符。和输入操作符不一样的是，getline 并不忽略行开头的换行符。只要 getline 遇到换行符，即便它是输入的第一个字符，getline 也将停止读入并返回。如果第一个字符就是换行符，则 string 参数将被置为空 string。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string sss;</span><br><span class="line">while (getline(cin, sss))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sss &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getline 函数将 istream 参数作为返回值，和输入操作符一样也把它用作判断条件。</p><h3 id="3-2-3-string对象的操作"><a href="#3-2-3-string对象的操作" class="headerlink" title="3.2.3 string对象的操作"></a>3.2.3 string对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.empty()       //如果 s 为空串，则返回 true，否则返回 false。</span><br><span class="line">s.size()        //返回 s 中字符的个数 </span><br><span class="line">s[n]            //返回 s 中位置为 n 的字符，位置从 0 开始计数</span><br><span class="line">s1 + s2         //把 s1 和 s2 连接成一个新字符串，返回新生成的字符串</span><br><span class="line">s1 = s2         //把 s1 内容替换为 s2 的副本</span><br><span class="line">v1 == v2        //比较 v1 与 v2 的内容，相等则返回 true，否则返回 false </span><br><span class="line">!=,&lt;,&gt;,&lt;=,&gt;=    //保持这些操作符惯有的含义</span><br></pre></td></tr></table></figure><p><strong>string::size_type类型</strong></p><p>从逻辑上来讲，size() 成员函数似乎应该返回整形数值，或如 2.2 节“建议”中所述的无符号整数。但事实上，size 操作返回的是 string::size_type 类型的值。</p><p>string 类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine-independent）。<br>size_type 就是这些配套类型中的一种。它定义为与 unsigned 型（unsigned int 或 unsigned long）具有相同的含义，而且可以保证足够大能够存储任意 string 对象的长度。为了使用由 string 类型定义的 size_type 类型是由 string 类定义。 </p><p><strong>string 关系操作符</strong></p><p>string 对象比较操作是区分大小写的，即同一个字符的大小写形式被认为是两个不同的字符。在多数计算机上，大写的字母位于小写之前：任何一个大写之母都小于任意的小写字母。</p><p>如果两个 string 对象长度不同，且短的 string 对象与长的 string 对象的前面部分相匹配，则短的 string 对象小于长的 string 对象。 </p><p>如果 string 对象的字符不同，则比较第一个不匹配的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string substr = &quot;Hello&quot;; </span><br><span class="line">string phrase = &quot;Hello World&quot;; </span><br><span class="line">string slang  = &quot;Hiya&quot;;</span><br></pre></td></tr></table></figure><p>则 substr 小于 phrase，而 slang 则大于 substr 或 phrase</p><p><strong>两个string对象相加</strong></p><p>string 对象的加法被定义为连接（concatenation）。也就是说，两个（或多个）string 对象可以通过使用加操作符 + 或者复合赋值操作符 += 连接起来。</p><p><strong>和字符串字面值的连接</strong></p><p>可以通过将 string 对象和字符串字面值混合连接得到同样的结果。</p><p>当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;hello&quot;;   // no punctuation </span><br><span class="line">string s2 = &quot;world&quot;; </span><br><span class="line">string s3 = s1 + &quot;, &quot;;           // ok: adding a string and a literal </span><br><span class="line">string s4 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operand </span><br><span class="line">string s5 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has string operand </span><br><span class="line">string s6 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can&apos;t add string literals</span><br></pre></td></tr></table></figure><p><strong>从string对象获取字符</strong></p><p>string 类型通过下标操作符（[ ]）来访问 string 对象中的单个字符。下标操作符需要取一个 size_type 类型的值，来标明要访问字符的位置。这个下标中的值通常被称为“下标”或“索引”（index）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (string::size_type ix = 0; ix != str.size(); ++ix) </span><br><span class="line">    str[ix] = &apos;*&apos;;</span><br></pre></td></tr></table></figure><p>任何可产生整型值的表达式可用作下标操作符的索引。</p><p>标准库不要求检查索引值，所用索引的下标越界是没有定义的，这样往往会导致严重的运行时错误。 </p><h2 id="3-2-4-string对象中字符的处理"><a href="#3-2-4-string对象中字符的处理" class="headerlink" title="3.2.4 string对象中字符的处理"></a>3.2.4 string对象中字符的处理</h2><p>我们经常要对 string 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。下列出了各种字符操作函数，适用于 string 对象的字符（或其他任何 char 值）。这些函数都在 <strong>cctype 头文件</strong>中定义。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)   //如果 c 是字母或数字，则为 True。 </span><br><span class="line">isalpha(c)   //如果 c 是字母，则为 true。 </span><br><span class="line">iscntrl(c)   //如果 c 是控制字符，则为 true  </span><br><span class="line">isdigit(c)   //如果 c 是数字，则为 true。 </span><br><span class="line">isgraph(c)   //如果 c 不是空格，但可打印，则为 true。 </span><br><span class="line">islower(c)   //如果 c 是小写字母，则为 true。 </span><br><span class="line">isprint(c)   //如果 c 是可打印的字符，则为 true。 </span><br><span class="line">ispunct(c)   //如果 c 是标点符号，则 true。 </span><br><span class="line">isspace(c)   //如果 c 是空白字符，则为 true。 </span><br><span class="line">isupper(c)   //如果 c 是大写字母，则 true。 </span><br><span class="line">isxdigit(c)  //如果是 c 十六进制数，则为 true。 </span><br><span class="line">tolower(c)   //如果 c 大写字母，返回其小写字母形式，否则直接返回 c。 </span><br><span class="line">toupper(c)   //如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c</span><br></pre></td></tr></table></figure><p>可打印的字符是指那些可以表示的字符，空白字符则是空格、制表符、垂直制表符、回车符、换行符和进纸符中的任意一种；标点符号则是除了数字、字母或（可打印的）空白字符（如空格）以外的其他可打印字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;p&gt;除第二章介绍的基本数据类型外，C++ 还定义了一个内容丰富的抽象数据类型标准库。其中最重要的标准库类型是 &lt;strong&gt;string&lt;/strong&gt; 和 &lt;strong&gt;vector&lt;/strong&gt;，它们分别定义了大小可变的字符串和集合。string 和 vector 往往将迭代器用作配套类型（companion type），用于访问 string 中的字符，或者 vector 中的元素。这些标准库类型是语言组成部分中更基本的那些数据类型（如数组和指针）的抽象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson4</title>
    <link href="https://zypsola.com/2018/10/21/C++Primer4/"/>
    <id>https://zypsola.com/2018/10/21/C++Primer4/</id>
    <published>2018-10-21T13:18:45.000Z</published>
    <updated>2018-10-22T07:36:48.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-8-类类型"><a href="#2-8-类类型" class="headerlink" title="2.8 类类型"></a>2.8 类类型</h2><p>C++ 中，通过定义类来自定义数据类型。类定义了该类型的对象包含的数据和该类型的对象可以执行的操作。</p><p>每个类都定义了一个<strong>接口</strong>和一个<strong>实现</strong>。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。 </p><a id="more"></a><p>类体可以为空。类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员。操作称为成员函数，而数据则称为<strong>数据成员</strong>。 </p><p>定义变量和定义数据成员存在非常重要的区别：一般不能把类成员的初始化作为其定义的一部分。当定义数据成员时，只能指定该数据成员的名字和类型。类不是在类定义里定义数据成员时初始化数据成员，而是通过称为构造函数的特殊成员函数控制初始化。</p><p><strong>使用struct关键字</strong></p><p>C++ 支持另一个关键字 struct，它也可以定义类类型。struct 关键字是从 C 语言中继承过来的。 </p><p>如果使用 class 关键字来定义类，那么定义在第一个访问标号前的任何成员都隐式指定为 private；如果使用 struct 关键字，那么这些成员都是 public。使用 class 还是 struct 关键字来定义类，仅仅影响默认的初始访问级别。 </p><h2 id="2-9-编写自己的头文件"><a href="#2-9-编写自己的头文件" class="headerlink" title="2.9 编写自己的头文件"></a>2.9 编写自己的头文件</h2><p>一般类定义都会放入<strong>头文件</strong>。</p><p>头文件一般包含类的定义、extern 变量的声明和函数的声明。</p><p>因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。 </p><p>对于头文件不应该含有定义这一规则，有三个例外。头文件可以定义类、值在编译时就已知道的 const 对象和 inline 函数。这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。 </p><p>在头文件中定义这些实体，是因为编译器需要它们的定义（不只是声明）来产生代码。例如：为了产生能定义或使用类的对象的代码，编译器需要知道组成该类型的数据成员。同样还需要知道能够在这些对象上执行的操作。类定义提供所需要的信息。在头文件中定义 const 对象则需要更多的解释。 </p><p>当我们在头文件中定义了 const 变量后，每个包含该头文件的源文件都有了自己的 const 变量，其名称和值都一样。 </p><p>当该 const 变量是用常量表达式初始化时，可以保证所有的变量都有相同的值。</p><p>如果 const 变量不是用常量表达式初始化，那么它就不应该在头文件中定义。相反，和其他的变量一样，该 const 变量应该在一个源文件中定义并初始化。应在头文件中为它添加 extern 声明，以使其能被多个文件共享。 </p><h3 id="预处理器的简单介绍"><a href="#预处理器的简单介绍" class="headerlink" title="预处理器的简单介绍"></a>预处理器的简单介绍</h3><p>#include 设施是 C++ 预处理器的一部分。预处理器处理程序的源代码，在编译器之前运行。C++ 继承了 C 的非常精细的预处理器。现在的 C++ 程序以高度受限的方式使用预处理器。 </p><p>#include 指示只接受一个参数：头文件名。预处理器用指定的头文件的内容替代每个 #include。</p><p>我们必须保证多次包含同一头文件不会引起该头文件定义的类和对象被多次定义。使得头文件安全的通用做法，是使用预处理器定义<strong>头文件保护符</strong>。</p><p><strong>预处理器变量</strong> 的名字在程序中必须是唯一的。为了避免名字冲突，预处理器变量经常用全大写字母表示。 </p><p>预处理器变量有两种状态：已定义或未定义。定义预处理器变量和检测其状态所用的预处理器指示不同。#define 指示接受一个名字并定义该名字为预处理器变量。#ifndef 指示检测指定的预处理器变量是否未定义。如果预处理器变量未定义，那么跟在其后的所有指示都被处理，直到出现 #endif。 </p><p>可以使用这些设施来预防多次包含同一头文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H </span><br><span class="line">#define SALESITEM_H </span><br><span class="line">// Definition of Sales_itemclass and related functions goes here </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>条件指示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H</span><br></pre></td></tr></table></figure><p>测试 SALESITEM_H 预处理器变量是否未定义。如果 SALESITEM_H 未定义，那么 #ifndef 测试成功，跟在 #ifndef 后面的所有行都被执行，直到发现 #endif。相反，如果 SALESITEM_H 已定义，那么 #ifndef 指示测试为假，该指示和 #endif 指示间的代码都被忽略。 </p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h2><ol><li><p><strong>access labels（访问标号）：</strong>类的成员可以定义为 private，这能够防止使用该类型的代码访问该成员。成员还可以定义为 public，这将使该整个程序中都可访问成员。 </p></li><li><p><strong>implementation（实现）：</strong>定义数据和操作的类成员（通常为 private），这些数据和操作并非为使用该类型的代码所用。例如，istream 和 ostream 类管理的 IO 缓冲区是它们的实现的一部分，但并不允许这些类的使用者直接访问。 </p></li><li><p><strong>interface（接口）：</strong>由某种类型支持的操作。设计良好的类分离了接口和实现，在类的 public 部分定义接口，private 部分定义实现。数据成员一般是实现的一部分。当函数成员是期望该类型的使用者使用的操作时，函数成员就是接口的一部分（因此为 public）；当函数成员执行类所需要的、非一般性使用的操作时，函数成员就是实现的一部分。 </p></li><li><p><strong>link（链接）：</strong>一个编译步骤，此时多个目标文件放置在一起以形成可执行程序。链接步骤解决了文件间的依赖，如将一个文件中的函数调用链接到另一个文件中的函数定义。 </p></li><li><p><strong>type-checking（类型检查）：</strong>编译器验证给定类型的对象的使用方式是否与该类型的定义一致，描述这一过程的术语。 </p></li><li><p><strong>word（字）：</strong>机器上的自然的整型计算单元。通常一个字足以容纳一个地址。一般在 32 位的机器上，机器字长为 4 个字节。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;h2 id=&quot;2-8-类类型&quot;&gt;&lt;a href=&quot;#2-8-类类型&quot; class=&quot;headerlink&quot; title=&quot;2.8 类类型&quot;&gt;&lt;/a&gt;2.8 类类型&lt;/h2&gt;&lt;p&gt;C++ 中，通过定义类来自定义数据类型。类定义了该类型的对象包含的数据和该类型的对象可以执行的操作。&lt;/p&gt;
&lt;p&gt;每个类都定义了一个&lt;strong&gt;接口&lt;/strong&gt;和一个&lt;strong&gt;实现&lt;/strong&gt;。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空之境界</title>
  
  <subtitle>ZYP&#39;s BLOG</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zypsola.com/"/>
  <updated>2018-10-22T07:34:00.840Z</updated>
  <id>https://zypsola.com/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ Lesson5</title>
    <link href="https://zypsola.com/2018/10/22/C++Primer5/"/>
    <id>https://zypsola.com/2018/10/22/C++Primer5/</id>
    <published>2018-10-22T05:06:25.000Z</published>
    <updated>2018-10-22T07:34:00.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><p>除第二章介绍的基本数据类型外，C++ 还定义了一个内容丰富的抽象数据类型标准库。其中最重要的标准库类型是 string 和 vector，它们分别定义了大小可变的字符串和集合。string 和 vector 往往将迭代器用作配套类型（companion type），用于访问 string 中的字符，或者 vector 中的元素。这些标准库类型是语言组成部分中更基本的那些数据类型（如数组和指针）的抽象。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;p&gt;除第二章介绍的基本数据类型外，C++ 还定义了一个内容丰富的抽象数据类型标准库。其中最重要的标准库类型是 string 和 vector，它们分别定义了大小可变的字符串和集合。string 和 vector 往往将迭代器用作配套类型（companion type），用于访问 string 中的字符，或者 vector 中的元素。这些标准库类型是语言组成部分中更基本的那些数据类型（如数组和指针）的抽象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson4</title>
    <link href="https://zypsola.com/2018/10/21/C++Primer4/"/>
    <id>https://zypsola.com/2018/10/21/C++Primer4/</id>
    <published>2018-10-21T13:18:45.000Z</published>
    <updated>2018-10-22T07:36:48.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-8-类类型"><a href="#2-8-类类型" class="headerlink" title="2.8 类类型"></a>2.8 类类型</h2><p>C++ 中，通过定义类来自定义数据类型。类定义了该类型的对象包含的数据和该类型的对象可以执行的操作。</p><p>每个类都定义了一个<strong>接口</strong>和一个<strong>实现</strong>。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。 </p><a id="more"></a><p>类体可以为空。类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员。操作称为成员函数，而数据则称为<strong>数据成员</strong>。 </p><p>定义变量和定义数据成员存在非常重要的区别：一般不能把类成员的初始化作为其定义的一部分。当定义数据成员时，只能指定该数据成员的名字和类型。类不是在类定义里定义数据成员时初始化数据成员，而是通过称为构造函数的特殊成员函数控制初始化。</p><p><strong>使用struct关键字</strong></p><p>C++ 支持另一个关键字 struct，它也可以定义类类型。struct 关键字是从 C 语言中继承过来的。 </p><p>如果使用 class 关键字来定义类，那么定义在第一个访问标号前的任何成员都隐式指定为 private；如果使用 struct 关键字，那么这些成员都是 public。使用 class 还是 struct 关键字来定义类，仅仅影响默认的初始访问级别。 </p><h2 id="2-9-编写自己的头文件"><a href="#2-9-编写自己的头文件" class="headerlink" title="2.9 编写自己的头文件"></a>2.9 编写自己的头文件</h2><p>一般类定义都会放入<strong>头文件</strong>。</p><p>头文件一般包含类的定义、extern 变量的声明和函数的声明。</p><p>因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。 </p><p>对于头文件不应该含有定义这一规则，有三个例外。头文件可以定义类、值在编译时就已知道的 const 对象和 inline 函数。这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。 </p><p>在头文件中定义这些实体，是因为编译器需要它们的定义（不只是声明）来产生代码。例如：为了产生能定义或使用类的对象的代码，编译器需要知道组成该类型的数据成员。同样还需要知道能够在这些对象上执行的操作。类定义提供所需要的信息。在头文件中定义 const 对象则需要更多的解释。 </p><p>当我们在头文件中定义了 const 变量后，每个包含该头文件的源文件都有了自己的 const 变量，其名称和值都一样。 </p><p>当该 const 变量是用常量表达式初始化时，可以保证所有的变量都有相同的值。</p><p>如果 const 变量不是用常量表达式初始化，那么它就不应该在头文件中定义。相反，和其他的变量一样，该 const 变量应该在一个源文件中定义并初始化。应在头文件中为它添加 extern 声明，以使其能被多个文件共享。 </p><h3 id="预处理器的简单介绍"><a href="#预处理器的简单介绍" class="headerlink" title="预处理器的简单介绍"></a>预处理器的简单介绍</h3><p>#include 设施是 C++ 预处理器的一部分。预处理器处理程序的源代码，在编译器之前运行。C++ 继承了 C 的非常精细的预处理器。现在的 C++ 程序以高度受限的方式使用预处理器。 </p><p>#include 指示只接受一个参数：头文件名。预处理器用指定的头文件的内容替代每个 #include。</p><p>我们必须保证多次包含同一头文件不会引起该头文件定义的类和对象被多次定义。使得头文件安全的通用做法，是使用预处理器定义<strong>头文件保护符</strong>。</p><p><strong>预处理器变量</strong> 的名字在程序中必须是唯一的。为了避免名字冲突，预处理器变量经常用全大写字母表示。 </p><p>预处理器变量有两种状态：已定义或未定义。定义预处理器变量和检测其状态所用的预处理器指示不同。#define 指示接受一个名字并定义该名字为预处理器变量。#ifndef 指示检测指定的预处理器变量是否未定义。如果预处理器变量未定义，那么跟在其后的所有指示都被处理，直到出现 #endif。 </p><p>可以使用这些设施来预防多次包含同一头文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H </span><br><span class="line">#define SALESITEM_H </span><br><span class="line">// Definition of Sales_itemclass and related functions goes here </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>条件指示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H</span><br></pre></td></tr></table></figure><p>测试 SALESITEM_H 预处理器变量是否未定义。如果 SALESITEM_H 未定义，那么 #ifndef 测试成功，跟在 #ifndef 后面的所有行都被执行，直到发现 #endif。相反，如果 SALESITEM_H 已定义，那么 #ifndef 指示测试为假，该指示和 #endif 指示间的代码都被忽略。 </p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h2><ol><li><p><strong>access labels（访问标号）：</strong>类的成员可以定义为 private，这能够防止使用该类型的代码访问该成员。成员还可以定义为 public，这将使该整个程序中都可访问成员。 </p></li><li><p><strong>implementation（实现）：</strong>定义数据和操作的类成员（通常为 private），这些数据和操作并非为使用该类型的代码所用。例如，istream 和 ostream 类管理的 IO 缓冲区是它们的实现的一部分，但并不允许这些类的使用者直接访问。 </p></li><li><p><strong>interface（接口）：</strong>由某种类型支持的操作。设计良好的类分离了接口和实现，在类的 public 部分定义接口，private 部分定义实现。数据成员一般是实现的一部分。当函数成员是期望该类型的使用者使用的操作时，函数成员就是接口的一部分（因此为 public）；当函数成员执行类所需要的、非一般性使用的操作时，函数成员就是实现的一部分。 </p></li><li><p><strong>link（链接）：</strong>一个编译步骤，此时多个目标文件放置在一起以形成可执行程序。链接步骤解决了文件间的依赖，如将一个文件中的函数调用链接到另一个文件中的函数定义。 </p></li><li><p><strong>type-checking（类型检查）：</strong>编译器验证给定类型的对象的使用方式是否与该类型的定义一致，描述这一过程的术语。 </p></li><li><p><strong>word（字）：</strong>机器上的自然的整型计算单元。通常一个字足以容纳一个地址。一般在 32 位的机器上，机器字长为 4 个字节。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;h2 id=&quot;2-8-类类型&quot;&gt;&lt;a href=&quot;#2-8-类类型&quot; class=&quot;headerlink&quot; title=&quot;2.8 类类型&quot;&gt;&lt;/a&gt;2.8 类类型&lt;/h2&gt;&lt;p&gt;C++ 中，通过定义类来自定义数据类型。类定义了该类型的对象包含的数据和该类型的对象可以执行的操作。&lt;/p&gt;
&lt;p&gt;每个类都定义了一个&lt;strong&gt;接口&lt;/strong&gt;和一个&lt;strong&gt;实现&lt;/strong&gt;。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson3</title>
    <link href="https://zypsola.com/2018/10/20/C++Primer3/"/>
    <id>https://zypsola.com/2018/10/20/C++Primer3/</id>
    <published>2018-10-20T12:27:10.000Z</published>
    <updated>2018-10-22T07:36:39.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>C++ 是一门静态类型语言，在编译时会作类型检查。 </p><p>在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。 </p><a id="more"></a><p>在 C++ 中，操作是否合法是在编译时检查的。当编写表达式时，编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话，那么编译器会提示错误，而不产生可执行文件。 </p><p>随着程序和使用的类型变得越来越复杂，我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此，程序中使用变量前必须先定义变量的类型 </p><h3 id="2-3-1-什么是变量"><a href="#2-3-1-什么是变量" class="headerlink" title="2.3.1 什么是变量"></a>2.3.1 什么是变量</h3><p>变量提供了程序可以操作的有名字的存储区。C++ 中的每一个变量都有特定的类型，该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。C++ 程序员常常把变量称为“变量”或“对象（object）”。 </p><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a><strong>左值和右值</strong></h3><p><strong>左值（lvalue）</strong>：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。<br><strong>右值（rvalue）</strong>：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</p><p><strong>什么是对象？</strong></p><p>C++ 程序员经常随意地使用术语对象。一般而言，对象就是内存中具有类型的区域。说得更具体一些，计算左值表达式就会产生对象。 </p><p>严格地说，有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象，当谈到有名字的对象时一般指变量。还有一些人区分对象和值，用术语对象描述可被程序改变的数据，用术语值描述只读数据。 </p><p>在本书中，我们遵循更为通用的用法，即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据，而不管这些数据是内置类型还是类类型，是有名字的还是没名字的，是可读的还是可写的。 </p><h3 id="2-3-2-变量名"><a href="#2-3-2-变量名" class="headerlink" title="2.3.2 变量名"></a>2.3.2 变量名</h3><p>变量名，即变量的<strong>标识符</strong>，可以由字母、数字和下划线组成。变量名必须以字母或下划线开头，并且区分大小写字母：C++ 中的标识符都是大小写敏感的。</p><p>C++ 保留了一组词用作该语言的关键字。关键字不能用作程序的标识符。</p><p>C++ 还保留了一些词用作各种操作符的替代名。这些替代名用于支持某些不支持标准 C++操作符号集的字符集。它们也不能用作标识符。</p><h3 id="2-3-3-定义对象"><a href="#2-3-3-定义对象" class="headerlink" title="2.3.3 定义对象"></a>2.3.3 定义对象</h3><p><strong>初始化</strong><br>变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时指定了初始值的对象被称为是<strong>已初始化的</strong>。C++ 支持两种初始化变量的形式：<strong>复制初始化</strong>和<strong>直接初始化</strong>。复制初始化语法用等号（=），直接初始化则是把初始化式放在括号中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival(1024);     // direct-initialization </span><br><span class="line">int ival = 1024;    // copy-initialization</span><br></pre></td></tr></table></figure><p>在 C++ 中理解“初始化不是赋值”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。 </p><p>当初始化类类型对象时，复制初始化和直接初始化之间的差别是很微妙的，直接初始化语法更灵活且效率更高。 </p><h3 id="2-3-4-变量初始化规则"><a href="#2-3-4-变量初始化规则" class="headerlink" title="2.3.4 变量初始化规则"></a>2.3.4 变量初始化规则</h3><p>内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，<strong>未初始化</strong>变量用作任何其他用途都是没有定义的。</p><h3 id="2-3-4-声明和定义"><a href="#2-3-4-声明和定义" class="headerlink" title="2.3.4 声明和定义"></a>2.3.4 声明和定义</h3><p>C++ 程序通常由许多文件组成。为了让多个文件访问相同的变量，C++ 区分了声明和定义。 </p><p>变量的<strong>定义</strong>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。 </p><p><strong>声明</strong>用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用 extern 关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字 extern：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i;   // declares but does not define i </span><br><span class="line">int i;          //  declares and defines i</span><br></pre></td></tr></table></figure><p>extern 声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。<strong>程序中变量可以声明多次，但只能定义一次。</strong></p><p>只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为 extern：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern double pi = 3.1416; // definition</span><br></pre></td></tr></table></figure><p>虽然使用了 extern ，但是这条语句还是定义了 pi，分配并初始化了存储空间。只有当 extern 声明位于函数外部时，才可以含有初始化式。 </p><p>任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。 </p><h3 id="2-3-6-名字的作用域"><a href="#2-3-6-名字的作用域" class="headerlink" title="2.3.6 名字的作用域"></a>2.3.6 名字的作用域</h3><p><strong>C++ 中作用域可嵌套</strong></p><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>const 把一个对象转换成一个常量。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512; // input buffer size</span><br></pre></td></tr></table></figure><p>定义 bufSize 为常量并初始化为 512。变量 bufSize 仍然是一个左值，但是现在这个左值是不可修改的。任何修改 bufSize 的尝试都会导致编译错误。</p><p>因为常量在定义后就不能被修改，所以定义时必须初始化。</p><p><strong>const 对象默认为文件的局部变量</strong></p><p>在全局作用域里定义非 const 变量时，它在整个程序中都可以访问。与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。</p><p>通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// file_1.cc </span><br><span class="line">extern const int bufSize = fcn(); </span><br><span class="line">// file_2.cc </span><br><span class="line">extern const int bufSize;</span><br><span class="line">for (int index = 0; index != bufSize; ++index)</span><br></pre></td></tr></table></figure><p>非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须地指定它为 extern。 </p><h2 id="2-5-引用"><a href="#2-5-引用" class="headerlink" title="2.5 引用"></a>2.5 引用</h2><p><strong>引用</strong>就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。</p><p>引用是一种<strong>复合类型</strong>，通过在变量名前添加“&amp;”符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义任何其他类型的引用</p><p>引用必须用与该引用同类型的对象初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024; </span><br><span class="line">int &amp;refVal = ival; // ok: refVal refers to ival </span><br><span class="line">int &amp;refVal2;       // error: a reference must be initialized </span><br><span class="line">int &amp;refVal3 = 10;  // error: initializer must be an object</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**引用是别名**</span><br><span class="line"></span><br><span class="line">因为引用只是它绑定的对象的另一名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。</span><br><span class="line"></span><br><span class="line">**const 引用**是指向 const 对象的引用：</span><br></pre></td></tr></table></figure><p>const int ival = 1024;<br>const int &amp;refVal = ival;      // ok: both reference and object are const<br>int &amp;ref2 = ival;              // error: non const reference to a const objec<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const 引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量：</span><br></pre></td></tr></table></figure></p><p>int i = 42;<br>//  legal for const references only<br>const int &amp;r = 42;<br>const int &amp;r2 = r + i;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同样的初始化对于非 const 引用却是不合法的，而且会导致编译时错误。</span><br><span class="line"></span><br><span class="line">观察将引用绑定到不同的类型时所发生的事情，最容易理解上述行为。假如我们编写：</span><br></pre></td></tr></table></figure></p><p>double dval = 3.14;<br>const int &amp;ri = dval;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译器会把这些代码转换成如以下形式的编码：</span><br></pre></td></tr></table></figure></p><p>int temp = dval;        // create temporary int from the double<br>const int &amp;ri = temp;   // bind ri to that temporary<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果 ri 不是 const，那么可以给 ri 赋一新值。这样做不会修改 dval，而是修改了 temp。期望对 ri 的赋值会修改 dval 的程序员会发现 dval 并没有被修改。仅允许 const 引用绑定到需要临时使用的值完全避免了这个问题，因为 const 引用是只读的。</span><br><span class="line"></span><br><span class="line">非 const 引用只能绑定到与该引用同类型的对象。</span><br><span class="line"></span><br><span class="line">const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</span><br><span class="line"></span><br><span class="line">## 2.6 typedef 名字</span><br><span class="line"></span><br><span class="line">typedef 可以用来定义类型的同义词：</span><br></pre></td></tr></table></figure></p><p>typedef double wages;       //  wages is a synonym for double<br>typedef int exam_score;     //  exam_score is a synonym for int<br>typedef wages salary;       //  indirect synonym for double<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef 定义以关键字 typedef 开始，后面是数据类型和标识符。标识符或类型名并没有引入新的类型，而只是现有数据类型的同义词。typedef 名字可出现在程序中类型名可出现的任何位置。 </span><br><span class="line"></span><br><span class="line">typedef 通常被用于以下三种目的：</span><br><span class="line">1. 为了隐藏特定类型的实现，强调使用类型的目的。 </span><br><span class="line">2. 简化复杂的类型定义，使其更易理解。 </span><br><span class="line">3. 允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。</span><br><span class="line"></span><br><span class="line">## 2.7 枚举</span><br><span class="line"></span><br><span class="line">枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员列表。 </span><br><span class="line"></span><br><span class="line">默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大 1。 </span><br><span class="line"></span><br><span class="line">**枚举成员是常量**</span><br><span class="line"></span><br><span class="line">可以为一个或多个枚举成员提供初始值，用来初始化枚举成员的值必须是一个常量表达式。常量表达式是编译器在编译时就能够计算出结果的整型表达式。</span><br></pre></td></tr></table></figure></p><p>enum Forms {shape = 1, sphere, cylinder, polygon};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 枚举类型 Forms 中，显式将 shape 赋值为 1。其他枚举成员隐式初始化：sphere 初始化为 2，cylinder 初始化为 3，polygon 初始化为 4。 </span><br><span class="line"></span><br><span class="line">枚举成员值可以是不唯一的。</span><br></pre></td></tr></table></figure></p><p>enum Points { point2d = 2, point2w, point3d = 3, point3w };<br><code>`</code></p><p>本例中，枚举成员 point2d 显式初始化为 2。下一个枚举成员 point2w 默认初始化，即它的值比前一枚举成员的值大 1。因此 point2w 初始化为 3。枚举成员 point3d 显式初始化为 3。一样，point3w 默认初始化，结果为 4。 </p><p>不能改变枚举成员的值。枚举成员本身就是一个常量表达式，所以也可用于需要常量表达式的任何地方。 </p><p><strong>每个 enum 都定义一种唯一的类型</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;h2 id=&quot;2-3-变量&quot;&gt;&lt;a href=&quot;#2-3-变量&quot; class=&quot;headerlink&quot; title=&quot;2.3 变量&quot;&gt;&lt;/a&gt;2.3 变量&lt;/h2&gt;&lt;p&gt;C++ 是一门静态类型语言，在编译时会作类型检查。 &lt;/p&gt;
&lt;p&gt;在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson2</title>
    <link href="https://zypsola.com/2018/10/20/C++Primer2/"/>
    <id>https://zypsola.com/2018/10/20/C++Primer2/</id>
    <published>2018-10-20T05:40:10.000Z</published>
    <updated>2018-10-21T10:25:15.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><p>类型是所有程序的基础。类型告诉我们数据代表什么意思以及可以对数据执行哪些操作。<br>C++ 语言定义了几种基本类型：字符型、整型、浮点型等。C++ 还提供了可用于自定义数据类型的机制，标准库正是利用这些机制定义了许多更复杂的类型，比如可变长字符串 string、vector 等。此外，我们还能修改已有的类型以形成复合类型。</p><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><a id="more"></a><ol><li><p>C++ 定义了一组表示整数、浮点数、单个字符和布尔值的算术类型，另外还定义了一种称为 void 的特殊类型。void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。 </p></li><li><p>算术类型的存储空间依机器而定。这里的存储空间是指用来表示该类型的位（bit）数。C++标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间。事实上，对于 int 类型，几乎所有的编译器使用的存储空间都比所要求的大。</p></li></ol><h3 id="2-1-1-整型"><a href="#2-1-1-整型" class="headerlink" title="2.1.1 整型"></a>2.1.1 整型</h3><p>表示整数、字符和布尔值的算术类型合称为<strong>整型</strong>。</p><h3 id="2-1-2-浮点型"><a href="#2-1-2-浮点型" class="headerlink" title="2.1.2 浮点型"></a>2.1.2 浮点型</h3><p>类型 float、 double 和 long double 分别表示单精度浮点数、双精度浮点数和扩展精度浮点数。</p><h2 id="2-2-字面值常量"><a href="#2-2-字面值常量" class="headerlink" title="2.2 字面值常量"></a>2.2 字面值常量</h2><p>像 42 这样的值，在程序中被当作字面值常量。称之为字面值是因为只能用它的值称呼它，称之为常量是因为它的值不能修改。每个字面值都有相应的类型，例如：0 是 int 型，3.14159 是 double 型。只有内置类型存在字面值，没有类类型的字面值。因此，也没有任何标准库类型的字面值。 </p><ol><li><strong>整型字面值规则</strong><br>定义字面值整数常量可以使用以下三种进制中的任一种：十进制、八进制和十六进制。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20     // decimal </span><br><span class="line">024    // octal </span><br><span class="line">0x14   // hexadecimal</span><br></pre></td></tr></table></figure><p>字面值整数常量的类型默认为 int 或 long 类型。其精度类型决定于字面值——其值适合 int 就是 int 类型，比 int 大的值就是 long 类型。通过增加后缀，能够强制将字面值整数常量转换为 long、unsigned 或 unsigned long 类型。通过在数值后面加 L 或者 l（字母“l”大写或小写）指定常量为 long 类型。 </p><p>类似地，可通过在数值后面加 U 或 u 定义 unsigned 类型。同时加 L 和 U 就能够得到 unsigned long 类型的字面值常量。但其后缀不能有空格： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">128u  /* unsigned */</span><br><span class="line">24UL  /* unsigned long */ </span><br><span class="line">1L    /* long */ </span><br><span class="line">8Lu   /* unsigned long */</span><br></pre></td></tr></table></figure><p>没有 short 类型的字面值常量。</p><ol start="2"><li><strong>浮点字面值规则</strong></li></ol><p>通常可以用十进制或者科学计数法来表示浮点字面值常量。使用科学计数法时，指数用 E 或者 e 表示。默认的浮点字面值常量为 double 类型。在数值的后面加上 F 或 f 表示单精度。同样加上 L 或者 l 表示扩展精度（再次提醒，不提倡使用小写字母 l）。下面每一组字面值表示相同的值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.14159F            .001f          12.345L            0. </span><br><span class="line">3.14159E0f          1E-3F          1.2345E1L          0e0</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>布尔字面值和字符字面值</strong></li></ol><p>单词 true 和 false 是布尔型的字面值。</p><p>可打印的字符型字面值通常用一对单引号来定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; &apos;2&apos; &apos;,&apos; &apos; &apos; // blank</span><br></pre></td></tr></table></figure><p>这些字面值都是 char 类型的。在字符字面值前加 L 就能够得到 wchar_t 类型的宽字符字面值。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&apos;a&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>非打印字符的转义序列</strong></li></ol><p>有些字符是不可打印的。不可打印字符实际上是不可显示的字符，比如退格或者控制符。还有一些在语言中有特殊意义的字符，例如单引号、双引号和反斜线符号。不可打印字符和特殊字符都用转义字符书写。转义字符都以反斜线符号开始，C++ 语言中定义了如下转义字符： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换行符        \n 水平制表符    \t</span><br><span class="line">纵向制表符    \v 退格符        \b</span><br><span class="line">回车符        \r 进纸符        \f</span><br><span class="line">报警(响铃)符  \a 反斜线        \\</span><br><span class="line">疑问号        \? 单引号        \&apos;</span><br><span class="line">双引号        \&quot;</span><br></pre></td></tr></table></figure><p>我们可以将任何字符表示为以下形式的通用转义字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\ooo</span><br></pre></td></tr></table></figure><p>这里 ooo 表示三个八进制数字，这三个数字表示字符的数字值。下面的例子是用 ASCII 码字符集表示字面值常量： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\7 (bell)      \12 (newline)     \40 (blank) </span><br><span class="line">\0 (null)      \062 (&apos;2&apos;)        \115 (&apos;M&apos;)</span><br></pre></td></tr></table></figure><p>同样也可以用十六进制转义字符来定义字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xddd</span><br></pre></td></tr></table></figure><p>它由一个反斜线符、一个 x 和一个或者多个十六进制数字组成。</p><ol start="5"><li><strong>字符串字面值</strong></li></ol><p>字符串字面值常量用双引号括起来的零个或者多个字符表示。不可打印字符表示成相应的转义字符。 </p><p>为了兼容 C 语言，C++ 中所有的字符串字面值都由编译器自动在末尾添加一个空字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot;    //表示包含字母 A 和空字符两个字符的字符串。</span><br></pre></td></tr></table></figure><p>也存在宽字符串字面值，一样在前面加“L”，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&quot;a wide string literal&quot;   //宽字符串字面值是一串常量宽字符，同样以一个宽空字符结束。</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>多行字面值</strong></li></ol><p>处理长字符串有一个更基本的（但不常使用）方法，这个方法依赖于很少使用的程序格式化特性：在一行的末尾加一反斜线符号可将此行和下一行当作同一行处理。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cou\ </span><br><span class="line">t &lt;&lt; &quot;Hi&quot; &lt;&lt; st\ </span><br><span class="line">d::endl;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &quot;Hi&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>可以使用这个特性来编写长字符串字面值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     std::cout &lt;&lt; &quot;a multi-line \ </span><br><span class="line">string literal \ </span><br><span class="line">using a backslash&quot; </span><br><span class="line">              &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>注意反斜线符号必须是该行的尾字符——不允许有注释或空格符。同样，后继行行首的任何空格和制表符都是字符串字面值的一部分。正因如此，长字符串字面值的后继行才不会有正常的缩进。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;p&gt;类型是所有程序的基础。类型告诉我们数据代表什么意思以及可以对数据执行哪些操作。&lt;br&gt;C++ 语言定义了几种基本类型：字符型、整型、浮点型等。C++ 还提供了可用于自定义数据类型的机制，标准库正是利用这些机制定义了许多更复杂的类型，比如可变长字符串 string、vector 等。此外，我们还能修改已有的类型以形成复合类型。&lt;/p&gt;
&lt;h2 id=&quot;2-1-基本内置类型&quot;&gt;&lt;a href=&quot;#2-1-基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 基本内置类型&quot;&gt;&lt;/a&gt;2.1 基本内置类型&lt;/h2&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>SalesItem</title>
    <link href="https://zypsola.com/2018/10/20/SalesItem/"/>
    <id>https://zypsola.com/2018/10/20/SalesItem/</id>
    <published>2018-10-20T05:03:10.000Z</published>
    <updated>2018-10-22T05:08:41.591Z</updated>
    
    <content type="html"><![CDATA[<p>Code</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H</span><br><span class="line">#define SALESITEM_H</span><br><span class="line"></span><br><span class="line">// Definition of Sales_item class and related functions goes here</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Sales_item &#123;</span><br><span class="line">friend bool operator==(const Sales_item&amp;, const Sales_item&amp;);</span><br><span class="line">// other members as before</span><br><span class="line">public:</span><br><span class="line">    // added constructors to initialize from a string or an istream</span><br><span class="line">    Sales_item(const std::string &amp;book):</span><br><span class="line">              isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br><span class="line">    Sales_item(std::istream &amp;is) &#123; is &gt;&gt; *this; &#125;</span><br><span class="line">    friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_item&amp;);</span><br><span class="line">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_item&amp;);</span><br><span class="line">public:</span><br><span class="line">    // operations on Sales_item objects</span><br><span class="line">    // member binary operator: left-hand operand bound to implicit this pointer</span><br><span class="line">    Sales_item&amp; operator+=(const Sales_item&amp;);</span><br><span class="line">    // other members as before</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    // operations on Sales_item objects</span><br><span class="line">    double avg_price() const;</span><br><span class="line">    bool same_isbn(const Sales_item &amp;rhs) const</span><br><span class="line">        &#123; return isbn == rhs.isbn; &#125;</span><br><span class="line">    // default constructor needed to initialize members of built-in type</span><br><span class="line">    Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</span><br><span class="line">// private members as before</span><br><span class="line">private:</span><br><span class="line">    std::string isbn;</span><br><span class="line">    unsigned units_sold;</span><br><span class="line">    double revenue;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// nonmember binary operator: must declare a parameter for each operand</span><br><span class="line">Sales_item operator+(const Sales_item&amp;, const Sales_item&amp;);</span><br><span class="line"></span><br><span class="line">inline bool </span><br><span class="line">operator==(const Sales_item &amp;lhs, const Sales_item &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    // must be made a friend of Sales_item</span><br><span class="line">    return lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">           lhs.revenue == rhs.revenue &amp;&amp;</span><br><span class="line">       lhs.same_isbn(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool </span><br><span class="line">operator!=(const Sales_item &amp;lhs, const Sales_item &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    return !(lhs == rhs); // != defined in terms of operator==</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using std::istream; using std::ostream;</span><br><span class="line"></span><br><span class="line">// assumes that both objects refer to the same isbn</span><br><span class="line">inline</span><br><span class="line">Sales_item&amp; Sales_item::operator+=(const Sales_item&amp; rhs) </span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold; </span><br><span class="line">    revenue += rhs.revenue; </span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// assumes that both objects refer to the same isbn</span><br><span class="line">inline</span><br><span class="line">Sales_item </span><br><span class="line">operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs) </span><br><span class="line">&#123;</span><br><span class="line">    Sales_item ret(lhs);  // copy lhs into a local object that we&apos;ll return</span><br><span class="line">    ret += rhs;           // add in the contents of rhs </span><br><span class="line">    return ret;           // return ret by value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">istream&amp; </span><br><span class="line">operator&gt;&gt;(istream&amp; in, Sales_item&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    double price;</span><br><span class="line">    in &gt;&gt; s.isbn &gt;&gt; s.units_sold &gt;&gt; price;</span><br><span class="line">    // check that the inputs succeeded</span><br><span class="line">    if (in)</span><br><span class="line">        s.revenue = s.units_sold * price;</span><br><span class="line">    else </span><br><span class="line">        s = Sales_item();  // input failed: reset object to default state</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">ostream&amp; </span><br><span class="line">operator&lt;&lt;(ostream&amp; out, const Sales_item&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; s.isbn &lt;&lt; &quot;\t&quot; &lt;&lt; s.units_sold &lt;&lt; &quot;\t&quot; </span><br><span class="line">        &lt;&lt; s.revenue &lt;&lt; &quot;\t&quot; &lt;&lt;  s.avg_price();</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">double Sales_item::avg_price() const</span><br><span class="line">&#123;</span><br><span class="line">    if (units_sold) </span><br><span class="line">        return revenue/units_sold; </span><br><span class="line">    else </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Code&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson1</title>
    <link href="https://zypsola.com/2018/10/18/C++Primer1/"/>
    <id>https://zypsola.com/2018/10/18/C++Primer1/</id>
    <published>2018-10-18T13:03:10.000Z</published>
    <updated>2018-10-22T07:37:14.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-快速入门"><a href="#第一章-快速入门" class="headerlink" title="第一章 快速入门"></a>第一章 快速入门</h1><a id="more"></a><ol><li><p>标准库定义了 4 个 IO 对象。<br>处理输入时使用命名为 cin（读作 see-in）的 istream 类型对象。这个对象也称为<strong>标准输入</strong>。处理输出时使用命名为 cout（读作 see-out）的 ostream 类型对象，这个对象也称为<strong>标准输出</strong>。标准库还定义了另外两个 ostream 对象，分别命名为 cerr 和 clog（分别读作“see-err”和“see-log”）。cerr 对象又叫作<strong>标准错误</strong>，通常用来输出警告和错误信息给程序的使用者。而 clog 对象用于产生程序执行的一般信息。 一般情况下，系统将这些对象与执行程序的窗口联系起来。这样，当我们从 cin 读入时，数据从执行程序的窗口读入，当写到 cin、cerr 或 clog 时，输出写至同一窗口。运行程序时，大部分操作系统都提供了重定向输入或输出流的方法。利用重定向可以将这些流与所选择的文件联系起来。 </p></li><li><p><strong>输出操作符</strong>（&lt;&lt; 操作符）<br>每个输出操作符实例都接受两个操作数：左操作数必须是 ostream 对象；右操作数是要输出的值。操作符将其右操作数写到作为其左操作数的 ostream 对象。C++ 中，每个表达式都会产生一个结果，通常是将操作符作用到其操作数所产生的值。当操作符是输出操作符时，结果是左操作数的值。也就是说，输出操作返回的值是输出流本身。 </p></li><li><p>endl 是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区。通过刷新缓冲区，用户可立即看到写入到流中的输出。 </p></li><li><p><strong>输入操作符</strong>（&gt;&gt; 操作符）<br>行为与输出操作符相似。它接受一个 istream 对象作为其左操作数，接受一个对象作为其右操作数，它从 istream 操作数读取数据并保存到右操作数中。像输出操作符一样，输入操作符返回其左操作数作为结果。</p></li><li><p><strong>关于注释</strong><br>C++ 中有单行注释和成对注释两种类型的注释。单行注释以双斜线（//）开头，行中处于双斜线右边的内容是注释，被编译器忽略。 另一种定界符，注释对（/* */），是从 C 语言继承过来的。这种注释以“/*”开头，以“*/”结尾。编译器把落入注释对“/**/”之间的内容作为注释。</p></li><li><p><strong>注释对不可嵌套</strong><br>当注释掉程序的一大部分时，似乎最简单的办法就是在要临时忽略的区域前后放一个注释对。问题是如果那段代码已经有了注释对，那么新插入的注释对将提前终止。临时忽略一段代码更好的方法，是用编辑器在要忽略的每一行代码前面插入单行注释。这样，你就无需担心要注释的代码是否已包含注释对。 </p></li><li><p><strong>术语</strong><br><strong>argument（实参）:</strong>传递给被调用函数的值。<br><strong>block（块）:</strong>花括号括起来的语句序列。<br><strong>buffer（缓冲区）:</strong>一段用来存放数据的存储区域。IO 设备常存储输入（或输出）到缓冲区，并独立于程序动作对缓冲区进行读写。输出缓冲区通常必须显式刷新以强制输出缓冲区内容。默认情况下，读 cin 会刷新 cout；当程序正常结束时，cout 也被刷新。<br><strong>built-in type（内置类型）:</strong>C++ 语言本身定义的类型，如 int。<br><strong>cerr:</strong>绑定到标准错误的 ostream 对象，这通常是与标准输出相同的流。默认情况下，输出 cerr 不缓冲，通常用于不是程序正常逻辑部分的错误信息或其他输出。<br><strong>clog:</strong>绑定到标准错误的 ostream 对象。默认情况下，写到 clog 时是带缓冲的。通常用于将程序执行信息写入到日志文件中。<br><strong>namespace（命名空间）:</strong>将库所定义的名字放至单独一个地方的机制。命名空间有助于避免无意的命名冲突。C++ 标准库所定义的名字在命名空间 std 中。<br><strong>preprocessor directive（预处理指示）:</strong>C++ 预处理器的指示。#include 是一个预处理器指示。预处理器指示必须出现在单独的行中。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章-快速入门&quot;&gt;&lt;a href=&quot;#第一章-快速入门&quot; class=&quot;headerlink&quot; title=&quot;第一章 快速入门&quot;&gt;&lt;/a&gt;第一章 快速入门&lt;/h1&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>Unity Lesson1</title>
    <link href="https://zypsola.com/2018/08/18/Unity1/"/>
    <id>https://zypsola.com/2018/08/18/Unity1/</id>
    <published>2018-08-18T07:43:51.000Z</published>
    <updated>2018-08-18T08:13:19.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Awake-、-OnEnable-与-Start"><a href="#Awake-、-OnEnable-与-Start" class="headerlink" title="Awake() 、 OnEnable() 与 Start()"></a>Awake() 、 OnEnable() 与 Start()</h1><a id="more"></a><p><img src="http://pdncef9qu.bkt.clouddn.com/unity-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Awake-、-OnEnable-与-Start&quot;&gt;&lt;a href=&quot;#Awake-、-OnEnable-与-Start&quot; class=&quot;headerlink&quot; title=&quot;Awake() 、 OnEnable() 与 Start()&quot;&gt;&lt;/a&gt;Awake() 、 OnEnable() 与 Start()&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Unity" scheme="https://zypsola.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C# Lesson3</title>
    <link href="https://zypsola.com/2018/07/12/C-Lesson3/"/>
    <id>https://zypsola.com/2018/07/12/C-Lesson3/</id>
    <published>2018-07-12T09:53:10.000Z</published>
    <updated>2018-10-19T16:50:51.365Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="C#" scheme="https://zypsola.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C# Lesson2</title>
    <link href="https://zypsola.com/2018/07/11/C-Lesson2/"/>
    <id>https://zypsola.com/2018/07/11/C-Lesson2/</id>
    <published>2018-07-11T12:11:22.000Z</published>
    <updated>2018-10-19T16:51:46.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-C-编程概述"><a href="#第二章-C-编程概述" class="headerlink" title="第二章 C#编程概述"></a>第二章 C#编程概述</h1><h2 id="1-一个简单的C-程序"><a href="#1-一个简单的C-程序" class="headerlink" title="1.一个简单的C#程序"></a>1.一个简单的C#程序</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;        //告诉编译器这个程序使用System命名空间的类型</span><br><span class="line"></span><br><span class="line">namespace Simple     //声明一个新命名空间，名称为Simple</span><br><span class="line">&#123;</span><br><span class="line">class Program    //声明一个新的类，名称为Program</span><br><span class="line">&#123;</span><br><span class="line">static void Main()     //声明了一个名称为Main的方法；Main是一个特殊函数，编译器用它作为程序的起始点</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;Hi there!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>C#程序由一个或多个类型声明组成，程序中的类型可以以任意顺序声明，在以上代码中，只声明了class类型。</li><li><strong>命名空间</strong>是与某个名称相关联的一组类型声明。</li></ol><h2 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h2><ol><li><strong>标识符</strong>是一种字符串，用来命名如变量、方法、参数等程序结构。</li><li>可以通过把有意义的词连接成一个单独的描述性名称来创建自文档化(self-documenting)的标识符。</li></ol><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic2-1.png" alt=""></p><h2 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h2><ol><li><strong>关键字</strong>是用来定义C#语言的字符串记号</li><li><strong>上下文关键字</strong>是仅在特定的语言结构中充当关键字的标识符</li></ol><h2 id="4-Main：程序的起始点"><a href="#4-Main：程序的起始点" class="headerlink" title="4.Main：程序的起始点"></a>4.Main：程序的起始点</h2><ol><li>每个C#程序必须有一个类带有Main方法(函数)</li></ol><h2 id="5-空白"><a href="#5-空白" class="headerlink" title="5.空白"></a>5.空白</h2><ol><li>空白字符包括：空格(Sapce)、制表符(Tab)、换行符、回车符</li></ol><h2 id="6-语句"><a href="#6-语句" class="headerlink" title="6.语句"></a>6.语句</h2><ol><li>语句是描述一个类型或告诉程序去执行某个动作的一条源代码指令；简单语句以一个分号结束</li><li><strong>块</strong>一个由成对大括号包围的0条或多条语句序列，它在语法上相当于一条语句。</li></ol><h2 id="7-从程序中输出文本"><a href="#7-从程序中输出文本" class="headerlink" title="7.从程序中输出文本"></a>7.从程序中输出文本</h2><h3 id="7-1-Write"><a href="#7-1-Write" class="headerlink" title="7.1 Write"></a>7.1 Write</h3><p>Write是Console类的成员，它把一个文本字符串发送到程序的控制台窗口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(&quot;This is trivial text&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="7-2-WriteLine"><a href="#7-2-WriteLine" class="headerlink" title="7.2 WriteLine"></a>7.2 WriteLine</h3><p>WriteLine是Console的另一个成员，与Write功能相同，但会在结尾添加一个换行符</p><h3 id="7-3-格式字符串"><a href="#7-3-格式字符串" class="headerlink" title="7.3 格式字符串"></a>7.3 格式字符串</h3><ol><li>Write语句和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔</li><li>第一个参数必须总为字符串，称为<strong>格式字符串</strong>，格式字符串可以包含替代标记</li><li><p>跟着格式字符串的参数称为<strong>替换值</strong>，替换值从0开始编号</p><p> Console.WriteLine(“Two sample intergers are {0} and {1}.”, 3, 6};</p></li></ol><h3 id="7-4-多重标记和值"><a href="#7-4-多重标记和值" class="headerlink" title="7.4 多重标记和值"></a>7.4 多重标记和值</h3><pre><code>Console.WriteLine(&quot;Three intergers are {1}, {0} and {1}.&quot;, 3, 6);</code></pre><h3 id="7-5-格式化数字字符串"><a href="#7-5-格式化数字字符串" class="headerlink" title="7.5 格式化数字字符串"></a>7.5 格式化数字字符串</h3><pre><code>Console.WriteLine(&quot;The value: {0}.&quot;, 500);    //输出数字Console.WriteLine(&quot;The value: {0:C}.&quot;, 500);  //格式为货币int myInt = 500；Console.WriteLine(&quot;|{0, 10}|&quot;, myInt);        //右对齐Console.WriteLine(&quot;|{0,-10}|&quot;, myInt);        //左对齐double myDouble = 12.345678;Console.WriteLine(&quot;{0,-10:G} -- General                           &quot;, myDouble);Console.WriteLine(&quot;{0,-10} -- Default, same as General            &quot;, myDouble);Console.WriteLine(&quot;{0,-10:F4} -- Fixed Point, 4 dec places        &quot;, myDouble);Console.WriteLine(&quot;{0,-10:C} -- Currency                          &quot;, myDouble);Console.WriteLine(&quot;{0,-10:E3} -- Sci. Notation, 3 dec places      &quot;, myDouble);Console.WriteLine(&quot;{0,-10:x} -- Hexadecimal integer               &quot;, 25);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-C-编程概述&quot;&gt;&lt;a href=&quot;#第二章-C-编程概述&quot; class=&quot;headerlink&quot; title=&quot;第二章 C#编程概述&quot;&gt;&lt;/a&gt;第二章 C#编程概述&lt;/h1&gt;&lt;h2 id=&quot;1-一个简单的C-程序&quot;&gt;&lt;a href=&quot;#1-一个简单的C-程序&quot; class=&quot;headerlink&quot; title=&quot;1.一个简单的C#程序&quot;&gt;&lt;/a&gt;1.一个简单的C#程序&lt;/h2&gt;
    
    </summary>
    
    
      <category term="C#" scheme="https://zypsola.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Blender(一)</title>
    <link href="https://zypsola.com/2018/05/25/Blender1/"/>
    <id>https://zypsola.com/2018/05/25/Blender1/</id>
    <published>2018-05-25T11:39:19.000Z</published>
    <updated>2018-07-11T13:21:01.428Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开启建模大业！Blender的学习！</strong></p><h2 id="必须熟悉的Blender基础操作"><a href="#必须熟悉的Blender基础操作" class="headerlink" title="必须熟悉的Blender基础操作"></a>必须熟悉的Blender基础操作</h2><a id="more"></a><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ol><li>右键：选择</li><li>A键：全选或取消选择</li><li>B键+左键：矩形选择</li><li>C键+左键：笔刷选择</li><li>C键+中键：笔刷取选</li><li>滚轮调节笔刷大小</li><li>Ctrl+左键：套索选择</li><li>Ctrl+shift+左键：套索取选</li><li>alt+右键：选择边循环</li><li>Ctrl+alt+右键：环边选择</li><li>Ctrl+tab：切换点/线/面选择模式</li><li>Ctrl+小键盘+/-：放大收缩选择范围</li><li>L键：选择鼠标所在元素的有关联元素</li></ol><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ol start="14"><li>中键：旋转视图</li><li>shift+中键：移动视图</li><li>ctrl+中键 / 滚轮：缩放视图</li><li>小键盘0：进入/退出摄像机视图</li><li>小键盘5：切换透视/正交视图</li><li>小键盘1/3/7：切换前/右/顶视图</li><li>ctrl+小键盘1/3/7：反向对应视图</li><li>Home：全窗口显示所有物体</li><li>小键盘.：全窗口显示所选物体</li><li>左键：移动3D游标</li><li>shift+C键：重置视图</li><li>小键盘/：所选物体满框并隔离未选择物体</li><li>Z键：线框/实体切换</li><li>alt+Z键：贴图/实体切换</li><li>Shift+Z键：渲染预览/实体切换</li></ol><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><ol start="29"><li>ctrl+R键：增加循环线;滚轮确定更多细分;右键确定循环线在切分中心</li><li>K键：使用切割工具,Enter完成切割</li><li>I键：插入工具</li><li>E键：挤出工具</li><li>ctrl+B键：倒角工具;滚轮确定更多细分</li><li>G键+G键：在边上滑动</li><li>V键：撕开选择边</li></ol><h3 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h3><ol start="36"><li>shift+A键：添加物体</li><li>G键：移动物体</li><li>S键：缩放</li><li>R键：旋转</li><li>XYZ键：固定在某个方向上操作</li><li>空格键：搜索菜单</li><li>Ctrl+shift+alt+C键：设置物体源心</li><li>shift+S键：吸附</li><li>shift+D键：复制</li><li>alt+D键：关联复制</li><li>P键：将选择的元素独立成新物体</li><li>Ctrl+J键：加入到目标物体</li></ol><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ol start="48"><li>alt+A键：播放/暂停</li><li>shift+alt+A键：倒放的播放/暂停</li><li>左右箭头：前后帧</li><li>shift+上下箭头：前后10帧</li><li>shift+左右箭头：到开始/结束位置</li></ol><h3 id="Add-2018-05-26"><a href="#Add-2018-05-26" class="headerlink" title="Add 2018-05-26"></a>Add 2018-05-26</h3><ol start="53"><li>ctrl+alt+Q键：多视图切换</li><li>shift+R：重复上次操作</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;开启建模大业！Blender的学习！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;必须熟悉的Blender基础操作&quot;&gt;&lt;a href=&quot;#必须熟悉的Blender基础操作&quot; class=&quot;headerlink&quot; title=&quot;必须熟悉的Blender基础操作&quot;&gt;&lt;/a&gt;必须熟悉的Blender基础操作&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://zypsola.com/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Z720(一)</title>
    <link href="https://zypsola.com/2018/05/05/MyNovel1/"/>
    <id>https://zypsola.com/2018/05/05/MyNovel1/</id>
    <published>2018-05-04T17:43:32.000Z</published>
    <updated>2018-10-19T14:47:21.624Z</updated>
    
    <content type="html"><![CDATA[<p>Z720是一台垃圾回收机器人，但请不要误会，它的工作并不是在脏乱的城市街道之中到处回收生活垃圾，而是回收哪些</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Z720是一台垃圾回收机器人，但请不要误会，它的工作并不是在脏乱的城市街道之中到处回收生活垃圾，而是回收哪些&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Z720" scheme="https://zypsola.com/tags/Z720/"/>
    
  </entry>
  
  <entry>
    <title>C# Lesson1</title>
    <link href="https://zypsola.com/2018/05/03/C-Lesson1/"/>
    <id>https://zypsola.com/2018/05/03/C-Lesson1/</id>
    <published>2018-05-03T14:57:06.000Z</published>
    <updated>2018-10-19T16:51:38.739Z</updated>
    
    <content type="html"><![CDATA[<p>从用<strong>WPF</strong>做界面开始，到现在用<strong>Unity</strong>做游戏，使用<strong>C#</strong>已经有好一段时间了，但一直没有系统地学习C#。<br>是时候学习一下了，这里我使用的是<strong>《C#图解教程》</strong>。</p><h1 id="第一章-C-和-NET框架"><a href="#第一章-C-和-NET框架" class="headerlink" title="第一章 C#和.NET框架"></a>第一章 C#和.NET框架</h1><p><strong>C#</strong>是为在微软的<strong>.NET Framework</strong>上开发程序设计的。</p><a id="more"></a><h2 id="1-NET框架由三部分组成"><a href="#1-NET框架由三部分组成" class="headerlink" title="1 .NET框架由三部分组成"></a>1 .NET框架由三部分组成</h2><ol><li><p>执行环境称为<strong>CLR</strong>(Common Language Runtime, 公共语言运行库)<br>CLR在运行时管理程序的执行，包括：<br>内存管理和垃圾收集<br>代码安全验证<br>代码执行、线程管理及异常处理</p><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-1.png" alt=""></p></li><li><p><strong>编程工具</strong>涵盖了编码和调试需要的一切，包括：<br>Visual Studio集成开发环境(IDE)<br>.NET兼容的编译器<br>调试器<br>网站开发服务器端技术，如ASP.NET或WCF</p></li><li><p><strong>BCL</strong>(Base Class Library,基类库)是.NET框架使用的一个大的类库，而且可以在自己的程序中使用</p></li></ol><h2 id="2-NET的特点及其带来的好处"><a href="#2-NET的特点及其带来的好处" class="headerlink" title="2 .NET的特点及其带来的好处"></a>2 .NET的特点及其带来的好处</h2><ol><li><p>面向对象的开发环境</p></li><li><p>自动垃圾收集<br>CLR有一项服务<strong>GC</strong>(Garbage Collector, 垃圾收集器)能自动管理内存<br>GC自动从内存中删除程序不再访问的对象</p></li><li><p>互操作性</p></li><li><p>不需要COM</p></li><li><p>简化部署</p></li><li><p>类型安全性</p></li><li><p>基础库</p></li></ol><h2 id="3-编译成CIL"><a href="#3-编译成CIL" class="headerlink" title="3 编译成CIL"></a>3 编译成CIL</h2><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-2.png" alt=""></p><p>.NET语言的编译器接受源代码文件，并生成名为<strong>程序集</strong>的输出文件<br>程序集要么是可执行的，要么是DLL<br>程序集里的代码不是本机代码而是<strong>CIL</strong>(Common International Language，公共中间语言)</p><h2 id="4-编译成本机代码并执行"><a href="#4-编译成本机代码并执行" class="headerlink" title="4 编译成本机代码并执行"></a>4 编译成本机代码并执行</h2><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-3.png" alt=""></p><p>程序的CIL直到它被调用运行时才会被编译成本机代码。运行时，CLR执行以下步骤：</p><ol><li><p>检查程序集的安全特性</p></li><li><p>在内存中分配空间</p></li><li><p>把程序集中的可执行代码发送给<strong>JIT</strong>(实时编译器)，把其中一部分编译成本机代码</p></li></ol><p>不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次<br>一旦CIL被编译成本机代码，CLR就在它运行时管理它<br><strong>托管代码</strong> 为.NET框架编写的代码，需要CLR<br><strong>非托管代码</strong> 不在CLR控制之下运行的代码</p><h2 id="5-编译和执行"><a href="#5-编译和执行" class="headerlink" title="5 编译和执行"></a>5 编译和执行</h2><p>无论原始源文件的语言是什么，都遵循相同的编译和执行过程</p><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-4.png" alt=""></p><h2 id="6-CLR与CLI"><a href="#6-CLR与CLI" class="headerlink" title="6 CLR与CLI"></a>6 CLR与CLI</h2><p>.NET框架的核心组件是CLR，它在操作系统的顶层，负责管理程序的执行</p><p>CLI(Common Language Infrastructure，公共语言基础结构)，它把所有.NET框架的组件连结成一个内聚的、一致的系统。它展示了系统的概念和架构，并详细说明了所有软件都必须坚持的规则和约定。</p><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-5.png" alt=""></p><p>CLI的重要组成部分</p><ol><li>公共类型系统<strong>CTS</strong>(Common Type System)</li><li>公共语言规范<strong>CLS</strong>(Common Language Specification)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从用&lt;strong&gt;WPF&lt;/strong&gt;做界面开始，到现在用&lt;strong&gt;Unity&lt;/strong&gt;做游戏，使用&lt;strong&gt;C#&lt;/strong&gt;已经有好一段时间了，但一直没有系统地学习C#。&lt;br&gt;是时候学习一下了，这里我使用的是&lt;strong&gt;《C#图解教程》&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;第一章-C-和-NET框架&quot;&gt;&lt;a href=&quot;#第一章-C-和-NET框架&quot; class=&quot;headerlink&quot; title=&quot;第一章 C#和.NET框架&quot;&gt;&lt;/a&gt;第一章 C#和.NET框架&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;C#&lt;/strong&gt;是为在微软的&lt;strong&gt;.NET Framework&lt;/strong&gt;上开发程序设计的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C#" scheme="https://zypsola.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="https://zypsola.com/2018/05/03/Markdown/"/>
    <id>https://zypsola.com/2018/05/03/Markdown/</id>
    <published>2018-05-03T10:07:17.000Z</published>
    <updated>2018-07-11T13:49:15.138Z</updated>
    
    <content type="html"><![CDATA[<p>既然要写博客，首先就要学习一下Markdown语法<a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="noopener">Markdown语法说明(简体中文版)</a></p><a id="more"></a><h2 id="1-标题语法"><a href="#1-标题语法" class="headerlink" title="1.标题语法"></a>1.标题语法</h2><p>Markdown支持两种标题语法：类Setext和类atx形式</p><h3 id="a-类Setext："><a href="#a-类Setext：" class="headerlink" title="a.类Setext："></a>a.类Setext：</h3><p>任意数量的’=’或’-‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H1 //最高阶标题</span><br><span class="line">===</span><br><span class="line">H2 //第二阶标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="b-类Atx："><a href="#b-类Atx：" class="headerlink" title="b.类Atx："></a>b.类Atx：</h3><p>行首插入1到6个’#’，对应1到6阶，注意’#’ 与标题间要有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line"></span><br><span class="line">## H2</span><br><span class="line"></span><br><span class="line">### H3</span><br></pre></td></tr></table></figure></p><p>也可以选择性地闭合类Atx标题：在行尾加上’#’，且数量无需和行首相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1 ###</span><br><span class="line"></span><br><span class="line">## H2 ##</span><br><span class="line"></span><br><span class="line">### H3 #</span><br></pre></td></tr></table></figure></p><h2 id="2-区块引用Blockquote"><a href="#2-区块引用Blockquote" class="headerlink" title="2.区块引用Blockquote"></a>2.区块引用Blockquote</h2><blockquote><p>我该说些什么好呢，ZYP，加油吧！<br>                                                                   ——ZYP</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 我该说些什么好呢，ZYP，加油吧！</span><br><span class="line">&gt;                               ——ZYP</span><br></pre></td></tr></table></figure><p>也可以嵌套</p><blockquote><p>Level1</p><blockquote><p>Level2</p><blockquote><p>Level3</p></blockquote><p>Level2</p></blockquote><p>Level1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Level1</span><br><span class="line">&gt; &gt; Level2</span><br><span class="line">&gt; &gt; &gt; Level3</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; Level2</span><br><span class="line">&gt;</span><br><span class="line">&gt; Level1</span><br></pre></td></tr></table></figure><p>引用的区块内也可以使用其他的Markdown语法</p><blockquote><h2 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h2><ol><li>First</li><li>Second</li></ol></blockquote><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><p>Markdown支持有序列表和无序列表  </p><p>无序列表使用星号、加号或减号作为列表标记</p><ul><li>1</li><li>2</li><li>3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 1</span><br><span class="line">* 2</span><br><span class="line">* 3</span><br></pre></td></tr></table></figure><ul><li>1</li><li>2</li><li>3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 1</span><br><span class="line">+ 2</span><br><span class="line">+ 3</span><br></pre></td></tr></table></figure><ul><li>1</li><li>2</li><li>3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line">- 3</span><br></pre></td></tr></table></figure><p>有序列表</p><ol><li>a</li><li>b</li><li>c</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. a</span><br><span class="line">2. b</span><br><span class="line">3. c</span><br></pre></td></tr></table></figure><h2 id="4-代码区块"><a href="#4-代码区块" class="headerlink" title="4.代码区块"></a>4.代码区块</h2><pre><code>for (int i = 0; i &lt; 4; i++){    double MobiTem = 0.0;    x = PosX[0][i];    y = PosY[0][i];    vst[x][y]++;    queenmove[x][y][0] = 1;    for (int j = 0; j &lt; 8; j++)    {        x = PosX[0][i];        y = PosY[0][i];        for (int s = 1;; s++)        {            x += Dx[j];            y += Dy[j];            if (Map[x][y] != BLANK)break;            vst[x][y]++;            queenmove[x][y][0] = 1;            double mobi = 0.0;            for (int k = 0; k &lt; 8; k++)            {                if (Map[x + Dx[k]][y + Dy[k]] == BLANK)                {                    mobi += 1.0;                }            }            MobiTem = MobiTem + mobi / s;        }    }    MobilityW += MobiTem;    if (MobiTem &lt; MobiMin)    {        MobiMin = MobiTem;    }}</code></pre><h2 id="5-分隔线"><a href="#5-分隔线" class="headerlink" title="5.分隔线"></a>5.分隔线</h2><hr><p>在一行中用三个以上星号、减号或底线来建立一个分隔线</p><hr><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------</span><br><span class="line">* * * * *</span><br><span class="line">_________</span><br></pre></td></tr></table></figure><h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h2><h3 id="a-行内式"><a href="#a-行内式" class="headerlink" title="a.行内式"></a>a.行内式</h3><p>This is <a href="http://www.baidu.com" title="百度一下" target="_blank" rel="noopener">baidu</a>.</p><p>This is <a href="/2018/05/02/Hello-ZYP/">my first blog</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [baidu](http://www.baidu.com &quot;百度一下&quot;).</span><br><span class="line"></span><br><span class="line">This is [my first blog](/2018/05/02/Hello-ZYP/).</span><br></pre></td></tr></table></figure><h3 id="b-参考式"><a href="#b-参考式" class="headerlink" title="b.参考式"></a>b.参考式</h3><p>链接标签不区分大小写</p><p>This is <a href="http://www.baidu.com" target="_blank" rel="noopener">baidu</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [baidu][baidu_id].</span><br><span class="line"></span><br><span class="line">[baidu_id]: http://www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="7-强调"><a href="#7-强调" class="headerlink" title="7.强调"></a>7.强调</h2><p>0123<br>0<em>123</em>4<br>0<strong>123</strong>45<br>0_123_456<br><strong>123</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0123</span><br><span class="line">0*123*4</span><br><span class="line">0**123**45</span><br><span class="line">0_123_456</span><br><span class="line">__123__</span><br></pre></td></tr></table></figure><h2 id="8-代码"><a href="#8-代码" class="headerlink" title="8.代码"></a>8.代码</h2><p>use <code>printf()</code> function<br><code>`</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use `printf()` function</span><br><span class="line">`` ` ``</span><br></pre></td></tr></table></figure><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9.图片"></a>9.图片</h2><p><img src="http://p87366ttr.bkt.clouddn.com/%E9%AD%94%E6%B3%95%E4%BD%BF%E4%B9%8B%E5%A4%9C01.jpg" alt="——魔法使之夜"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text]()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然要写博客，首先就要学习一下Markdown语法&lt;a href=&quot;http://wowubuntu.com/markdown/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown语法说明(简体中文版)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://zypsola.com/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Hello ZYP!</title>
    <link href="https://zypsola.com/2018/05/02/Hello-ZYP/"/>
    <id>https://zypsola.com/2018/05/02/Hello-ZYP/</id>
    <published>2018-05-02T08:31:38.000Z</published>
    <updated>2018-10-19T14:47:50.110Z</updated>
    
    <content type="html"><![CDATA[<p>经过了两天的努力总算搭好了这个博客，这将是一个新的起点，不再<strong>随波逐流</strong>，而是明确前进的方向，为了自己的梦想努力！<br>无论有没有他人观看，<strong>自己都始终是自己人生的观众</strong>，那么就不能让自己失望！这个博客并不是为了展示，而是记录，是为了让自己看的更加清楚，未来是靠自己创造的！</p><a id="more"></a><p>这个博客是使用 Hexo + Github Page 搭建</p><p>Hexo命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d   //生成并部署</span><br><span class="line">$ hexo new [layout] &lt;title&gt;   //新建文章</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过了两天的努力总算搭好了这个博客，这将是一个新的起点，不再&lt;strong&gt;随波逐流&lt;/strong&gt;，而是明确前进的方向，为了自己的梦想努力！&lt;br&gt;无论有没有他人观看，&lt;strong&gt;自己都始终是自己人生的观众&lt;/strong&gt;，那么就不能让自己失望！这个博客并不是为了展示，而是记录，是为了让自己看的更加清楚，未来是靠自己创造的！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://zypsola.com/tags/Others/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空之境界</title>
  
  <subtitle>ZYP&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zypsola.com/"/>
  <updated>2018-10-29T12:54:01.410Z</updated>
  <id>https://zypsola.com/</id>
  
  <author>
    <name>ZYP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ Lesson11</title>
    <link href="https://zypsola.com/2018/10/29/C++Primer11/"/>
    <id>https://zypsola.com/2018/10/29/C++Primer11/</id>
    <published>2018-10-29T12:51:31.000Z</published>
    <updated>2018-10-29T12:54:01.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-语句"><a href="#第六章-语句" class="headerlink" title="第六章 语句"></a>第六章 语句</h1><p>语句类似于自然语言中的句子。C++ 语言既有只完成单一任务的简单语句，也有作为一个单元执行的由一组语句组成的复合语句。和大多数语言一样，C++ 也提供了实现条件分支结构的语句以及重复地执行同一段代码的循环结构。本章将详细讨论 C++ 所支持的语句。</p><a id="more"></a><p>通常情况下，语句是顺序执行的。但是，除了最简单的程序外，只有顺序执行往往并不足够。为此，C++ 定义了一组控制流语句，允许有条件地执行或者重复地执行某部分功能。if 和 switch 语句提供了条件分支结构，而 for、while 和 do while 语句则支持重复执行的功能。后几种语句常称为循环或者迭代语句。 </p><h2 id="6-1-简单语句"><a href="#6-1-简单语句" class="headerlink" title="6.1 简单语句"></a>6.1 简单语句</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第六章-语句&quot;&gt;&lt;a href=&quot;#第六章-语句&quot; class=&quot;headerlink&quot; title=&quot;第六章 语句&quot;&gt;&lt;/a&gt;第六章 语句&lt;/h1&gt;&lt;p&gt;语句类似于自然语言中的句子。C++ 语言既有只完成单一任务的简单语句，也有作为一个单元执行的由一组语句组成的复合语句。和大多数语言一样，C++ 也提供了实现条件分支结构的语句以及重复地执行同一段代码的循环结构。本章将详细讨论 C++ 所支持的语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson10</title>
    <link href="https://zypsola.com/2018/10/24/C++Primer10/"/>
    <id>https://zypsola.com/2018/10/24/C++Primer10/</id>
    <published>2018-10-24T07:07:09.000Z</published>
    <updated>2018-10-29T12:44:14.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-表达式"><a href="#第五章-表达式" class="headerlink" title="第五章 表达式"></a>第五章 表达式</h1><p>表达式由一个或多个<strong>操作数</strong>通过<strong>操作符</strong>组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。</p><a id="more"></a><p>除了特殊用法外，表达式的结果是右值，可以读取该结果值，但是不允许对它进行赋值。 </p><p>C++提供了一元操作符和二元操作符两种操作符。作用在一个操作数上的操作符称为一元操作符,如取地址操作符（&amp;）和解引用操作符（*）；而二元操作符则作用于两个操作数上。除此之外，C++ 还提供了一个使用三个操作数的三元操作符。</p><p>对于操作数为内置或复合类型的二元操作符，通常要求它的两个操作数具有相同的数据类型，或者其类型可以转换为同一种数据类型。</p><p>要理解由多个操作符组成的表达式，必须先理解操作符的<strong>优先级</strong>、<strong>结合性</strong>和操作数的<strong>求值顺序</strong>。</p><h2 id="5-1-算术操作符"><a href="#5-1-算术操作符" class="headerlink" title="5.1 算术操作符"></a>5.1 算术操作符</h2><p>按优先级来对操作符进行分组——一元操作符优先级最高，其次是乘、除操作，接着是二元的加、减法操作。高优先级的操作符要比低优先级的结合得更紧密。这些算术操作符都是左结合，这就意味着当操作符的优先级相同时，这些操作符从左向右依次与操作数结合。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+      一元正号    + expr </span><br><span class="line">-      一元负号    - expr </span><br><span class="line">*      乘法      expr * expr</span><br><span class="line">/      除法      expr / expr</span><br><span class="line">%      求余      expr % expr</span><br><span class="line">+      加法      expr + expr</span><br><span class="line">-      减法      expr - expr</span><br></pre></td></tr></table></figure><p>如果两个操作数为正，除法（/）和求模（%）操作的结果也是正数（或零）；如果两个操作数都是负数，除法操作的结果为正数（或零），而求模操作的结果则为负数（或零）；如果只有一个操作数为负数，这两种操作的结果取决于机器；求模结果的符号也取决于机器，而除法操作的值则是负数（或零）： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-21 % -8; //  ok: result is -5 </span><br><span class="line">21 % -5;  //  machine-dependent: result is 1 or -4 </span><br><span class="line">-21 / -8; //  ok: result is 2 </span><br><span class="line">21 / -5;  //  machine-dependent: result is -4 or -5</span><br></pre></td></tr></table></figure><h2 id="5-2-关系操作符和逻辑操作符"><a href="#5-2-关系操作符和逻辑操作符" class="headerlink" title="5.2 关系操作符和逻辑操作符"></a>5.2 关系操作符和逻辑操作符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!        逻辑非     !expr </span><br><span class="line">&lt;        小于       expr &lt; expr</span><br><span class="line">&lt;=       小于等于   expr &lt;= expr</span><br><span class="line">&gt;        大于       expr &gt; expr</span><br><span class="line">&gt;=       大于等于   expr &gt;= expr</span><br><span class="line">==       相等       expr == expr</span><br><span class="line">!=       不等       expr != expr</span><br><span class="line">&amp;&amp;       逻辑与     expr &amp;&amp; expr</span><br><span class="line">||       逻辑或     expr || expr</span><br></pre></td></tr></table></figure><p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们常常称这种求值策略为“短路求值（short-circuit evaluation）”。 </p><h2 id="5-3-位操作符"><a href="#5-3-位操作符" class="headerlink" title="5.3 位操作符"></a>5.3 位操作符</h2><p>位操作符使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能。另外，这类操作符还可用于 bitset 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~    bitwise NOT（位求反）  ~expr </span><br><span class="line">&lt;&lt;    left shift（左移）    expr1 &lt;&lt; expr2</span><br><span class="line">&gt;&gt;    right shift（右移）   expr1 &gt;&gt; expr2</span><br><span class="line">&amp;    bitwise AND（位与）    expr1 &amp; expr2</span><br><span class="line">^    bitwise XOR（位异或）  expr1 ^ expr2</span><br><span class="line">|    bitwise OR（位或）     expr1 | expr2</span><br></pre></td></tr></table></figure><p>位操作符操纵的整数的类型可以是有符号的也可以是无符号的。如果操作数为负数，则位操作符如何处理其操作数的符号位依赖于机器。</p><p>移位操作的右操作数不可以是负数，而且必须是严格小于左操作数位数的值。否则，操作的效果未定义。 </p><h2 id="5-4-赋值操作符"><a href="#5-4-赋值操作符" class="headerlink" title="5.4 赋值操作符"></a>5.4 赋值操作符</h2><p>赋值操作符的左操作数必须是非 const 的左值。</p><h3 id="5-4-1-赋值操作的右结合性"><a href="#5-4-1-赋值操作的右结合性" class="headerlink" title="5.4.1 赋值操作的右结合性"></a>5.4.1 赋值操作的右结合性</h3><p>C++语言允许将这多个赋值操作写在一个表达式中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">float b;</span><br><span class="line">a = b = 4.345;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;     //result: 4 4.345</span><br></pre></td></tr></table></figure><h3 id="5-4-2-赋值操作具有低优先级"><a href="#5-4-2-赋值操作具有低优先级" class="headerlink" title="5.4.2 赋值操作具有低优先级"></a>5.4.2 赋值操作具有低优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i; </span><br><span class="line">while ((i = get_value()) != 42) &#123; </span><br><span class="line">    // do something ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在赋值操作上加圆括号是必需的，因为赋值操作符的优先级低于不等操作符。 </p><h3 id="5-4-3-复合赋值操作符"><a href="#5-4-3-复合赋值操作符" class="headerlink" title="5.4.3 复合赋值操作符"></a>5.4.3 复合赋值操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+=   -=   *=   /=   %=   // arithmetic operators </span><br><span class="line">&lt;&lt;= &gt;&gt;=   &amp;=   ^=   |=   // bitwise operators</span><br></pre></td></tr></table></figure><h2 id="5-5-增和自减操作符"><a href="#5-5-增和自减操作符" class="headerlink" title="5.5 增和自减操作符"></a>5.5 增和自减操作符</h2><p>自增（++）和自减（–）操作符为对象加 1 或减 1 操作提供了方便简短的实现方式。它们有前置和后置两种使用形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 0, j; </span><br><span class="line">j = ++i; // j = 1, i = 1</span><br><span class="line">j = i++; // j = 1, i = 2</span><br></pre></td></tr></table></figure><p>前置操作返回加 1 后的值，所以返回对象本身，这是左值。而后置操作返回的则是右值。 </p><p><strong>在单个表达式中组合使用解引用和自增操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123; 10,20,30 &#125;,&#123; 40,50,60 &#125; &#125;;</span><br><span class="line">int(*p)[3] = a;</span><br><span class="line">cout &lt;&lt; **p &lt;&lt; endl;    //result: 10</span><br><span class="line">cout &lt;&lt; *((*p) + 1) &lt;&lt; endl;    //result: 20</span><br><span class="line">cout &lt;&lt; *((*++p) + 1) &lt;&lt; endl;  //result: 50</span><br></pre></td></tr></table></figure><h2 id="5-6-箭头操作符"><a href="#5-6-箭头操作符" class="headerlink" title="5.6 箭头操作符"></a>5.6 箭头操作符</h2><p>C++ 语言为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（-&gt;）。点操作符用于获取类类型对象的成员： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item1.same_isbn(item2);</span><br></pre></td></tr></table></figure><p>如果有一个指向 Sales_item 对象的指针（或迭代器），则在使用点操作符前，需对该指针（或迭代器）进行解引用： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_item *sp = &amp;item1; </span><br><span class="line">(*sp).same_isbn(item2);</span><br></pre></td></tr></table></figure><p>必须用圆括号把解引用括起来，因为解引用的优先级低于点操作符。</p><p>C++ 为在点操作符后使用的解引用操作定义了一个同义词：箭头操作符（-&gt;）。假设有一个指向类类型对象的指针（或迭代器），下面的表达式相互等价： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p).foo;</span><br><span class="line">p-&gt;foo;</span><br></pre></td></tr></table></figure><h2 id="5-7-条件操作符"><a href="#5-7-条件操作符" class="headerlink" title="5.7 条件操作符"></a>5.7 条件操作符</h2><p>条件操作符是 C++ 中唯一的三元操作符，它允许将简单的 if-else 判断语句嵌入表达式中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure><p>无论如何，cond 总是要被计算的。然后，条件为 true 时计算 expr1 ，否则计算 expr2 。expr1 和 expr2 中只有一个表达式被计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1, j = 2, k = 3;</span><br><span class="line">int maxij = i &gt; j ? i : j;</span><br><span class="line">int maxijk = i &gt; j ?</span><br><span class="line">i &gt; k ? i : k :</span><br><span class="line">j &gt; k ? j : k;</span><br></pre></td></tr></table></figure><h2 id="5-8-sizeof操作符"><a href="#5-8-sizeof操作符" class="headerlink" title="5.8 sizeof操作符"></a>5.8 sizeof操作符</h2><p>sizeof 操作符的作用是返回一个对象或类型名的长度，返回值的类型为 size_t，长度的单位是字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof (type name); </span><br><span class="line">sizeof (expr); </span><br><span class="line">sizeof expr;</span><br></pre></td></tr></table></figure><p>将 sizeof 应用在表达式 expr 上，将获得该表达式的结果的类型长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double a[10];</span><br><span class="line">double *p = a;</span><br><span class="line">cout &lt;&lt; sizeof(double) &lt;&lt; endl   //8</span><br><span class="line">&lt;&lt; sizeof a &lt;&lt; endl          //80</span><br><span class="line">&lt;&lt; sizeof *p &lt;&lt; endl         //8</span><br><span class="line">&lt;&lt; sizeof(4 + 1.2) &lt;&lt; endl   //8</span><br><span class="line">&lt;&lt; sizeof p &lt;&lt; endl;         //4</span><br></pre></td></tr></table></figure><h2 id="5-9-逗号操作符"><a href="#5-9-逗号操作符" class="headerlink" title="5.9 逗号操作符"></a>5.9 逗号操作符</h2><p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。如果最右边的操作数是左值，则逗号表达式的值也是左值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   int a = (222 + 333, 66);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;          //66</span><br><span class="line">int b = 55;</span><br><span class="line">(b++, a = 77)++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        //78 56</span><br></pre></td></tr></table></figure><h2 id="5-10-复合表达式的求值"><a href="#5-10-复合表达式的求值" class="headerlink" title="5.10 复合表达式的求值"></a>5.10 复合表达式的求值</h2><p>含有两个或更多操作符的表达式称为<strong>复合表达式</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (ia[index++] &lt; ia[index])</span><br></pre></td></tr></table></figure><p>此表达式的行为没有明确定义。问题在于：&lt; 操作符的左右操作数都使用了 index 变量，但是，左操作数更改了该变量的值。假设 index 初值为 0，编译器可以用下面两种方式之一求该表达式的值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (ia[0] &lt; ia[0]) // execution if rhs is evaluated first </span><br><span class="line">if (ia[0] &lt; ia[1]) // execution if lhs is evaluated first</span><br></pre></td></tr></table></figure><h2 id="5-11-new-和-delete-表达式"><a href="#5-11-new-和-delete-表达式" class="headerlink" title="5.11 new 和 delete 表达式"></a>5.11 new 和 delete 表达式</h2><p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new 表达式返回指向新创建对象的指针，我们通过该指针来访问此对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pi = new int;</span><br></pre></td></tr></table></figure><p><strong>动态创建对象的初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *pi = new int(1024); </span><br><span class="line">string *ps = new string(10, &apos;9&apos;);</span><br></pre></td></tr></table></figure><p><strong>动态创建对象的默认初始化</strong></p><p>如果不提供显式初始化，动态创建的对象与在函数内定义的变量初始化方式相同。对于类类型的对象，用该类的默认构造函数初始化；而内置类型的对象则无初始化。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = new int();     //初始化为0</span><br><span class="line">int *p2 = new int;       //未初始化</span><br></pre></td></tr></table></figure><p><strong>撤销动态创建的对象</strong></p><p>动态创建的对象用完后，程序员必须显式地将该对象占用的内存返回给自由存储区。C++ 提供了 delete 表达式释放指针所指向的地址空间。 </p><p>如果指针指向不是用 new 分配的内存地址，则在该指针上使用 delete 是不合法的。 </p><p><strong>零值指针的删除</strong></p><p>如果指针的值为 0，则在其上做 delete 操作是合法的，但这样做没有任何意义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *ip = 0; </span><br><span class="line">delete ip;</span><br></pre></td></tr></table></figure><p>C++ 保证：删除 0 值的指针是安全的。</p><p><strong>在delete之后，重设指针的值</strong></p><p>执行语句delete p; 后，p 变成没有定义。在很多机器上，尽管 p 没有定义，但仍然存放了它之前所指向对象的地址，然而 p 所指向的内存已经被释放，因此 p 不再有效。 </p><p>删除指针后，该指针变成悬垂指针。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。 </p><p>一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清楚地表明指针不再指向任何对象。 </p><p><strong>const对象的动态分配和回收</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int *pci = new const int(1024)</span><br></pre></td></tr></table></figure><p>与其他常量一样，动态创建的 const 对象必须在创建时初始化，并且一经初始化，其值就不能再修改。</p><p>对于类类型的 const 动态对象，如果该类提供了默认的构造函数，则此对象可隐式初始化： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const string *pcs = new const string;</span><br></pre></td></tr></table></figure><h2 id="5-12-类型转换"><a href="#5-12-类型转换" class="headerlink" title="5.12 类型转换"></a>5.12 类型转换</h2><p>在 C++ 中，某些类型之间存在相关的依赖关系。若两种类型相关，则可在需要某种类型的操作数位置上，使用该类型的相关类型对象或值。如果两个类型之间可以相互转换，则称这两个类型相关。 </p><h3 id="5-12-1-何时发生隐式类型转换"><a href="#5-12-1-何时发生隐式类型转换" class="headerlink" title="5.12.1 何时发生隐式类型转换"></a>5.12.1 何时发生隐式类型转换</h3><ol><li>在混合类型的表达式中，其操作数被转换为相同的类型</li><li>用作条件的表达式被转换为 bool 类型</li><li>用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量的类型</li></ol><p>另外，在函数调用中也可能发生隐式类型转换。</p><h3 id="5-12-2-算术转换"><a href="#5-12-2-算术转换" class="headerlink" title="5.12.2 算术转换"></a>5.12.2 算术转换</h3><p>算术转换规则定义了一个类型转换层次，该层次规定了操作数应按什么次序转换为表达式中最宽的类型。</p><p>若表达式中使用了unsigned数值，所定义的转换规则需保护操作数的精度。unsigned 操作数的转换依赖于机器中整型的相对大小，因此，这类转换本质上依赖于机器。 </p><h3 id="5-12-3-其他隐式转换"><a href="#5-12-3-其他隐式转换" class="headerlink" title="5.12.3 其他隐式转换"></a>5.12.3 其他隐式转换</h3><p><strong>指针转换</strong></p><p>在使用数组时，大多数情况下数组都会自动转换为指向第一个元素的指针。</p><p>指向任意数据类型的指针都可转换为 void* 类型；整型数值常量 0 可转换为任意指针类型。 </p><p><strong>转换为bool类型</strong></p><p>算术值和指针值都可以转换为 bool 类型。如果指针或算术值为 0，则其 bool 值为 false ，而其他值则为 true。</p><p><strong>算术类型与bool类型的转换</strong></p><p>可将算术对象转换为 bool 类型，bool 对象也可转换为 int 型。将算术类型转换为 bool 型时，零转换为 false ，而其他值则转换为 true 。将 bool 对象转换为算术类型时，true 变成 1，而 false 则为 0。</p><p><strong>转换与枚举类型</strong></p><p>C++ 自动将枚举类型的对象或枚举成员转换为整型，其转换结果可用于任何要求使用整数值的地方。</p><h3 id="5-12-4-显式转换"><a href="#5-12-4-显式转换" class="headerlink" title="5.12.4 显式转换"></a>5.12.4 显式转换</h3><p>显式转换也称为强制类型转换（cast），包括以下列名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast 和 reinterpret_cast。 </p><h3 id="5-12-5-何时需要强制类型转换"><a href="#5-12-5-何时需要强制类型转换" class="headerlink" title="5.12.5 何时需要强制类型转换"></a>5.12.5 何时需要强制类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">double b = 3.99;</span><br><span class="line">cout &lt;&lt; a*static_cast&lt;int&gt;(b) &lt;&lt; endl;    //9</span><br><span class="line">cout &lt;&lt; a*b &lt;&lt; endl;           //11.97</span><br></pre></td></tr></table></figure><p>显式使用强制类型转换的另一个原因是：可能存在多种转换时，需要选择一种特定的类型转换。</p><h3 id="5-12-6-命名的强制类型转换"><a href="#5-12-6-命名的强制类型转换" class="headerlink" title="5.12.6 命名的强制类型转换"></a>5.12.6 命名的强制类型转换</h3><p><strong>dynamic_cast</strong>:支持运行时识别指针或引用所指向的对象。</p><p><strong>const_cast</strong>:转换掉表达式的 const 性质。例如，假设有函数 string_copy，只有唯一的参数，为 char<em> 类型，我们对该函数只读不写。在访问该函数时，最好的选择是修改它让它接受 const char</em> 类型的参数。如果不行，可通过 const_cast 用一个 const 值调用 string_copy 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char* sc(char *p1)</span><br><span class="line">&#123;</span><br><span class="line">p1 = new char(&apos;c&apos;);</span><br><span class="line">char *p2 = p1;</span><br><span class="line">return p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const char *p = new char(&apos;a&apos;);</span><br><span class="line">char *p2 = sc(const_cast&lt;char*&gt;(p));</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *p2 &lt;&lt; endl;       //a c</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>static_cast</strong>:编译器隐式执行的任何类型转换都可以由 static_cast 显式完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a(1.23);</span><br><span class="line">void *p = &amp;a;</span><br><span class="line">cout &lt;&lt; *(static_cast&lt;double*&gt;(p)) &lt;&lt; endl;   //1.23</span><br></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong>:reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *ip = new int(65);</span><br><span class="line">char *cp = reinterpret_cast&lt;char*&gt;(ip);</span><br><span class="line">cout &lt;&lt; *cp &lt;&lt; endl;    //A</span><br></pre></td></tr></table></figure><h3 id="5-12-7-旧式强制类型转换"><a href="#5-12-7-旧式强制类型转换" class="headerlink" title="5.12.7 旧式强制类型转换"></a>5.12.7 旧式强制类型转换</h3><p>在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现。</p><p>旧式强制转换符号有下列两种形式： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type (expr); // Function-style cast notation </span><br><span class="line">(type) expr; // C-language-style cast notation</span><br></pre></td></tr></table></figure><p>旧式强制转换依赖于所涉及的数据类型，具有与 const_cast、 static_cast 和 reinterpret_cast 一样的行为。在合法使用 static_cast 或 const_cast 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。如果这两种强制转换均不合法，则旧式强制转换执行 reinterpret_cast 功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第五章-表达式&quot;&gt;&lt;a href=&quot;#第五章-表达式&quot; class=&quot;headerlink&quot; title=&quot;第五章 表达式&quot;&gt;&lt;/a&gt;第五章 表达式&lt;/h1&gt;&lt;p&gt;表达式由一个或多个&lt;strong&gt;操作数&lt;/strong&gt;通过&lt;strong&gt;操作符&lt;/strong&gt;组合而成。最简单的表达式仅包含一个字面值常量或变量。较复杂的表达式则由操作符以及一个或多个操作数构成。每个表达式都会产生一个结果。如果表达式中没有操作符，则其结果就是操作数本身（例如，字面值常量或变量）的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson9</title>
    <link href="https://zypsola.com/2018/10/23/C++Primer9/"/>
    <id>https://zypsola.com/2018/10/23/C++Primer9/</id>
    <published>2018-10-23T15:29:47.000Z</published>
    <updated>2018-10-24T06:55:58.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-数组和指针"><a href="#第四章-数组和指针" class="headerlink" title="第四章 数组和指针"></a>第四章 数组和指针</h1><h2 id="4-3-C风格字符串"><a href="#4-3-C风格字符串" class="headerlink" title="4.3 C风格字符串"></a>4.3 C风格字符串</h2><p>字符串字面值的类型就是const char 类型的数组。实际上，C 风格字符串既不能确切地归结为 C 语言的类型，也不能归结为 C++ 语言的类型，而是以空字符 null 结束的字符数组。</p><a id="more"></a><p>C++ 语言通过(const)char*类型的指针来操纵 C 风格字符串。一般来说，我们使用指针的算术操作来遍历 C 风格字符串，每次对指针进行测试并递增 1，直到到达结束符 null 为止： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const char *cp = &quot;12345&quot;;</span><br><span class="line">while (*cp) &#123;    //真值表明这是除 null 外的任意字符</span><br><span class="line">cout &lt;&lt; *cp++;</span><br><span class="line">&#125;</span><br><span class="line">//result: 12345</span><br></pre></td></tr></table></figure><p><strong>C 风格字符串的标准库函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strlen(s)       返回 s 的长度，不包括字符串结束符 null </span><br><span class="line">strcmp(s1, s2)  比较两个字符串 s1 和 s2 是否相同。若 s1 与 s2 相等，返回 0；若 s1 大于 s2，返回正数；若 s1 小于 s2，则返回负数 </span><br><span class="line">strcat(s1, s2)  将字符串 s2 连接到 s1 后，并返回 s1 </span><br><span class="line">strcpy(s1, s2)     将 s2 复制给 s1，并返回 s1 </span><br><span class="line">strncat(s1, s2, n) 将 s2 的前 n 个字符连接到 s1 后面，并返回 s1 </span><br><span class="line">strncpy(s1, s2, n) 将 s2 的前 n 个字符复制给 s1，并返回 s1</span><br></pre></td></tr></table></figure><p>C++ 语言提供普通的关系操作符实现标准库类型 string 的对象的比较。这些操作符也可用于比较指向 C 风格字符串的指针，但效果却很不相同：实际上，此时比较的是指针上存放的地址值，而并非它们所指向的字符串。</p><h3 id="4-3-1-创建动态数组"><a href="#4-3-1-创建动态数组" class="headerlink" title="4.3.1 创建动态数组"></a>4.3.1 创建动态数组</h3><p>数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须知道其长度，数组只在定义它的块语句内存在。实际的程序往往不能忍受这样的限制——它们需要在运行时动态地分配数组。虽然数组长度是固定的，但动态分配的数组不必在编译时知道其长度，可以（通常也是）在运行时才确定数组长度。与数组变量不同，动态分配的数组将一直存在，直到程序显式释放它为止。 </p><p>每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的<strong>自由存储区</strong>或<strong>堆</strong>。</p><p>C 语言程序使用一对标准库函数 <strong>malloc</strong> 和 <strong>free</strong> 在自由存储区中分配存储空间，而 C++ 语言则使用 <strong>new</strong> 和 <strong>delete</strong> 表达式实现相同的功能。 </p><p><strong>动态数组的定义</strong></p><p>数组变量通过指定类型、数组名和维数来定义。而动态分配数组时，只需指定类型和数组长度，不必为数组对象命名，new 表达式返回指向新分配数组的第一个元素的指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int size</span><br><span class="line">cin &gt;&gt; size;</span><br><span class="line">int *p = new int[size];</span><br></pre></td></tr></table></figure><p><strong>初始化动态分配的数组</strong></p><p>动态分配数组时，如果数组元素具有类类型，将使用该类的默认构造函数实现初始化；如果数组元素是内置类型，则无初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *psa = new string[10]; // array of 10 empty strings </span><br><span class="line">int *pia = new int[10];       // array of 10 uninitialized ints</span><br></pre></td></tr></table></figure><p>也可使用跟在数组长度后面的一对空圆括号，对数组元素做值初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *p = new int[10] (); // array of 10 zero</span><br></pre></td></tr></table></figure><p>圆括号要求编译器对数组做值初始化。对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。 </p><p><strong>const 对象的动态数组</strong></p><p>如果我们在自由存储区中创建的数组存储了内置类型的 const 对象，则必须为这个数组提供初始化：因为数组元素都是 const 对象，无法赋值。实现这个要求的唯一方法是对数组做值初始化： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int *pci = new const int[100]();</span><br><span class="line">const string *pcs = new const string[100];    //将使用 string 类的默认构造函数初始化数组元素</span><br></pre></td></tr></table></figure><p>已创建的常量元素不允许修改——因此这样的数组实际上用处不大。</p><p><strong>允许动态分配空数组</strong></p><p>C++ 虽然不允许定义长度为 0 的数组变量，但明确指出，调用 new 动态创建长度为 0 的数组是合法的： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char arr[0];            // error: cannot define zero-length array </span><br><span class="line">char *cp = new char[0]; // ok: but cp can&apos;t be dereferenced</span><br></pre></td></tr></table></figure><p>用 new 动态创建长度为 0 的数组时，new 返回有效的非零指针。该指针与 new 返回的其他指针不同，不能进行解引用操作，因为它毕竟没有指向任何元素。</p><p><strong>动态空间的释放</strong></p><p>动态分配的内存最后必须进行释放，否则，内存最终将会逐渐耗尽。如果不再需要使用动态创建的数组，程序员必须显式地将其占用的存储空间返还给程序的自由存储区。C++ 语言为指针提供 delete [] 表达式释放指针所指向的数组空间： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete [] pia;</span><br></pre></td></tr></table></figure><p>在关键字 delete 和指针之间的空方括号对是必不可少的：它告诉编译器该指针指向的是自由存储区中的数组，而并非单个对象。 </p><h3 id="4-3-2-新旧代码的兼容"><a href="#4-3-2-新旧代码的兼容" class="headerlink" title="4.3.2 新旧代码的兼容"></a>4.3.2 新旧代码的兼容</h3><p><strong>混合使用标准库类string和C风格字符串</strong></p><p>可用字符串字面值初始化 string 类对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello&quot;);</span><br><span class="line">char s1[10] = &quot;123456&quot;;</span><br><span class="line">string s2(s1);</span><br></pre></td></tr></table></figure><p>无法使用 string 对象初始化字符指针,但是，string 类提供了一个名为 c_str 的成员函数，以实现我们的要求： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;123456&quot;);</span><br><span class="line">const char *const ps = s.c_str();</span><br></pre></td></tr></table></figure><p><strong>使用数组初始化vector对象</strong></p><p>使用数组初始化 vector 对象，必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123; 1,2,3,4,5 &#125;;</span><br><span class="line">vector&lt;int&gt; b(a + 1, a + 4);    //size of b:3;b:2,3,4</span><br></pre></td></tr></table></figure><h2 id="4-4-多维数组"><a href="#4-4-多维数组" class="headerlink" title="4.4 多维数组"></a>4.4 多维数组</h2><p><strong>多维数组的初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123;</span><br><span class="line">&#123;1,2,3&#125;,</span><br><span class="line">&#123;4,5,6&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; 1,2,3,4,5,6 &#125;;</span><br></pre></td></tr></table></figure><p>下面的声明只初始化了每行的第一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123;1&#125;,&#123;4&#125; &#125;;</span><br><span class="line">//1 0 0</span><br><span class="line">//4 0 0</span><br></pre></td></tr></table></figure><h3 id="4-4-1-指针和多维数组"><a href="#4-4-1-指针和多维数组" class="headerlink" title="4.4.1 指针和多维数组"></a>4.4.1 指针和多维数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[2][3] = &#123; &#123;10,20,30&#125;,&#123;40,50,60&#125; &#125;;</span><br><span class="line">int(*p)[3] = a;</span><br><span class="line">cout &lt;&lt; **p &lt;&lt; endl;    //result: 10</span><br><span class="line">p = &amp;a[1];</span><br><span class="line">cout &lt;&lt; *((*p) + 1) &lt;&lt; endl;    //result: 50</span><br></pre></td></tr></table></figure><p><strong>用 typedef 简化指向多维数组的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int int_array[3];</span><br><span class="line">int a[2][3] = &#123; &#123;10,20,30&#125;,&#123;40,50,60&#125; &#125;;</span><br><span class="line">int_array *p = a;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-数组和指针&quot;&gt;&lt;a href=&quot;#第四章-数组和指针&quot; class=&quot;headerlink&quot; title=&quot;第四章 数组和指针&quot;&gt;&lt;/a&gt;第四章 数组和指针&lt;/h1&gt;&lt;h2 id=&quot;4-3-C风格字符串&quot;&gt;&lt;a href=&quot;#4-3-C风格字符串&quot; class=&quot;headerlink&quot; title=&quot;4.3 C风格字符串&quot;&gt;&lt;/a&gt;4.3 C风格字符串&lt;/h2&gt;&lt;p&gt;字符串字面值的类型就是const char 类型的数组。实际上，C 风格字符串既不能确切地归结为 C 语言的类型，也不能归结为 C++ 语言的类型，而是以空字符 null 结束的字符数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson8</title>
    <link href="https://zypsola.com/2018/10/23/C++Primer8/"/>
    <id>https://zypsola.com/2018/10/23/C++Primer8/</id>
    <published>2018-10-23T07:58:31.000Z</published>
    <updated>2018-10-23T15:52:57.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-数组和指针"><a href="#第四章-数组和指针" class="headerlink" title="第四章 数组和指针"></a>第四章 数组和指针</h1><p>C++ 语言提供了两种类似于 vector 和迭代器类型的低级复合类型——<strong>数组</strong>和<strong>指针</strong>。与 vector 类型相似，数组也可以保存某种类型的一组对象；而它们的区别在于，数组的长度是固定的。数组一经创建，就不允许添加新的元素。指针则可以像迭代器一样用于遍历和检查数组中的元素。 </p><a id="more"></a><p>现代 C++ 程序应尽量使用 vector 和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。</p><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组是由类型名、标识符和维数组成的复合数据类型，类型名规定了存放在数组中的元素的类型，而维数则指定数组中包含的元素个数。 </p><h3 id="4-1-1-数组的定义和初始化"><a href="#4-1-1-数组的定义和初始化" class="headerlink" title="4.1.1 数组的定义和初始化"></a>4.1.1 数组的定义和初始化</h3><p>数组的维数必须用值大于等于 1 的常量表达式定义。此常量表达式只能包含整型字面值常量、枚举常量或者用常量表达式初始化的整型 const 对象。非 const 变量以及要到运行阶段才知道其值的 const 变量都不能用于定义数组的维数。 </p><p><strong>显式初始化数组元素</strong></p><p>显式初始化的数组不需要指定数组的维数值，编译器会根据列出的元素个数来确定数组的长度： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[5] = &#123; 1,2,3 &#125;;</span><br><span class="line">cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; &quot; &quot; &lt;&lt; a[2] &lt;&lt; &quot; &quot;</span><br><span class="line"> &lt;&lt; a[3] &lt;&lt; &quot; &quot; &lt;&lt; a[4] &lt;&lt; endl;    //输出结果： 1 2 3 0 0</span><br><span class="line">int b[] = &#123; 1,2,3 &#125;;</span><br></pre></td></tr></table></figure><p><strong>特殊的字符数组</strong></p><p>字符数组既可以用一组由花括号括起来、逗号隔开的字符字面值进行初始化，也可以用一个字符串字面值进行初始化。然而，要注意这两种初始化形式并不完全相同，字符串字面值包含一个额外的空字符（null）用于结束字符串。当使用字符串字面值来初始化创建的新数组时，将在新数组中加入空字符： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a1[] = &#123; &apos;1&apos;,&apos;2&apos;,&apos;3&apos; &#125;;</span><br><span class="line">char a2[] = &#123; &apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;\0&apos; &#125;;</span><br><span class="line">char a3[] = &quot;123&quot;;</span><br><span class="line">cout &lt;&lt; a1 &lt;&lt; endl &lt;&lt; a2 &lt;&lt; endl &lt;&lt; a3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123烫烫烃蚉鉎</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>使用一组字符字面值初始化字符数组时，一定要记得添加结束字符串的空字符。</p><p><strong>不允许数组直接复制和赋值</strong></p><p>与 vector 不同，一个数组不能用另外一个数组初始化，也不能将一个数组赋值给另一个数组，这些操作都是非法的。</p><h3 id="4-1-2-数组操作"><a href="#4-1-2-数组操作" class="headerlink" title="4.1.2 数组操作"></a>4.1.2 数组操作</h3><p>与 vector 元素一样，数组元素可用下标操作符来访问，数组元素也是从 0 开始计数。</p><p>使用数组时，必须保证其下标值在正确范围之内，即数组在该下标位置应对应一个元素。 </p><h2 id="4-2-指针的引入"><a href="#4-2-指针的引入" class="headerlink" title="4.2 指针的引入"></a>4.2 指针的引入</h2><h3 id="4-2-1-什么是指针"><a href="#4-2-1-什么是指针" class="headerlink" title="4.2.1 什么是指针"></a>4.2.1 什么是指针</h3><p>指针的概念很简单：指针用于指向对象。具体来说，指针保存的是另一个对象的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;); </span><br><span class="line">string *sp = &amp;s; // sp holds the address of s</span><br></pre></td></tr></table></figure><p>第二条语句定义了一个指向 string 类型的指针 sp，并初始化 sp 使其指向 string 类型的对象 s。*sp 中的 * 操作符表明 sp 是一个指针变量，&amp;s 中的 &amp; 符号是取地址操作符，当此操作符用于一个对象上时，返回的是该对象的存储地址。</p><p>C++ 语言使用 * 符号把一个标识符声明为指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;   *pvec;      // pvec can point to a vector&lt;int&gt; </span><br><span class="line">int           *ip1, *ip2; // ip1 and ip2 can point to an int </span><br><span class="line">string        *pstring;   // pstring can point to a string </span><br><span class="line">double        *dp;        // dp can point to a double</span><br></pre></td></tr></table></figure><p>理解指针声明语句时，请从右向左阅读。语句把 pstring 定义为一个指向 string 类型对象的指针变量。</p><p>在声明语句中，符号 * 可用在指定类型的对象列表的任何位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double dp, *dp2; /</span><br></pre></td></tr></table></figure><p><strong>另一种声明指针的风格</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps; // legal but can be misleading</span><br></pre></td></tr></table></figure><p>也就是说，该语句把 ps 定义为一个指向 string 类型对象的指针。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps1, ps2;</span><br></pre></td></tr></table></figure><p>实际上只把 ps1 定义为指针，而 ps2 并非指针，只是一个普通的 string 对象而已。如果需要在一个声明语句中定义两个指针，必须在每个变量标识符前再加符号 * 声明： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ing* ps1, *ps2;</span><br></pre></td></tr></table></figure><p><strong>指针可能的取值</strong></p><p>一个有效的指针必然是以下三种状态之一：保存一个特定对象的地址；指向某个对象后面的另一对象；或者是 0 值。若指针保存 0 值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它。</p><p><strong>指针初始化和赋值操作的约束</strong></p><p>对指针进行初始化或赋值只能使用以下四种类型的值： </p><ol><li>0 值常量表达式。</li><li>类型匹配的对象的地址。</li><li>另一对象末的下一地址。</li><li>同类型的另一个有效指针。</li></ol><p>除了使用数值 0 或在编译时值为 0 的 const 量外，还可以使用 C++ 语言从 C 语言中继承下来的预处理器变量 NULL，其值为 0。如果在代码中使用了这个预处理器变量，则编译时会自动被数值 0 替换。因此，把指针初始化为 NULL 等效于初始化为 0 值。</p><p><strong>void*指针</strong></p><p>C++ 提供了一种特殊的指针类型 void*，它可以保存任何类型对象的地址： 表明该指针与一地址值相关，但不清楚存储在此地址上的对象的类型。 </p><p>void* 指针只支持几种有限的操作：与另一个指针进行比较；向函数传递 void* 指针或从函数返回 void* 指针；给另一个 void* 指针赋值。不允许使用 void* 指针操纵它所指向的对象。</p><h3 id="4-2-3-指针操作"><a href="#4-2-3-指针操作" class="headerlink" title="4.2.3 指针操作"></a>4.2.3 指针操作</h3><p>指针提供间接操纵其所指对象的功能。与对迭代器进行解引用操作一样，对指针进行解引用可访问它所指的对象，* 操作符（解引用操作符）将获取指针所指的对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world&quot;); </span><br><span class="line">string *sp = &amp;s;</span><br><span class="line">cout  &lt;&lt;*sp;</span><br></pre></td></tr></table></figure><p>解引用操作符返回指定对象的左值，利用这个功能可修改指针所指对象的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*sp = &quot;goodbye&quot;;</span><br></pre></td></tr></table></figure><p><strong>指向指针的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024; </span><br><span class="line">int *pi = &amp;ival; // pi points to an int </span><br><span class="line">int **ppi = &amp;pi; // ppi points to a pointer to int</span><br></pre></td></tr></table></figure><h3 id="4-2-4-使用指针访问数组元素"><a href="#4-2-4-使用指针访问数组元素" class="headerlink" title="4.2.4 使用指针访问数组元素"></a>4.2.4 使用指针访问数组元素</h3><p>C++ 语言中，指针和数组密切相关。特别是在表达式中使用数组名时，该名字会自动转换为指向数组第一个元素的指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,2,4,6,8&#125;; </span><br><span class="line">int *ip = ia; // ip points to ia[0] </span><br><span class="line">ip = &amp;ia[4]; // ip points to last element in ia</span><br></pre></td></tr></table></figure><p>指针的算术操作只有在原指针和计算出来的新指针都指向同一个数组的元素，或指向该数组存储空间的下一单元时才是合法的。</p><p>两个指针减法操作的结果是标准库类型（library type）ptrdiff_t 的数据。</p><p>在指针上加一个整型数值，其结果仍然是指针。允许在这个结果上直接进行解引用操作，而不必先把它赋给一个新指针： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123; 2,3,4,5,6 &#125;;</span><br><span class="line">cout &lt;&lt; *(a + 4) &lt;&lt; endl;   //result: 6</span><br></pre></td></tr></table></figure><p><strong>下标和指针</strong></p><p>使用下标访问数组时，实际上是使用下标访问指针,在使用下标访问数组时，实际上是对指向数组元素的指针做下标操作。只要指针指向数组元素，就可以对它进行下标操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123; 2,3,4,5,6 &#125;;</span><br><span class="line">int *p = &amp;a[2];</span><br><span class="line">cout &lt;&lt; p[-2] &lt;&lt; endl;   //result: 2</span><br></pre></td></tr></table></figure><h3 id="4-2-5-指针和const限定符"><a href="#4-2-5-指针和const限定符" class="headerlink" title="4.2.5 指针和const限定符"></a>4.2.5 指针和const限定符</h3><p><strong>指向const对象的指针</strong></p><p>如果指针指向 const 对象，则不允许用指针来改变其所指的 const 值。为了保证这个特性，C++ 语言强制要求指向 const 对象的指针也必须具有 const 特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double *cptr;</span><br></pre></td></tr></table></figure><p>这里的 cptr 是一个指向 double 类型 const 对象的指针，const 限定了 cptr 指针所指向的对象类型，而并非 cptr 本身。也就是说，cptr 本身并不是const。在定义时不需要对它进行初始化，如果需要的话，允许给 cptr 重新赋值，使其指向另一个 const 对象。但不能通过 cptr 修改其所指对象的值。</p><p>把一个 const 对象的地址赋给一个普通的、非 const 对象的指针也会导致编译时的错误。</p><p>允许把非 const 对象的地址赋给指向 const 对象的指针。</p><p>在实际的程序中，指向 const 的指针常用作函数的形参。将形参定义为指向 const 的指针，以此确保传递给函数的实际对象在函数中不因为形参而被修改。 </p><p><strong>const指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int errNumb = 0; </span><br><span class="line">int *const curErr = &amp;errNumb;</span><br></pre></td></tr></table></figure><p>与其他 const 量一样，const 指针的值不能修改，const 指针也必须在定义时初始化。</p><p><strong>指向const对象的const指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const double pi = 3.14159; </span><br><span class="line">const double *const pi_ptr = &amp;pi;</span><br></pre></td></tr></table></figure><p>既不能修改所指向对象的值，也不允许修改该指针的指向。</p><p><strong>指针和typedef</strong></p><p>在 typedef中使用指针往往会带来意外的结果。假设给出以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef string *pstring; </span><br><span class="line">const pstring cstr;</span><br></pre></td></tr></table></figure><p>这个定义等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *const cstr;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第四章-数组和指针&quot;&gt;&lt;a href=&quot;#第四章-数组和指针&quot; class=&quot;headerlink&quot; title=&quot;第四章 数组和指针&quot;&gt;&lt;/a&gt;第四章 数组和指针&lt;/h1&gt;&lt;p&gt;C++ 语言提供了两种类似于 vector 和迭代器类型的低级复合类型——&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;指针&lt;/strong&gt;。与 vector 类型相似，数组也可以保存某种类型的一组对象；而它们的区别在于，数组的长度是固定的。数组一经创建，就不允许添加新的元素。指针则可以像迭代器一样用于遍历和检查数组中的元素。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
      <category term="数组" scheme="https://zypsola.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson7</title>
    <link href="https://zypsola.com/2018/10/23/C++Primer7/"/>
    <id>https://zypsola.com/2018/10/23/C++Primer7/</id>
    <published>2018-10-23T02:50:46.000Z</published>
    <updated>2018-10-23T10:00:09.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><h2 id="3-5-标准库-bitset"><a href="#3-5-标准库-bitset" class="headerlink" title="3.5 标准库 bitset"></a>3.5 标准库 bitset</h2><p>有些程序要处理二进制位的有序集，每个位可能包含 0（关）1（开）值。位是用来保存一组项或条件的 yes/no 信息（有时也称标志）的简洁方法。标准库提供的 bitset 类简化了位集的处理。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;bitset&gt; </span><br><span class="line">using std::bitset</span><br></pre></td></tr></table></figure><h3 id="3-5-1-bitset对象的定义和初始化"><a href="#3-5-1-bitset对象的定义和初始化" class="headerlink" title="3.5.1 bitset对象的定义和初始化"></a>3.5.1 bitset对象的定义和初始化</h3><p>似于 vector，bitset 类是一种类模板；而与 vector 不一样的是 bitset 类型对象的区别仅在其长度而不在其类型。在定义 bitset 时，要明确 bitset 含有多少位，须在尖括号内给出它的长度值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;n&gt; b;             //b 有 n 位，每位都 0 </span><br><span class="line">bitset&lt;n&gt; b(u);          //b 是 unsigned long 型 u 的一个副本 </span><br><span class="line">bitset&lt;n&gt; b(s);          //b 是 string 对象 s 中含有的位串的副本 </span><br><span class="line">bitset&lt;n&gt; b(s, pos, n);  //b 是 s 中从位置 pos 开始的&amp;nbps;n 个位的副本。</span><br><span class="line">bitset&lt;32&gt; bitvec;       //32bits, all 0</span><br></pre></td></tr></table></figure><p>给出的长度值必须是常量表达式。长度值值必须定义为整型字面值常量或是已用常量值初始化的整型的 const 对象。 </p><p>bitset 中的位是没有命名的，只能按位置来访问。位集合的位置编号从 0 开始，因此，bitvec 的位序是从 0 到 31。以 0 位开始的位串是低阶位（low-order），以 31 位结束的位串是高阶位（high-order）。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt; a(4);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; 4; i++)</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0100</span><br><span class="line">0010</span><br></pre></td></tr></table></figure><h3 id="用unsigned值初始化bitset对象"><a href="#用unsigned值初始化bitset对象" class="headerlink" title="用unsigned值初始化bitset对象"></a><strong>用unsigned值初始化bitset对象</strong></h3><p>当用 unsigned long 值作为 bitset 对象的初始值时，该值将转化为二进制的位模式。而 bitset 对象中的位集作为这种位模式的副本。如果 bitset 类型长度大于 unsigned long 值的二进制位数，则其余的高阶位将置为 0；如果 bitset 类型长度小于 unsigned long 值的二进制位数，则只使用 unsigned 值中的低阶位，超过 bistset 类型长度的高阶位将被丢弃。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt; a(19);</span><br><span class="line">bitset&lt;6&gt; b(19);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0011</span><br><span class="line">010011</span><br></pre></td></tr></table></figure><h3 id="用string对象初始化bitset对象"><a href="#用string对象初始化bitset对象" class="headerlink" title="用string对象初始化bitset对象"></a><strong>用string对象初始化bitset对象</strong></h3><p>当用 string 对象初始化 bitset 对象时，string 对象直接表示为位模式。从 string 对象读入位集的顺序是从右向左： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str(&quot;1100&quot;);</span><br><span class="line">bitset&lt;8&gt; bita(str);</span><br><span class="line">bitset&lt;8&gt; bitb(&quot;0111&quot;);</span><br><span class="line">cout &lt;&lt; bita &lt;&lt; endl &lt;&lt; bitb &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00001100</span><br><span class="line">00000111</span><br></pre></td></tr></table></figure><p>不一定要把整个 string 对象都作为 bitset 对象的初始值。相反，可以只用某个子串作为初始值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str(&quot;010110111011010&quot;);</span><br><span class="line">bitset&lt;16&gt; bita(str, 1, 8);</span><br><span class="line">bitset&lt;16&gt; bitb(str, str.size() - 9);</span><br><span class="line">cout &lt;&lt; bita &lt;&lt; endl &lt;&lt; bitb &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000010110111</span><br><span class="line">0000000111011010</span><br></pre></td></tr></table></figure></p><p>如果省略第三个参数则意味着取从开始位置一直到 string 末尾的所有字符。</p><h3 id="3-5-2-bitset对象上的操作"><a href="#3-5-2-bitset对象上的操作" class="headerlink" title="3.5.2 bitset对象上的操作"></a>3.5.2 bitset对象上的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b.any()      b 中是否存在置为 1 的二进制位？ </span><br><span class="line">b.none()     b 中不存在置为 1 的二进制位吗？ </span><br><span class="line">b.count()    b 中置为 1 的二进制位的个数 </span><br><span class="line">b.size()     b 中二进制位的个数 </span><br><span class="line">b[pos]       访问 b 中在 pos 处二进制位 </span><br><span class="line">b.test(pos)  b 中在 pos 处的二进制位置为 1 么？ </span><br><span class="line">b.set()      把 b 中所有二进制位都置为 1  </span><br><span class="line">b.set(pos)   把 b 中在 pos 处的二进制位置为 1</span><br><span class="line">b.reset()    把 b 中所有二进制位都置为 0 </span><br><span class="line">b.reset(pos) 把 b 中在 pos 处的二进制位置为 0 </span><br><span class="line">b.flip()     把 b 中所有二进制位逐位取反 </span><br><span class="line">b.flip(pos)  把 b 中在 pos 处的二进制位取反 </span><br><span class="line">b.to_ulong() 用 b 中同样的二进制位返回一个 unsigned long 值 </span><br><span class="line">os &lt;&lt; b      把 b 中的位集输出到 os 流</span><br></pre></td></tr></table></figure><p>count 操作的返回类型是标准库中命名为 size_t 类型。它是一个与机器相关的 unsigned 类型。</p><p><strong>访问bitset对象中的位</strong></p><p>可以用下标操作符来读或写某个索引位置的二进制位。</p><p>bitset 类也支持内置的位操作符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bita = bita &amp; bitb;</span><br><span class="line">cout &lt;&lt; bita &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000010010010</span><br></pre></td></tr></table></figure><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><p><strong>abstract data type（抽象数据类型）:</strong>隐藏其实现的数据类型。使用抽象数据类型时，只需要了解该类型所支持的操作。</p></li><li><p><strong>class template（类模板）:</strong>一个可创建许多潜在类类型的蓝图。使用类模板时，必须给出实际的类型和值。例如，vector 类型是保存给定类型对象的模板。创建一个 vector 对象时，必须指出这个 vector 对象所保存的元素的类型。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;h2 id=&quot;3-5-标准库-bitset&quot;&gt;&lt;a href=&quot;#3-5-标准库-bitset&quot; class=&quot;headerlink&quot; title=&quot;3.5 标准库 bitset&quot;&gt;&lt;/a&gt;3.5 标准库 bitset&lt;/h2&gt;&lt;p&gt;有些程序要处理二进制位的有序集，每个位可能包含 0（关）1（开）值。位是用来保存一组项或条件的 yes/no 信息（有时也称标志）的简洁方法。标准库提供的 bitset 类简化了位集的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
      <category term="bitset" scheme="https://zypsola.com/tags/bitset/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson6</title>
    <link href="https://zypsola.com/2018/10/22/C++Primer6/"/>
    <id>https://zypsola.com/2018/10/22/C++Primer6/</id>
    <published>2018-10-22T13:22:19.000Z</published>
    <updated>2018-10-23T11:25:39.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><h2 id="3-3-标准库-vector-类型"><a href="#3-3-标准库-vector-类型" class="headerlink" title="3.3 标准库 vector 类型"></a>3.3 标准库 vector 类型</h2><p><strong>vector</strong> 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为<strong>容器</strong>，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt; </span><br><span class="line">using std::vector;</span><br></pre></td></tr></table></figure><p>vector 是一个<strong>类模板（class template）</strong>。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。因此，我们可以定义保存 string 对象的 vector，或保存 int 值的 vector，又或是保存自定义的类类型对象（如 Sales_items 对象）的 vector。</p><p>声明从类模板产生的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以 vector 为例，必须说明 vector 保存何种对象的类型，通过将类型放在类模板名称后面的尖括号中来指定类型： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec;               // ivec holds objects of type int </span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;   // holds Sales_items</span><br></pre></td></tr></table></figure><p>vector 不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，vector&lt;int&gt; 和 vector&lt;string&gt; 都是数据类型。</p><h3 id="3-3-1-vector对象的定义和初始化"><a href="#3-3-1-vector对象的定义和初始化" class="headerlink" title="3.3.1 vector对象的定义和初始化"></a>3.3.1 vector对象的定义和初始化</h3><p>vector 类定义了好几种构造函数，用来定义和初始化 vector 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;        \\vector 保存类型为 T 对象。 默认构造函数 v1 为空。 </span><br><span class="line">vector&lt;T&gt; v2(v1);    \\v2 是 v1 的一个副本。 </span><br><span class="line">vector&lt;T&gt; v3(n, i);  \\v3 包含 n 个值为 i 的元素。 </span><br><span class="line">vector&lt;T&gt; v4(n);     \\v4 含有值初始化的元素的 n 个副本。</span><br></pre></td></tr></table></figure><p><strong>创建确定个数的元素</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ivec1;           // ivec1 holds objects of type int </span><br><span class="line">vector&lt;int&gt; ivec2(ivec1);    // ok: copy elements of ivec1 into ivec2 </span><br><span class="line">vector&lt;string&gt; svec(ivec1);  // error: svec holds strings, not ints </span><br><span class="line">vector&lt;int&gt; ivec4(10, -1);       // 10 elements, each initialized to -1 </span><br><span class="line">vector&lt;string&gt; svec(10, &quot;hi!&quot;);  // 10 strings, each initialized to &quot;hi!&quot;</span><br></pre></td></tr></table></figure><p>虽然可以对给定元素个数的 vector 对象预先分配内存，但更有效的方法是先初始化一个空 vector 对象，然后再动态地增加元素。</p><p><strong>值初始化</strong></p><p>如果没有指定元素的初始化式，那么标准库将自行提供一个元素初始值进行值初始化（value initializationd）。这个由库生成的初始值将用来初始化容器中的每个元素，具体值为何，取决于存储在 vector 中元素的数据类型。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; fvec(10); // 10 elements, each initialized to 0 </span><br><span class="line">vector&lt;string&gt; svec(10); // 10 elements, each an empty string</span><br></pre></td></tr></table></figure><p>一些有自定义构造函数但没有默认构造函数的类，在初始化这种类型的 vector 对象时，程序员就不能仅提供元素个数，还需要提供元素初始值。 </p><h3 id="3-3-2-vector对象的操作"><a href="#3-3-2-vector对象的操作" class="headerlink" title="3.3.2 vector对象的操作"></a>3.3.2 vector对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v.empty()       如果 v 为空，则返回 true，否则返回 false。 </span><br><span class="line">v.size()        返回 v 中元素的个数。 </span><br><span class="line">v.empty()       如果 v 为空，则返回 true，否则返回 false。 </span><br><span class="line">v.push_back(t)  在 v 的末尾增加一个值为 t 的元素。 </span><br><span class="line">v[n]            返回 v 中位置为 n 的元素。 </span><br><span class="line">v1 = v2         把 v1 的元素替换为 v2 中元素的副本。 </span><br><span class="line">v1 == v2        如果 v1 与 v2 相等，则返回 true。 </span><br><span class="line">!=, &lt;, &lt;=,  &gt;, and &gt;=       保持这些操作符惯有的含义。</span><br></pre></td></tr></table></figure><p>成员函数 size 返回相应 vector 类定义的 size_type 的值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::size_type       // ok </span><br><span class="line">vector::size_type            // error</span><br></pre></td></tr></table></figure><p><strong>下标操作不添加元素</strong></p><h2 id="3-4-迭代器简介"><a href="#3-4-迭代器简介" class="headerlink" title="3.4 迭代器简介"></a>3.4 迭代器简介</h2><p>除了使用下标来访问 vector 对象的元素外，标准库还提供了另一种访问元素的方法：使用<strong>迭代器（iterator）</strong>。迭代器是一种检查容器内元素并遍历元素的数据类型。 </p><p>标准库为每一种标准容器（包括 vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代 C++ 程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的 vector 类型也是这样。 </p><p><strong>容器的iterator类型</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::iterator iter;</span><br></pre></td></tr></table></figure><p>这符语句定义了一个名为 iter 的变量，它的数据类型是 vector&lt;int&gt; 定义的 iterator 类型。每个标准库容器类型都定义了一个名为 iterator 的成员，这里的 iterator 与迭代器实际类型的含义相同。 </p><p><strong>begin和end操作</strong></p><p>由 begin 返回的迭代器指向第一个元素;由 end 操作返回的迭代器指向 vector 的“末端元素的下一个”。如果 vector 为空，begin 返回的迭代器与 end 返回的迭代器相同。 </p><p>由 end 操作返回的迭代器并不指向 vector 中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完 vector 中所有元素。 </p><p><strong>vector迭代器的自增和解引用运算</strong></p><p>迭代器类型可使用<strong>解引用操作符</strong>（dereference operator）（*）来访问迭代器所指向的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*iter = 0;</span><br></pre></td></tr></table></figure><p>由于 end 操作返回的迭代器不指向任何元素，因此不能对它进行解引用或自增操作。 </p><p>另一对可执行于迭代器的操作就是比较：用 == 或 != , &gt; , &lt; , &lt;= , &gt;= 操作符来比较两个迭代器，如果两个迭代器对象指向同一个元素，则它们相等，否则就不相等。 </p><p><strong>const_iterator</strong></p><p>前面的程序用 vector::iterator 改变 vector 中的元素值。每种容器类型还定义了一种名为 const_iterator 的类型，该类型只能用于读取容器内元素，但不能改变其值。 </p><p>不要把 const_iterator 对象与 const 的 iterator 对象混淆起来。声明一个 const 迭代器时，必须初始化迭代器。一旦被初始化后，就不能改变它的值。</p><p>const_iterator 对象可以用于 const vector 或非 const vector，因为不能改写元素值。const 迭代器这种类型几乎没什么用处：一旦它被初始化后，只能用它来改写其指向的元素，但不能使它指向任何其他元素。 </p><h3 id="3-4-1-迭代器的算术操作"><a href="#3-4-1-迭代器的算术操作" class="headerlink" title="3.4.1 迭代器的算术操作"></a>3.4.1 迭代器的算术操作</h3><p>除了一次移动迭代器的一个元素的增量操作符外，vector 迭代器（其他标准库容器迭代器很少）也支持其他的算术操作。这些操作称为迭代器算术操作（iterator arithmetic）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iter + n;</span><br><span class="line">iter - n;</span><br><span class="line">iter1 - iter2;</span><br></pre></td></tr></table></figure><p>该表达式用来计算两个迭代器对象的距离，该距离是名为 difference_type 的 signed 类型 size_type 的值，这里的 difference_type 是 signed 类型，因为减法运算可能产生负数的结果。该类型可以保证足够大以存储任何两个迭代器对象间的距离。两个迭代器相加的操作是未定义的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;::difference_type dis;</span><br></pre></td></tr></table></figure><p>任何改变 vector 长度的操作都会使已存在的迭代器失效。例如，在调用 push_back 之后，就不能再信赖指向 vector 的迭代器的值了。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;h2 id=&quot;3-3-标准库-vector-类型&quot;&gt;&lt;a href=&quot;#3-3-标准库-vector-类型&quot; class=&quot;headerlink&quot; title=&quot;3.3 标准库 vector 类型&quot;&gt;&lt;/a&gt;3.3 标准库 vector 类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;vector&lt;/strong&gt; 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为&lt;strong&gt;容器&lt;/strong&gt;，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
      <category term="vecter" scheme="https://zypsola.com/tags/vecter/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson5</title>
    <link href="https://zypsola.com/2018/10/22/C++Primer5/"/>
    <id>https://zypsola.com/2018/10/22/C++Primer5/</id>
    <published>2018-10-22T05:06:25.000Z</published>
    <updated>2018-10-22T13:24:51.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-标准库类型"><a href="#第三章-标准库类型" class="headerlink" title="第三章 标准库类型"></a>第三章 标准库类型</h1><p>除第二章介绍的基本数据类型外，C++ 还定义了一个内容丰富的抽象数据类型标准库。其中最重要的标准库类型是 <strong>string</strong> 和 <strong>vector</strong>，它们分别定义了大小可变的字符串和集合。string 和 vector 往往将迭代器用作配套类型（companion type），用于访问 string 中的字符，或者 vector 中的元素。这些标准库类型是语言组成部分中更基本的那些数据类型（如数组和指针）的抽象。</p><a id="more"></a><p>另一种标准库类型 bitset，提供了一种抽象方法来操作位的集合。与整型值上的内置位操作符相比，bitset 类类型提供了一种更方便的处理位的方式。 </p><h2 id="3-1-命名空间的-using-声明"><a href="#3-1-命名空间的-using-声明" class="headerlink" title="3.1 命名空间的 using 声明"></a>3.1 命名空间的 using 声明</h2><p>从标准输入读取数据时，就用 std::cin。这些名字都用了:: 操作符，该操作符是作用域操作符。它的含义是右操作数的名字可以在左操作数的作用域中找到。</p><p>C++ 提供了更简洁的方式来使用命名空间成员。本节将介绍一种最安全的机制：<strong>using 声明</strong>。</p><p>using 声明的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace::name;</span><br></pre></td></tr></table></figure><p>一旦使用了 using 声明，我们就可以直接引用名字，而不需要再引用该名字的命名空间。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using std::cin; </span><br><span class="line">using std::string; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    string s;       // ok: string is now a synonym for std::string </span><br><span class="line">    cin &gt;&gt; s;       // ok: cin is now a synonym for std::cin </span><br><span class="line">    cout &lt;&lt; s;      // error: no using declaration; we must use full name </span><br><span class="line">    std::cout &lt;&lt; s; // ok: explicitly use cout from namepsace std </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种情况下，必须总是使用完全限定的标准库名字：<strong>在头文件中</strong>。理由是头文件的内容会被预处理器复制到程序中。用 #include 包含文件时，相当于头文件中的文本将成为我们编写的文件的一部分。如果在头文件中放置 using 声明，就相当于在包含该头文件 using 的每个程序中都放置了同一 using，不论该程序是否需要 using 声明。 </p><h2 id="3-2-标准库-string-类型"><a href="#3-2-标准库-string-类型" class="headerlink" title="3.2 标准库 string 类型"></a>3.2 标准库 string 类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt; </span><br><span class="line">using std::string;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-string对象的定义和初始化"><a href="#3-2-1-string对象的定义和初始化" class="headerlink" title="3.2.1 string对象的定义和初始化"></a>3.2.1 string对象的定义和初始化</h3><p>string 标准库支持几个构造函数。当没有明确指定对象初始化式时，系统将使用默认构造函数。</p><p><strong>string 类型常用的构造函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;           //默认构造函数，s1 为空串</span><br><span class="line">string s2(s1);       //将 s2 初始化为 s1 的一个副本</span><br><span class="line">string s3(&quot;value&quot;);  //将 s3 初始化为一个字符串字面值副本</span><br><span class="line">string s4(n, &apos;c&apos;);   //将 s4 初始化为字符 &apos;c&apos; 的 n 个副本</span><br></pre></td></tr></table></figure><p>因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 string 类型不是同一种类型。</p><h3 id="3-2-2-string-对象的读写"><a href="#3-2-2-string-对象的读写" class="headerlink" title="3.2.2 string 对象的读写"></a>3.2.2 string 对象的读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;          // empty string </span><br><span class="line">cin &gt;&gt; s;          // read whitespace-separated string into s </span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; // write s to the output</span><br></pre></td></tr></table></figure><p>从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符： </p><ol><li>读取并忽略开头所有的空白字符（如空格，换行符，制表符）。</li><li>读取字符直至再次遇到空白字符，读取终止。</li></ol><p><strong>读入未知数目的string对象</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string sss;</span><br><span class="line">while (cin &gt;&gt; sss)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sss &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用getline读取整行文本</strong></p><p>另外还有一个有用的 string IO 操作：getline。这个函数接受两个参数：一个输入流对象和一个 string 对象。getline 函数从输入流的下一行读取，并保存读取的内容到不包括换行符。和输入操作符不一样的是，getline 并不忽略行开头的换行符。只要 getline 遇到换行符，即便它是输入的第一个字符，getline 也将停止读入并返回。如果第一个字符就是换行符，则 string 参数将被置为空 string。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string sss;</span><br><span class="line">while (getline(cin, sss))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; sss &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getline 函数将 istream 参数作为返回值，和输入操作符一样也把它用作判断条件。</p><h3 id="3-2-3-string对象的操作"><a href="#3-2-3-string对象的操作" class="headerlink" title="3.2.3 string对象的操作"></a>3.2.3 string对象的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.empty()       //如果 s 为空串，则返回 true，否则返回 false。</span><br><span class="line">s.size()        //返回 s 中字符的个数 </span><br><span class="line">s[n]            //返回 s 中位置为 n 的字符，位置从 0 开始计数</span><br><span class="line">s1 + s2         //把 s1 和 s2 连接成一个新字符串，返回新生成的字符串</span><br><span class="line">s1 = s2         //把 s1 内容替换为 s2 的副本</span><br><span class="line">v1 == v2        //比较 v1 与 v2 的内容，相等则返回 true，否则返回 false </span><br><span class="line">!=,&lt;,&gt;,&lt;=,&gt;=    //保持这些操作符惯有的含义</span><br></pre></td></tr></table></figure><p><strong>string::size_type类型</strong></p><p>从逻辑上来讲，size() 成员函数似乎应该返回整形数值，或如 2.2 节“建议”中所述的无符号整数。但事实上，size 操作返回的是 string::size_type 类型的值。</p><p>string 类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine-independent）。<br>size_type 就是这些配套类型中的一种。它定义为与 unsigned 型（unsigned int 或 unsigned long）具有相同的含义，而且可以保证足够大能够存储任意 string 对象的长度。为了使用由 string 类型定义的 size_type 类型是由 string 类定义。 </p><p><strong>string 关系操作符</strong></p><p>string 对象比较操作是区分大小写的，即同一个字符的大小写形式被认为是两个不同的字符。在多数计算机上，大写的字母位于小写之前：任何一个大写之母都小于任意的小写字母。</p><p>如果两个 string 对象长度不同，且短的 string 对象与长的 string 对象的前面部分相匹配，则短的 string 对象小于长的 string 对象。 </p><p>如果 string 对象的字符不同，则比较第一个不匹配的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string substr = &quot;Hello&quot;; </span><br><span class="line">string phrase = &quot;Hello World&quot;; </span><br><span class="line">string slang  = &quot;Hiya&quot;;</span><br></pre></td></tr></table></figure><p>则 substr 小于 phrase，而 slang 则大于 substr 或 phrase</p><p><strong>两个string对象相加</strong></p><p>string 对象的加法被定义为连接（concatenation）。也就是说，两个（或多个）string 对象可以通过使用加操作符 + 或者复合赋值操作符 += 连接起来。</p><p><strong>和字符串字面值的连接</strong></p><p>可以通过将 string 对象和字符串字面值混合连接得到同样的结果。</p><p>当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;hello&quot;;   // no punctuation </span><br><span class="line">string s2 = &quot;world&quot;; </span><br><span class="line">string s3 = s1 + &quot;, &quot;;           // ok: adding a string and a literal </span><br><span class="line">string s4 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operand </span><br><span class="line">string s5 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has string operand </span><br><span class="line">string s6 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can&apos;t add string literals</span><br></pre></td></tr></table></figure><p><strong>从string对象获取字符</strong></p><p>string 类型通过下标操作符（[ ]）来访问 string 对象中的单个字符。下标操作符需要取一个 size_type 类型的值，来标明要访问字符的位置。这个下标中的值通常被称为“下标”或“索引”（index）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (string::size_type ix = 0; ix != str.size(); ++ix) </span><br><span class="line">    str[ix] = &apos;*&apos;;</span><br></pre></td></tr></table></figure><p>任何可产生整型值的表达式可用作下标操作符的索引。</p><p>标准库不要求检查索引值，所用索引的下标越界是没有定义的，这样往往会导致严重的运行时错误。 </p><h2 id="3-2-4-string对象中字符的处理"><a href="#3-2-4-string对象中字符的处理" class="headerlink" title="3.2.4 string对象中字符的处理"></a>3.2.4 string对象中字符的处理</h2><p>我们经常要对 string 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。下列出了各种字符操作函数，适用于 string 对象的字符（或其他任何 char 值）。这些函数都在 <strong>cctype 头文件</strong>中定义。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)   //如果 c 是字母或数字，则为 True。 </span><br><span class="line">isalpha(c)   //如果 c 是字母，则为 true。 </span><br><span class="line">iscntrl(c)   //如果 c 是控制字符，则为 true  </span><br><span class="line">isdigit(c)   //如果 c 是数字，则为 true。 </span><br><span class="line">isgraph(c)   //如果 c 不是空格，但可打印，则为 true。 </span><br><span class="line">islower(c)   //如果 c 是小写字母，则为 true。 </span><br><span class="line">isprint(c)   //如果 c 是可打印的字符，则为 true。 </span><br><span class="line">ispunct(c)   //如果 c 是标点符号，则 true。 </span><br><span class="line">isspace(c)   //如果 c 是空白字符，则为 true。 </span><br><span class="line">isupper(c)   //如果 c 是大写字母，则 true。 </span><br><span class="line">isxdigit(c)  //如果是 c 十六进制数，则为 true。 </span><br><span class="line">tolower(c)   //如果 c 大写字母，返回其小写字母形式，否则直接返回 c。 </span><br><span class="line">toupper(c)   //如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c</span><br></pre></td></tr></table></figure><p>可打印的字符是指那些可以表示的字符，空白字符则是空格、制表符、垂直制表符、回车符、换行符和进纸符中的任意一种；标点符号则是除了数字、字母或（可打印的）空白字符（如空格）以外的其他可打印字符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第三章-标准库类型&quot;&gt;&lt;a href=&quot;#第三章-标准库类型&quot; class=&quot;headerlink&quot; title=&quot;第三章 标准库类型&quot;&gt;&lt;/a&gt;第三章 标准库类型&lt;/h1&gt;&lt;p&gt;除第二章介绍的基本数据类型外，C++ 还定义了一个内容丰富的抽象数据类型标准库。其中最重要的标准库类型是 &lt;strong&gt;string&lt;/strong&gt; 和 &lt;strong&gt;vector&lt;/strong&gt;，它们分别定义了大小可变的字符串和集合。string 和 vector 往往将迭代器用作配套类型（companion type），用于访问 string 中的字符，或者 vector 中的元素。这些标准库类型是语言组成部分中更基本的那些数据类型（如数组和指针）的抽象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson4</title>
    <link href="https://zypsola.com/2018/10/21/C++Primer4/"/>
    <id>https://zypsola.com/2018/10/21/C++Primer4/</id>
    <published>2018-10-21T13:18:45.000Z</published>
    <updated>2018-10-22T07:36:48.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-8-类类型"><a href="#2-8-类类型" class="headerlink" title="2.8 类类型"></a>2.8 类类型</h2><p>C++ 中，通过定义类来自定义数据类型。类定义了该类型的对象包含的数据和该类型的对象可以执行的操作。</p><p>每个类都定义了一个<strong>接口</strong>和一个<strong>实现</strong>。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。 </p><a id="more"></a><p>类体可以为空。类体定义了组成该类型的数据和操作。这些操作和数据是类的一部分，也称为类的成员。操作称为成员函数，而数据则称为<strong>数据成员</strong>。 </p><p>定义变量和定义数据成员存在非常重要的区别：一般不能把类成员的初始化作为其定义的一部分。当定义数据成员时，只能指定该数据成员的名字和类型。类不是在类定义里定义数据成员时初始化数据成员，而是通过称为构造函数的特殊成员函数控制初始化。</p><p><strong>使用struct关键字</strong></p><p>C++ 支持另一个关键字 struct，它也可以定义类类型。struct 关键字是从 C 语言中继承过来的。 </p><p>如果使用 class 关键字来定义类，那么定义在第一个访问标号前的任何成员都隐式指定为 private；如果使用 struct 关键字，那么这些成员都是 public。使用 class 还是 struct 关键字来定义类，仅仅影响默认的初始访问级别。 </p><h2 id="2-9-编写自己的头文件"><a href="#2-9-编写自己的头文件" class="headerlink" title="2.9 编写自己的头文件"></a>2.9 编写自己的头文件</h2><p>一般类定义都会放入<strong>头文件</strong>。</p><p>头文件一般包含类的定义、extern 变量的声明和函数的声明。</p><p>因为头文件包含在多个源文件中，所以不应该含有变量或函数的定义。 </p><p>对于头文件不应该含有定义这一规则，有三个例外。头文件可以定义类、值在编译时就已知道的 const 对象和 inline 函数。这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。 </p><p>在头文件中定义这些实体，是因为编译器需要它们的定义（不只是声明）来产生代码。例如：为了产生能定义或使用类的对象的代码，编译器需要知道组成该类型的数据成员。同样还需要知道能够在这些对象上执行的操作。类定义提供所需要的信息。在头文件中定义 const 对象则需要更多的解释。 </p><p>当我们在头文件中定义了 const 变量后，每个包含该头文件的源文件都有了自己的 const 变量，其名称和值都一样。 </p><p>当该 const 变量是用常量表达式初始化时，可以保证所有的变量都有相同的值。</p><p>如果 const 变量不是用常量表达式初始化，那么它就不应该在头文件中定义。相反，和其他的变量一样，该 const 变量应该在一个源文件中定义并初始化。应在头文件中为它添加 extern 声明，以使其能被多个文件共享。 </p><h3 id="预处理器的简单介绍"><a href="#预处理器的简单介绍" class="headerlink" title="预处理器的简单介绍"></a>预处理器的简单介绍</h3><p>#include 设施是 C++ 预处理器的一部分。预处理器处理程序的源代码，在编译器之前运行。C++ 继承了 C 的非常精细的预处理器。现在的 C++ 程序以高度受限的方式使用预处理器。 </p><p>#include 指示只接受一个参数：头文件名。预处理器用指定的头文件的内容替代每个 #include。</p><p>我们必须保证多次包含同一头文件不会引起该头文件定义的类和对象被多次定义。使得头文件安全的通用做法，是使用预处理器定义<strong>头文件保护符</strong>。</p><p><strong>预处理器变量</strong> 的名字在程序中必须是唯一的。为了避免名字冲突，预处理器变量经常用全大写字母表示。 </p><p>预处理器变量有两种状态：已定义或未定义。定义预处理器变量和检测其状态所用的预处理器指示不同。#define 指示接受一个名字并定义该名字为预处理器变量。#ifndef 指示检测指定的预处理器变量是否未定义。如果预处理器变量未定义，那么跟在其后的所有指示都被处理，直到出现 #endif。 </p><p>可以使用这些设施来预防多次包含同一头文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H </span><br><span class="line">#define SALESITEM_H </span><br><span class="line">// Definition of Sales_itemclass and related functions goes here </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>条件指示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H</span><br></pre></td></tr></table></figure><p>测试 SALESITEM_H 预处理器变量是否未定义。如果 SALESITEM_H 未定义，那么 #ifndef 测试成功，跟在 #ifndef 后面的所有行都被执行，直到发现 #endif。相反，如果 SALESITEM_H 已定义，那么 #ifndef 指示测试为假，该指示和 #endif 指示间的代码都被忽略。 </p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a><strong>术语</strong></h2><ol><li><p><strong>access labels（访问标号）：</strong>类的成员可以定义为 private，这能够防止使用该类型的代码访问该成员。成员还可以定义为 public，这将使该整个程序中都可访问成员。 </p></li><li><p><strong>implementation（实现）：</strong>定义数据和操作的类成员（通常为 private），这些数据和操作并非为使用该类型的代码所用。例如，istream 和 ostream 类管理的 IO 缓冲区是它们的实现的一部分，但并不允许这些类的使用者直接访问。 </p></li><li><p><strong>interface（接口）：</strong>由某种类型支持的操作。设计良好的类分离了接口和实现，在类的 public 部分定义接口，private 部分定义实现。数据成员一般是实现的一部分。当函数成员是期望该类型的使用者使用的操作时，函数成员就是接口的一部分（因此为 public）；当函数成员执行类所需要的、非一般性使用的操作时，函数成员就是实现的一部分。 </p></li><li><p><strong>link（链接）：</strong>一个编译步骤，此时多个目标文件放置在一起以形成可执行程序。链接步骤解决了文件间的依赖，如将一个文件中的函数调用链接到另一个文件中的函数定义。 </p></li><li><p><strong>type-checking（类型检查）：</strong>编译器验证给定类型的对象的使用方式是否与该类型的定义一致，描述这一过程的术语。 </p></li><li><p><strong>word（字）：</strong>机器上的自然的整型计算单元。通常一个字足以容纳一个地址。一般在 32 位的机器上，机器字长为 4 个字节。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;h2 id=&quot;2-8-类类型&quot;&gt;&lt;a href=&quot;#2-8-类类型&quot; class=&quot;headerlink&quot; title=&quot;2.8 类类型&quot;&gt;&lt;/a&gt;2.8 类类型&lt;/h2&gt;&lt;p&gt;C++ 中，通过定义类来自定义数据类型。类定义了该类型的对象包含的数据和该类型的对象可以执行的操作。&lt;/p&gt;
&lt;p&gt;每个类都定义了一个&lt;strong&gt;接口&lt;/strong&gt;和一个&lt;strong&gt;实现&lt;/strong&gt;。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供一般性使用的函数。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson3</title>
    <link href="https://zypsola.com/2018/10/20/C++Primer3/"/>
    <id>https://zypsola.com/2018/10/20/C++Primer3/</id>
    <published>2018-10-20T12:27:10.000Z</published>
    <updated>2018-10-24T10:40:47.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h2><p>C++ 是一门静态类型语言，在编译时会作类型检查。 </p><p>在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。 </p><a id="more"></a><p>在 C++ 中，操作是否合法是在编译时检查的。当编写表达式时，编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话，那么编译器会提示错误，而不产生可执行文件。 </p><p>随着程序和使用的类型变得越来越复杂，我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此，程序中使用变量前必须先定义变量的类型 </p><h3 id="2-3-1-什么是变量"><a href="#2-3-1-什么是变量" class="headerlink" title="2.3.1 什么是变量"></a>2.3.1 什么是变量</h3><p>变量提供了程序可以操作的有名字的存储区。C++ 中的每一个变量都有特定的类型，该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。C++ 程序员常常把变量称为“变量”或“对象（object）”。 </p><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a><strong>左值和右值</strong></h3><p><strong>左值（lvalue）</strong>：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。<br><strong>右值（rvalue）</strong>：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</p><p><strong>什么是对象？</strong></p><p>C++ 程序员经常随意地使用术语对象。一般而言，对象就是内存中具有类型的区域。说得更具体一些，计算左值表达式就会产生对象。 </p><p>严格地说，有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象，当谈到有名字的对象时一般指变量。还有一些人区分对象和值，用术语对象描述可被程序改变的数据，用术语值描述只读数据。 </p><p>在本书中，我们遵循更为通用的用法，即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据，而不管这些数据是内置类型还是类类型，是有名字的还是没名字的，是可读的还是可写的。 </p><h3 id="2-3-2-变量名"><a href="#2-3-2-变量名" class="headerlink" title="2.3.2 变量名"></a>2.3.2 变量名</h3><p>变量名，即变量的<strong>标识符</strong>，可以由字母、数字和下划线组成。变量名必须以字母或下划线开头，并且区分大小写字母：C++ 中的标识符都是大小写敏感的。</p><p>C++ 保留了一组词用作该语言的关键字。关键字不能用作程序的标识符。</p><p>C++ 还保留了一些词用作各种操作符的替代名。这些替代名用于支持某些不支持标准 C++操作符号集的字符集。它们也不能用作标识符。</p><h3 id="2-3-3-定义对象"><a href="#2-3-3-定义对象" class="headerlink" title="2.3.3 定义对象"></a>2.3.3 定义对象</h3><p><strong>初始化</strong><br>变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时指定了初始值的对象被称为是<strong>已初始化的</strong>。C++ 支持两种初始化变量的形式：<strong>复制初始化</strong>和<strong>直接初始化</strong>。复制初始化语法用等号（=），直接初始化则是把初始化式放在括号中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ival(1024);     // direct-initialization </span><br><span class="line">int ival = 1024;    // copy-initialization</span><br></pre></td></tr></table></figure><p>在 C++ 中理解“初始化不是赋值”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。 </p><p>当初始化类类型对象时，复制初始化和直接初始化之间的差别是很微妙的，直接初始化语法更灵活且效率更高。 </p><h3 id="2-3-4-变量初始化规则"><a href="#2-3-4-变量初始化规则" class="headerlink" title="2.3.4 变量初始化规则"></a>2.3.4 变量初始化规则</h3><p>内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，<strong>未初始化</strong>变量用作任何其他用途都是没有定义的。</p><h3 id="2-3-4-声明和定义"><a href="#2-3-4-声明和定义" class="headerlink" title="2.3.4 声明和定义"></a>2.3.4 声明和定义</h3><p>C++ 程序通常由许多文件组成。为了让多个文件访问相同的变量，C++ 区分了声明和定义。 </p><p>变量的<strong>定义</strong>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。 </p><p><strong>声明</strong>用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用 extern 关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字 extern：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i;   // declares but does not define i </span><br><span class="line">int i;          //  declares and defines i</span><br></pre></td></tr></table></figure><p>extern 声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。<strong>程序中变量可以声明多次，但只能定义一次。</strong></p><p>只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为 extern：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern double pi = 3.1416; // definition</span><br></pre></td></tr></table></figure><p>虽然使用了 extern ，但是这条语句还是定义了 pi，分配并初始化了存储空间。只有当 extern 声明位于函数外部时，才可以含有初始化式。 </p><p>任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。 </p><h3 id="2-3-6-名字的作用域"><a href="#2-3-6-名字的作用域" class="headerlink" title="2.3.6 名字的作用域"></a>2.3.6 名字的作用域</h3><p><strong>C++ 中作用域可嵌套</strong></p><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>const 把一个对象转换成一个常量。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int bufSize = 512; // input buffer size</span><br></pre></td></tr></table></figure><p>定义 bufSize 为常量并初始化为 512。变量 bufSize 仍然是一个左值，但是现在这个左值是不可修改的。任何修改 bufSize 的尝试都会导致编译错误。</p><p>因为常量在定义后就不能被修改，所以定义时必须初始化。</p><p><strong>const 对象默认为文件的局部变量</strong></p><p>在全局作用域里定义非 const 变量时，它在整个程序中都可以访问。与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。</p><p>通过指定 const 变更为 extern，就可以在整个程序中访问 const 对象： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// file_1.cc </span><br><span class="line">extern const int bufSize = fcn(); </span><br><span class="line">// file_2.cc </span><br><span class="line">extern const int bufSize;</span><br><span class="line">for (int index = 0; index != bufSize; ++index)</span><br></pre></td></tr></table></figure><p>非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须地指定它为 extern。 </p><h2 id="2-5-引用"><a href="#2-5-引用" class="headerlink" title="2.5 引用"></a>2.5 引用</h2><p><strong>引用</strong>就是对象的另一个名字。在实际程序中，引用主要用作函数的形式参数。</p><p>引用是一种<strong>复合类型</strong>，通过在变量名前添加“&amp;”符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用，但可以定义任何其他类型的引用</p><p>引用必须用与该引用同类型的对象初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ival = 1024; </span><br><span class="line">int &amp;refVal = ival; // ok: refVal refers to ival </span><br><span class="line">int &amp;refVal2;       // error: a reference must be initialized </span><br><span class="line">int &amp;refVal3 = 10;  // error: initializer must be an object</span><br></pre></td></tr></table></figure><p><strong>引用是别名</strong></p><p>因为引用只是它绑定的对象的另一名字，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。</p><p><strong>const 引用</strong>是指向 const 对象的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ival = 1024; </span><br><span class="line">const int &amp;refVal = ival;      // ok: both reference and object are const </span><br><span class="line">int &amp;ref2 = ival;              // error: non const reference to a const objec</span><br></pre></td></tr></table></figure><p>const 引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 42; </span><br><span class="line">//  legal for const references only </span><br><span class="line">const int &amp;r = 42; </span><br><span class="line">const int &amp;r2 = r + i;</span><br></pre></td></tr></table></figure><p>同样的初始化对于非 const 引用却是不合法的，而且会导致编译时错误。</p><p>观察将引用绑定到不同的类型时所发生的事情，最容易理解上述行为。假如我们编写： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14; </span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure><p>编译器会把这些代码转换成如以下形式的编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int temp = dval;        // create temporary int from the double </span><br><span class="line">const int &amp;ri = temp;   // bind ri to that temporary</span><br></pre></td></tr></table></figure><p>如果 ri 不是 const，那么可以给 ri 赋一新值。这样做不会修改 dval，而是修改了 temp。期望对 ri 的赋值会修改 dval 的程序员会发现 dval 并没有被修改。仅允许 const 引用绑定到需要临时使用的值完全避免了这个问题，因为 const 引用是只读的。</p><p>非 const 引用只能绑定到与该引用同类型的对象。</p><p>const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</p><h2 id="2-6-typedef-名字"><a href="#2-6-typedef-名字" class="headerlink" title="2.6 typedef 名字"></a>2.6 typedef 名字</h2><p>typedef 可以用来定义类型的同义词：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef double wages;       //  wages is a synonym for double </span><br><span class="line">typedef int exam_score;     //  exam_score is a synonym for int </span><br><span class="line">typedef wages salary;       //  indirect synonym for double</span><br></pre></td></tr></table></figure><p>typedef 定义以关键字 typedef 开始，后面是数据类型和标识符。标识符或类型名并没有引入新的类型，而只是现有数据类型的同义词。typedef 名字可出现在程序中类型名可出现的任何位置。 </p><p>typedef 通常被用于以下三种目的：</p><ol><li>为了隐藏特定类型的实现，强调使用类型的目的。 </li><li>简化复杂的类型定义，使其更易理解。 </li><li>允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。</li></ol><h2 id="2-7-枚举"><a href="#2-7-枚举" class="headerlink" title="2.7 枚举"></a>2.7 枚举</h2><p>枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员列表。 </p><p>默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大 1。 </p><p><strong>枚举成员是常量</strong></p><p>可以为一个或多个枚举成员提供初始值，用来初始化枚举成员的值必须是一个常量表达式。常量表达式是编译器在编译时就能够计算出结果的整型表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Forms &#123;shape = 1, sphere, cylinder, polygon&#125;;</span><br></pre></td></tr></table></figure><p>在 枚举类型 Forms 中，显式将 shape 赋值为 1。其他枚举成员隐式初始化：sphere 初始化为 2，cylinder 初始化为 3，polygon 初始化为 4。 </p><p>枚举成员值可以是不唯一的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Points &#123; point2d = 2, point2w, point3d = 3, point3w &#125;;</span><br></pre></td></tr></table></figure><p>本例中，枚举成员 point2d 显式初始化为 2。下一个枚举成员 point2w 默认初始化，即它的值比前一枚举成员的值大 1。因此 point2w 初始化为 3。枚举成员 point3d 显式初始化为 3。一样，point3w 默认初始化，结果为 4。 </p><p>不能改变枚举成员的值。枚举成员本身就是一个常量表达式，所以也可用于需要常量表达式的任何地方。 </p><p><strong>每个 enum 都定义一种唯一的类型</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;h2 id=&quot;2-3-变量&quot;&gt;&lt;a href=&quot;#2-3-变量&quot; class=&quot;headerlink&quot; title=&quot;2.3 变量&quot;&gt;&lt;/a&gt;2.3 变量&lt;/h2&gt;&lt;p&gt;C++ 是一门静态类型语言，在编译时会作类型检查。 &lt;/p&gt;
&lt;p&gt;在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson2</title>
    <link href="https://zypsola.com/2018/10/20/C++Primer2/"/>
    <id>https://zypsola.com/2018/10/20/C++Primer2/</id>
    <published>2018-10-20T05:40:10.000Z</published>
    <updated>2018-10-21T10:25:15.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><p>类型是所有程序的基础。类型告诉我们数据代表什么意思以及可以对数据执行哪些操作。<br>C++ 语言定义了几种基本类型：字符型、整型、浮点型等。C++ 还提供了可用于自定义数据类型的机制，标准库正是利用这些机制定义了许多更复杂的类型，比如可变长字符串 string、vector 等。此外，我们还能修改已有的类型以形成复合类型。</p><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><a id="more"></a><ol><li><p>C++ 定义了一组表示整数、浮点数、单个字符和布尔值的算术类型，另外还定义了一种称为 void 的特殊类型。void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。 </p></li><li><p>算术类型的存储空间依机器而定。这里的存储空间是指用来表示该类型的位（bit）数。C++标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间。事实上，对于 int 类型，几乎所有的编译器使用的存储空间都比所要求的大。</p></li></ol><h3 id="2-1-1-整型"><a href="#2-1-1-整型" class="headerlink" title="2.1.1 整型"></a>2.1.1 整型</h3><p>表示整数、字符和布尔值的算术类型合称为<strong>整型</strong>。</p><h3 id="2-1-2-浮点型"><a href="#2-1-2-浮点型" class="headerlink" title="2.1.2 浮点型"></a>2.1.2 浮点型</h3><p>类型 float、 double 和 long double 分别表示单精度浮点数、双精度浮点数和扩展精度浮点数。</p><h2 id="2-2-字面值常量"><a href="#2-2-字面值常量" class="headerlink" title="2.2 字面值常量"></a>2.2 字面值常量</h2><p>像 42 这样的值，在程序中被当作字面值常量。称之为字面值是因为只能用它的值称呼它，称之为常量是因为它的值不能修改。每个字面值都有相应的类型，例如：0 是 int 型，3.14159 是 double 型。只有内置类型存在字面值，没有类类型的字面值。因此，也没有任何标准库类型的字面值。 </p><ol><li><strong>整型字面值规则</strong><br>定义字面值整数常量可以使用以下三种进制中的任一种：十进制、八进制和十六进制。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20     // decimal </span><br><span class="line">024    // octal </span><br><span class="line">0x14   // hexadecimal</span><br></pre></td></tr></table></figure><p>字面值整数常量的类型默认为 int 或 long 类型。其精度类型决定于字面值——其值适合 int 就是 int 类型，比 int 大的值就是 long 类型。通过增加后缀，能够强制将字面值整数常量转换为 long、unsigned 或 unsigned long 类型。通过在数值后面加 L 或者 l（字母“l”大写或小写）指定常量为 long 类型。 </p><p>类似地，可通过在数值后面加 U 或 u 定义 unsigned 类型。同时加 L 和 U 就能够得到 unsigned long 类型的字面值常量。但其后缀不能有空格： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">128u  /* unsigned */</span><br><span class="line">24UL  /* unsigned long */ </span><br><span class="line">1L    /* long */ </span><br><span class="line">8Lu   /* unsigned long */</span><br></pre></td></tr></table></figure><p>没有 short 类型的字面值常量。</p><ol start="2"><li><strong>浮点字面值规则</strong></li></ol><p>通常可以用十进制或者科学计数法来表示浮点字面值常量。使用科学计数法时，指数用 E 或者 e 表示。默认的浮点字面值常量为 double 类型。在数值的后面加上 F 或 f 表示单精度。同样加上 L 或者 l 表示扩展精度（再次提醒，不提倡使用小写字母 l）。下面每一组字面值表示相同的值： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.14159F            .001f          12.345L            0. </span><br><span class="line">3.14159E0f          1E-3F          1.2345E1L          0e0</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>布尔字面值和字符字面值</strong></li></ol><p>单词 true 和 false 是布尔型的字面值。</p><p>可打印的字符型字面值通常用一对单引号来定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;a&apos; &apos;2&apos; &apos;,&apos; &apos; &apos; // blank</span><br></pre></td></tr></table></figure><p>这些字面值都是 char 类型的。在字符字面值前加 L 就能够得到 wchar_t 类型的宽字符字面值。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&apos;a&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>非打印字符的转义序列</strong></li></ol><p>有些字符是不可打印的。不可打印字符实际上是不可显示的字符，比如退格或者控制符。还有一些在语言中有特殊意义的字符，例如单引号、双引号和反斜线符号。不可打印字符和特殊字符都用转义字符书写。转义字符都以反斜线符号开始，C++ 语言中定义了如下转义字符： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换行符        \n 水平制表符    \t</span><br><span class="line">纵向制表符    \v 退格符        \b</span><br><span class="line">回车符        \r 进纸符        \f</span><br><span class="line">报警(响铃)符  \a 反斜线        \\</span><br><span class="line">疑问号        \? 单引号        \&apos;</span><br><span class="line">双引号        \&quot;</span><br></pre></td></tr></table></figure><p>我们可以将任何字符表示为以下形式的通用转义字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\ooo</span><br></pre></td></tr></table></figure><p>这里 ooo 表示三个八进制数字，这三个数字表示字符的数字值。下面的例子是用 ASCII 码字符集表示字面值常量： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\7 (bell)      \12 (newline)     \40 (blank) </span><br><span class="line">\0 (null)      \062 (&apos;2&apos;)        \115 (&apos;M&apos;)</span><br></pre></td></tr></table></figure><p>同样也可以用十六进制转义字符来定义字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xddd</span><br></pre></td></tr></table></figure><p>它由一个反斜线符、一个 x 和一个或者多个十六进制数字组成。</p><ol start="5"><li><strong>字符串字面值</strong></li></ol><p>字符串字面值常量用双引号括起来的零个或者多个字符表示。不可打印字符表示成相应的转义字符。 </p><p>为了兼容 C 语言，C++ 中所有的字符串字面值都由编译器自动在末尾添加一个空字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;A&quot;    //表示包含字母 A 和空字符两个字符的字符串。</span><br></pre></td></tr></table></figure><p>也存在宽字符串字面值，一样在前面加“L”，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L&quot;a wide string literal&quot;   //宽字符串字面值是一串常量宽字符，同样以一个宽空字符结束。</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>多行字面值</strong></li></ol><p>处理长字符串有一个更基本的（但不常使用）方法，这个方法依赖于很少使用的程序格式化特性：在一行的末尾加一反斜线符号可将此行和下一行当作同一行处理。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cou\ </span><br><span class="line">t &lt;&lt; &quot;Hi&quot; &lt;&lt; st\ </span><br><span class="line">d::endl;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &quot;Hi&quot; &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>可以使用这个特性来编写长字符串字面值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     std::cout &lt;&lt; &quot;a multi-line \ </span><br><span class="line">string literal \ </span><br><span class="line">using a backslash&quot; </span><br><span class="line">              &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>注意反斜线符号必须是该行的尾字符——不允许有注释或空格符。同样，后继行行首的任何空格和制表符都是字符串字面值的一部分。正因如此，长字符串字面值的后继行才不会有正常的缩进。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h1&gt;&lt;p&gt;类型是所有程序的基础。类型告诉我们数据代表什么意思以及可以对数据执行哪些操作。&lt;br&gt;C++ 语言定义了几种基本类型：字符型、整型、浮点型等。C++ 还提供了可用于自定义数据类型的机制，标准库正是利用这些机制定义了许多更复杂的类型，比如可变长字符串 string、vector 等。此外，我们还能修改已有的类型以形成复合类型。&lt;/p&gt;
&lt;h2 id=&quot;2-1-基本内置类型&quot;&gt;&lt;a href=&quot;#2-1-基本内置类型&quot; class=&quot;headerlink&quot; title=&quot;2.1 基本内置类型&quot;&gt;&lt;/a&gt;2.1 基本内置类型&lt;/h2&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>SalesItem.h</title>
    <link href="https://zypsola.com/2018/10/20/SalesItem/"/>
    <id>https://zypsola.com/2018/10/20/SalesItem/</id>
    <published>2018-10-20T05:03:10.000Z</published>
    <updated>2018-10-22T09:35:21.101Z</updated>
    
    <content type="html"><![CDATA[<p>Code</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#ifndef SALESITEM_H</span><br><span class="line">#define SALESITEM_H</span><br><span class="line"></span><br><span class="line">// Definition of Sales_item class and related functions goes here</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Sales_item &#123;</span><br><span class="line">friend bool operator==(const Sales_item&amp;, const Sales_item&amp;);</span><br><span class="line">// other members as before</span><br><span class="line">public:</span><br><span class="line">    // added constructors to initialize from a string or an istream</span><br><span class="line">    Sales_item(const std::string &amp;book):</span><br><span class="line">              isbn(book), units_sold(0), revenue(0.0) &#123; &#125;</span><br><span class="line">    Sales_item(std::istream &amp;is) &#123; is &gt;&gt; *this; &#125;</span><br><span class="line">    friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, Sales_item&amp;);</span><br><span class="line">    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Sales_item&amp;);</span><br><span class="line">public:</span><br><span class="line">    // operations on Sales_item objects</span><br><span class="line">    // member binary operator: left-hand operand bound to implicit this pointer</span><br><span class="line">    Sales_item&amp; operator+=(const Sales_item&amp;);</span><br><span class="line">    // other members as before</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    // operations on Sales_item objects</span><br><span class="line">    double avg_price() const;</span><br><span class="line">    bool same_isbn(const Sales_item &amp;rhs) const</span><br><span class="line">        &#123; return isbn == rhs.isbn; &#125;</span><br><span class="line">    // default constructor needed to initialize members of built-in type</span><br><span class="line">    Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</span><br><span class="line">// private members as before</span><br><span class="line">private:</span><br><span class="line">    std::string isbn;</span><br><span class="line">    unsigned units_sold;</span><br><span class="line">    double revenue;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// nonmember binary operator: must declare a parameter for each operand</span><br><span class="line">Sales_item operator+(const Sales_item&amp;, const Sales_item&amp;);</span><br><span class="line"></span><br><span class="line">inline bool </span><br><span class="line">operator==(const Sales_item &amp;lhs, const Sales_item &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    // must be made a friend of Sales_item</span><br><span class="line">    return lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">           lhs.revenue == rhs.revenue &amp;&amp;</span><br><span class="line">       lhs.same_isbn(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool </span><br><span class="line">operator!=(const Sales_item &amp;lhs, const Sales_item &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    return !(lhs == rhs); // != defined in terms of operator==</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using std::istream; using std::ostream;</span><br><span class="line"></span><br><span class="line">// assumes that both objects refer to the same isbn</span><br><span class="line">inline</span><br><span class="line">Sales_item&amp; Sales_item::operator+=(const Sales_item&amp; rhs) </span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold; </span><br><span class="line">    revenue += rhs.revenue; </span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// assumes that both objects refer to the same isbn</span><br><span class="line">inline</span><br><span class="line">Sales_item </span><br><span class="line">operator+(const Sales_item&amp; lhs, const Sales_item&amp; rhs) </span><br><span class="line">&#123;</span><br><span class="line">    Sales_item ret(lhs);  // copy lhs into a local object that we&apos;ll return</span><br><span class="line">    ret += rhs;           // add in the contents of rhs </span><br><span class="line">    return ret;           // return ret by value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">istream&amp; </span><br><span class="line">operator&gt;&gt;(istream&amp; in, Sales_item&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    double price;</span><br><span class="line">    in &gt;&gt; s.isbn &gt;&gt; s.units_sold &gt;&gt; price;</span><br><span class="line">    // check that the inputs succeeded</span><br><span class="line">    if (in)</span><br><span class="line">        s.revenue = s.units_sold * price;</span><br><span class="line">    else </span><br><span class="line">        s = Sales_item();  // input failed: reset object to default state</span><br><span class="line">    return in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">ostream&amp; </span><br><span class="line">operator&lt;&lt;(ostream&amp; out, const Sales_item&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; s.isbn &lt;&lt; &quot;\t&quot; &lt;&lt; s.units_sold &lt;&lt; &quot;\t&quot; </span><br><span class="line">        &lt;&lt; s.revenue &lt;&lt; &quot;\t&quot; &lt;&lt;  s.avg_price();</span><br><span class="line">    return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">double Sales_item::avg_price() const</span><br><span class="line">&#123;</span><br><span class="line">    if (units_sold) </span><br><span class="line">        return revenue/units_sold; </span><br><span class="line">    else </span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Code&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Lesson1</title>
    <link href="https://zypsola.com/2018/10/18/C++Primer1/"/>
    <id>https://zypsola.com/2018/10/18/C++Primer1/</id>
    <published>2018-10-18T13:03:10.000Z</published>
    <updated>2018-10-22T07:37:14.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-快速入门"><a href="#第一章-快速入门" class="headerlink" title="第一章 快速入门"></a>第一章 快速入门</h1><a id="more"></a><ol><li><p>标准库定义了 4 个 IO 对象。<br>处理输入时使用命名为 cin（读作 see-in）的 istream 类型对象。这个对象也称为<strong>标准输入</strong>。处理输出时使用命名为 cout（读作 see-out）的 ostream 类型对象，这个对象也称为<strong>标准输出</strong>。标准库还定义了另外两个 ostream 对象，分别命名为 cerr 和 clog（分别读作“see-err”和“see-log”）。cerr 对象又叫作<strong>标准错误</strong>，通常用来输出警告和错误信息给程序的使用者。而 clog 对象用于产生程序执行的一般信息。 一般情况下，系统将这些对象与执行程序的窗口联系起来。这样，当我们从 cin 读入时，数据从执行程序的窗口读入，当写到 cin、cerr 或 clog 时，输出写至同一窗口。运行程序时，大部分操作系统都提供了重定向输入或输出流的方法。利用重定向可以将这些流与所选择的文件联系起来。 </p></li><li><p><strong>输出操作符</strong>（&lt;&lt; 操作符）<br>每个输出操作符实例都接受两个操作数：左操作数必须是 ostream 对象；右操作数是要输出的值。操作符将其右操作数写到作为其左操作数的 ostream 对象。C++ 中，每个表达式都会产生一个结果，通常是将操作符作用到其操作数所产生的值。当操作符是输出操作符时，结果是左操作数的值。也就是说，输出操作返回的值是输出流本身。 </p></li><li><p>endl 是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区。通过刷新缓冲区，用户可立即看到写入到流中的输出。 </p></li><li><p><strong>输入操作符</strong>（&gt;&gt; 操作符）<br>行为与输出操作符相似。它接受一个 istream 对象作为其左操作数，接受一个对象作为其右操作数，它从 istream 操作数读取数据并保存到右操作数中。像输出操作符一样，输入操作符返回其左操作数作为结果。</p></li><li><p><strong>关于注释</strong><br>C++ 中有单行注释和成对注释两种类型的注释。单行注释以双斜线（//）开头，行中处于双斜线右边的内容是注释，被编译器忽略。 另一种定界符，注释对（/* */），是从 C 语言继承过来的。这种注释以“/*”开头，以“*/”结尾。编译器把落入注释对“/**/”之间的内容作为注释。</p></li><li><p><strong>注释对不可嵌套</strong><br>当注释掉程序的一大部分时，似乎最简单的办法就是在要临时忽略的区域前后放一个注释对。问题是如果那段代码已经有了注释对，那么新插入的注释对将提前终止。临时忽略一段代码更好的方法，是用编辑器在要忽略的每一行代码前面插入单行注释。这样，你就无需担心要注释的代码是否已包含注释对。 </p></li><li><p><strong>术语</strong><br><strong>argument（实参）:</strong>传递给被调用函数的值。<br><strong>block（块）:</strong>花括号括起来的语句序列。<br><strong>buffer（缓冲区）:</strong>一段用来存放数据的存储区域。IO 设备常存储输入（或输出）到缓冲区，并独立于程序动作对缓冲区进行读写。输出缓冲区通常必须显式刷新以强制输出缓冲区内容。默认情况下，读 cin 会刷新 cout；当程序正常结束时，cout 也被刷新。<br><strong>built-in type（内置类型）:</strong>C++ 语言本身定义的类型，如 int。<br><strong>cerr:</strong>绑定到标准错误的 ostream 对象，这通常是与标准输出相同的流。默认情况下，输出 cerr 不缓冲，通常用于不是程序正常逻辑部分的错误信息或其他输出。<br><strong>clog:</strong>绑定到标准错误的 ostream 对象。默认情况下，写到 clog 时是带缓冲的。通常用于将程序执行信息写入到日志文件中。<br><strong>namespace（命名空间）:</strong>将库所定义的名字放至单独一个地方的机制。命名空间有助于避免无意的命名冲突。C++ 标准库所定义的名字在命名空间 std 中。<br><strong>preprocessor directive（预处理指示）:</strong>C++ 预处理器的指示。#include 是一个预处理器指示。预处理器指示必须出现在单独的行中。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章-快速入门&quot;&gt;&lt;a href=&quot;#第一章-快速入门&quot; class=&quot;headerlink&quot; title=&quot;第一章 快速入门&quot;&gt;&lt;/a&gt;第一章 快速入门&lt;/h1&gt;
    
    </summary>
    
    
      <category term="C++ Primer" scheme="https://zypsola.com/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>Unity Lesson1</title>
    <link href="https://zypsola.com/2018/08/18/Unity1/"/>
    <id>https://zypsola.com/2018/08/18/Unity1/</id>
    <published>2018-08-18T07:43:51.000Z</published>
    <updated>2018-08-18T08:13:19.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Awake-、-OnEnable-与-Start"><a href="#Awake-、-OnEnable-与-Start" class="headerlink" title="Awake() 、 OnEnable() 与 Start()"></a>Awake() 、 OnEnable() 与 Start()</h1><a id="more"></a><p><img src="http://pdncef9qu.bkt.clouddn.com/unity-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Awake-、-OnEnable-与-Start&quot;&gt;&lt;a href=&quot;#Awake-、-OnEnable-与-Start&quot; class=&quot;headerlink&quot; title=&quot;Awake() 、 OnEnable() 与 Start()&quot;&gt;&lt;/a&gt;Awake() 、 OnEnable() 与 Start()&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Unity" scheme="https://zypsola.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>C# Lesson3</title>
    <link href="https://zypsola.com/2018/07/12/C-Lesson3/"/>
    <id>https://zypsola.com/2018/07/12/C-Lesson3/</id>
    <published>2018-07-12T09:53:10.000Z</published>
    <updated>2018-10-19T16:50:51.365Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="C#" scheme="https://zypsola.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C# Lesson2</title>
    <link href="https://zypsola.com/2018/07/11/C-Lesson2/"/>
    <id>https://zypsola.com/2018/07/11/C-Lesson2/</id>
    <published>2018-07-11T12:11:22.000Z</published>
    <updated>2018-10-19T16:51:46.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-C-编程概述"><a href="#第二章-C-编程概述" class="headerlink" title="第二章 C#编程概述"></a>第二章 C#编程概述</h1><h2 id="1-一个简单的C-程序"><a href="#1-一个简单的C-程序" class="headerlink" title="1.一个简单的C#程序"></a>1.一个简单的C#程序</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;        //告诉编译器这个程序使用System命名空间的类型</span><br><span class="line"></span><br><span class="line">namespace Simple     //声明一个新命名空间，名称为Simple</span><br><span class="line">&#123;</span><br><span class="line">class Program    //声明一个新的类，名称为Program</span><br><span class="line">&#123;</span><br><span class="line">static void Main()     //声明了一个名称为Main的方法；Main是一个特殊函数，编译器用它作为程序的起始点</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;Hi there!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>C#程序由一个或多个类型声明组成，程序中的类型可以以任意顺序声明，在以上代码中，只声明了class类型。</li><li><strong>命名空间</strong>是与某个名称相关联的一组类型声明。</li></ol><h2 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h2><ol><li><strong>标识符</strong>是一种字符串，用来命名如变量、方法、参数等程序结构。</li><li>可以通过把有意义的词连接成一个单独的描述性名称来创建自文档化(self-documenting)的标识符。</li></ol><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic2-1.png" alt=""></p><h2 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h2><ol><li><strong>关键字</strong>是用来定义C#语言的字符串记号</li><li><strong>上下文关键字</strong>是仅在特定的语言结构中充当关键字的标识符</li></ol><h2 id="4-Main：程序的起始点"><a href="#4-Main：程序的起始点" class="headerlink" title="4.Main：程序的起始点"></a>4.Main：程序的起始点</h2><ol><li>每个C#程序必须有一个类带有Main方法(函数)</li></ol><h2 id="5-空白"><a href="#5-空白" class="headerlink" title="5.空白"></a>5.空白</h2><ol><li>空白字符包括：空格(Sapce)、制表符(Tab)、换行符、回车符</li></ol><h2 id="6-语句"><a href="#6-语句" class="headerlink" title="6.语句"></a>6.语句</h2><ol><li>语句是描述一个类型或告诉程序去执行某个动作的一条源代码指令；简单语句以一个分号结束</li><li><strong>块</strong>一个由成对大括号包围的0条或多条语句序列，它在语法上相当于一条语句。</li></ol><h2 id="7-从程序中输出文本"><a href="#7-从程序中输出文本" class="headerlink" title="7.从程序中输出文本"></a>7.从程序中输出文本</h2><h3 id="7-1-Write"><a href="#7-1-Write" class="headerlink" title="7.1 Write"></a>7.1 Write</h3><p>Write是Console类的成员，它把一个文本字符串发送到程序的控制台窗口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.Write(&quot;This is trivial text&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="7-2-WriteLine"><a href="#7-2-WriteLine" class="headerlink" title="7.2 WriteLine"></a>7.2 WriteLine</h3><p>WriteLine是Console的另一个成员，与Write功能相同，但会在结尾添加一个换行符</p><h3 id="7-3-格式字符串"><a href="#7-3-格式字符串" class="headerlink" title="7.3 格式字符串"></a>7.3 格式字符串</h3><ol><li>Write语句和WriteLine语句的常规形式中可以有一个以上的参数，参数间用逗号分隔</li><li>第一个参数必须总为字符串，称为<strong>格式字符串</strong>，格式字符串可以包含替代标记</li><li><p>跟着格式字符串的参数称为<strong>替换值</strong>，替换值从0开始编号</p><p> Console.WriteLine(“Two sample intergers are {0} and {1}.”, 3, 6};</p></li></ol><h3 id="7-4-多重标记和值"><a href="#7-4-多重标记和值" class="headerlink" title="7.4 多重标记和值"></a>7.4 多重标记和值</h3><pre><code>Console.WriteLine(&quot;Three intergers are {1}, {0} and {1}.&quot;, 3, 6);</code></pre><h3 id="7-5-格式化数字字符串"><a href="#7-5-格式化数字字符串" class="headerlink" title="7.5 格式化数字字符串"></a>7.5 格式化数字字符串</h3><pre><code>Console.WriteLine(&quot;The value: {0}.&quot;, 500);    //输出数字Console.WriteLine(&quot;The value: {0:C}.&quot;, 500);  //格式为货币int myInt = 500；Console.WriteLine(&quot;|{0, 10}|&quot;, myInt);        //右对齐Console.WriteLine(&quot;|{0,-10}|&quot;, myInt);        //左对齐double myDouble = 12.345678;Console.WriteLine(&quot;{0,-10:G} -- General                           &quot;, myDouble);Console.WriteLine(&quot;{0,-10} -- Default, same as General            &quot;, myDouble);Console.WriteLine(&quot;{0,-10:F4} -- Fixed Point, 4 dec places        &quot;, myDouble);Console.WriteLine(&quot;{0,-10:C} -- Currency                          &quot;, myDouble);Console.WriteLine(&quot;{0,-10:E3} -- Sci. Notation, 3 dec places      &quot;, myDouble);Console.WriteLine(&quot;{0,-10:x} -- Hexadecimal integer               &quot;, 25);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-C-编程概述&quot;&gt;&lt;a href=&quot;#第二章-C-编程概述&quot; class=&quot;headerlink&quot; title=&quot;第二章 C#编程概述&quot;&gt;&lt;/a&gt;第二章 C#编程概述&lt;/h1&gt;&lt;h2 id=&quot;1-一个简单的C-程序&quot;&gt;&lt;a href=&quot;#1-一个简单的C-程序&quot; class=&quot;headerlink&quot; title=&quot;1.一个简单的C#程序&quot;&gt;&lt;/a&gt;1.一个简单的C#程序&lt;/h2&gt;
    
    </summary>
    
    
      <category term="C#" scheme="https://zypsola.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Blender(一)</title>
    <link href="https://zypsola.com/2018/05/25/Blender1/"/>
    <id>https://zypsola.com/2018/05/25/Blender1/</id>
    <published>2018-05-25T11:39:19.000Z</published>
    <updated>2018-07-11T13:21:01.428Z</updated>
    
    <content type="html"><![CDATA[<p><strong>开启建模大业！Blender的学习！</strong></p><h2 id="必须熟悉的Blender基础操作"><a href="#必须熟悉的Blender基础操作" class="headerlink" title="必须熟悉的Blender基础操作"></a>必须熟悉的Blender基础操作</h2><a id="more"></a><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><ol><li>右键：选择</li><li>A键：全选或取消选择</li><li>B键+左键：矩形选择</li><li>C键+左键：笔刷选择</li><li>C键+中键：笔刷取选</li><li>滚轮调节笔刷大小</li><li>Ctrl+左键：套索选择</li><li>Ctrl+shift+左键：套索取选</li><li>alt+右键：选择边循环</li><li>Ctrl+alt+右键：环边选择</li><li>Ctrl+tab：切换点/线/面选择模式</li><li>Ctrl+小键盘+/-：放大收缩选择范围</li><li>L键：选择鼠标所在元素的有关联元素</li></ol><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ol start="14"><li>中键：旋转视图</li><li>shift+中键：移动视图</li><li>ctrl+中键 / 滚轮：缩放视图</li><li>小键盘0：进入/退出摄像机视图</li><li>小键盘5：切换透视/正交视图</li><li>小键盘1/3/7：切换前/右/顶视图</li><li>ctrl+小键盘1/3/7：反向对应视图</li><li>Home：全窗口显示所有物体</li><li>小键盘.：全窗口显示所选物体</li><li>左键：移动3D游标</li><li>shift+C键：重置视图</li><li>小键盘/：所选物体满框并隔离未选择物体</li><li>Z键：线框/实体切换</li><li>alt+Z键：贴图/实体切换</li><li>Shift+Z键：渲染预览/实体切换</li></ol><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><ol start="29"><li>ctrl+R键：增加循环线;滚轮确定更多细分;右键确定循环线在切分中心</li><li>K键：使用切割工具,Enter完成切割</li><li>I键：插入工具</li><li>E键：挤出工具</li><li>ctrl+B键：倒角工具;滚轮确定更多细分</li><li>G键+G键：在边上滑动</li><li>V键：撕开选择边</li></ol><h3 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h3><ol start="36"><li>shift+A键：添加物体</li><li>G键：移动物体</li><li>S键：缩放</li><li>R键：旋转</li><li>XYZ键：固定在某个方向上操作</li><li>空格键：搜索菜单</li><li>Ctrl+shift+alt+C键：设置物体源心</li><li>shift+S键：吸附</li><li>shift+D键：复制</li><li>alt+D键：关联复制</li><li>P键：将选择的元素独立成新物体</li><li>Ctrl+J键：加入到目标物体</li></ol><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ol start="48"><li>alt+A键：播放/暂停</li><li>shift+alt+A键：倒放的播放/暂停</li><li>左右箭头：前后帧</li><li>shift+上下箭头：前后10帧</li><li>shift+左右箭头：到开始/结束位置</li></ol><h3 id="Add-2018-05-26"><a href="#Add-2018-05-26" class="headerlink" title="Add 2018-05-26"></a>Add 2018-05-26</h3><ol start="53"><li>ctrl+alt+Q键：多视图切换</li><li>shift+R：重复上次操作</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;开启建模大业！Blender的学习！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;必须熟悉的Blender基础操作&quot;&gt;&lt;a href=&quot;#必须熟悉的Blender基础操作&quot; class=&quot;headerlink&quot; title=&quot;必须熟悉的Blender基础操作&quot;&gt;&lt;/a&gt;必须熟悉的Blender基础操作&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://zypsola.com/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Z720(一)</title>
    <link href="https://zypsola.com/2018/05/05/MyNovel1/"/>
    <id>https://zypsola.com/2018/05/05/MyNovel1/</id>
    <published>2018-05-04T17:43:32.000Z</published>
    <updated>2018-10-19T14:47:21.624Z</updated>
    
    <content type="html"><![CDATA[<p>Z720是一台垃圾回收机器人，但请不要误会，它的工作并不是在脏乱的城市街道之中到处回收生活垃圾，而是回收哪些</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Z720是一台垃圾回收机器人，但请不要误会，它的工作并不是在脏乱的城市街道之中到处回收生活垃圾，而是回收哪些&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Z720" scheme="https://zypsola.com/tags/Z720/"/>
    
  </entry>
  
  <entry>
    <title>C# Lesson1</title>
    <link href="https://zypsola.com/2018/05/03/C-Lesson1/"/>
    <id>https://zypsola.com/2018/05/03/C-Lesson1/</id>
    <published>2018-05-03T14:57:06.000Z</published>
    <updated>2018-10-19T16:51:38.739Z</updated>
    
    <content type="html"><![CDATA[<p>从用<strong>WPF</strong>做界面开始，到现在用<strong>Unity</strong>做游戏，使用<strong>C#</strong>已经有好一段时间了，但一直没有系统地学习C#。<br>是时候学习一下了，这里我使用的是<strong>《C#图解教程》</strong>。</p><h1 id="第一章-C-和-NET框架"><a href="#第一章-C-和-NET框架" class="headerlink" title="第一章 C#和.NET框架"></a>第一章 C#和.NET框架</h1><p><strong>C#</strong>是为在微软的<strong>.NET Framework</strong>上开发程序设计的。</p><a id="more"></a><h2 id="1-NET框架由三部分组成"><a href="#1-NET框架由三部分组成" class="headerlink" title="1 .NET框架由三部分组成"></a>1 .NET框架由三部分组成</h2><ol><li><p>执行环境称为<strong>CLR</strong>(Common Language Runtime, 公共语言运行库)<br>CLR在运行时管理程序的执行，包括：<br>内存管理和垃圾收集<br>代码安全验证<br>代码执行、线程管理及异常处理</p><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-1.png" alt=""></p></li><li><p><strong>编程工具</strong>涵盖了编码和调试需要的一切，包括：<br>Visual Studio集成开发环境(IDE)<br>.NET兼容的编译器<br>调试器<br>网站开发服务器端技术，如ASP.NET或WCF</p></li><li><p><strong>BCL</strong>(Base Class Library,基类库)是.NET框架使用的一个大的类库，而且可以在自己的程序中使用</p></li></ol><h2 id="2-NET的特点及其带来的好处"><a href="#2-NET的特点及其带来的好处" class="headerlink" title="2 .NET的特点及其带来的好处"></a>2 .NET的特点及其带来的好处</h2><ol><li><p>面向对象的开发环境</p></li><li><p>自动垃圾收集<br>CLR有一项服务<strong>GC</strong>(Garbage Collector, 垃圾收集器)能自动管理内存<br>GC自动从内存中删除程序不再访问的对象</p></li><li><p>互操作性</p></li><li><p>不需要COM</p></li><li><p>简化部署</p></li><li><p>类型安全性</p></li><li><p>基础库</p></li></ol><h2 id="3-编译成CIL"><a href="#3-编译成CIL" class="headerlink" title="3 编译成CIL"></a>3 编译成CIL</h2><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-2.png" alt=""></p><p>.NET语言的编译器接受源代码文件，并生成名为<strong>程序集</strong>的输出文件<br>程序集要么是可执行的，要么是DLL<br>程序集里的代码不是本机代码而是<strong>CIL</strong>(Common International Language，公共中间语言)</p><h2 id="4-编译成本机代码并执行"><a href="#4-编译成本机代码并执行" class="headerlink" title="4 编译成本机代码并执行"></a>4 编译成本机代码并执行</h2><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-3.png" alt=""></p><p>程序的CIL直到它被调用运行时才会被编译成本机代码。运行时，CLR执行以下步骤：</p><ol><li><p>检查程序集的安全特性</p></li><li><p>在内存中分配空间</p></li><li><p>把程序集中的可执行代码发送给<strong>JIT</strong>(实时编译器)，把其中一部分编译成本机代码</p></li></ol><p>不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次<br>一旦CIL被编译成本机代码，CLR就在它运行时管理它<br><strong>托管代码</strong> 为.NET框架编写的代码，需要CLR<br><strong>非托管代码</strong> 不在CLR控制之下运行的代码</p><h2 id="5-编译和执行"><a href="#5-编译和执行" class="headerlink" title="5 编译和执行"></a>5 编译和执行</h2><p>无论原始源文件的语言是什么，都遵循相同的编译和执行过程</p><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-4.png" alt=""></p><h2 id="6-CLR与CLI"><a href="#6-CLR与CLI" class="headerlink" title="6 CLR与CLI"></a>6 CLR与CLI</h2><p>.NET框架的核心组件是CLR，它在操作系统的顶层，负责管理程序的执行</p><p>CLI(Common Language Infrastructure，公共语言基础结构)，它把所有.NET框架的组件连结成一个内聚的、一致的系统。它展示了系统的概念和架构，并详细说明了所有软件都必须坚持的规则和约定。</p><p><img src="http://p87c5zr6b.bkt.clouddn.com/pic1-5.png" alt=""></p><p>CLI的重要组成部分</p><ol><li>公共类型系统<strong>CTS</strong>(Common Type System)</li><li>公共语言规范<strong>CLS</strong>(Common Language Specification)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从用&lt;strong&gt;WPF&lt;/strong&gt;做界面开始，到现在用&lt;strong&gt;Unity&lt;/strong&gt;做游戏，使用&lt;strong&gt;C#&lt;/strong&gt;已经有好一段时间了，但一直没有系统地学习C#。&lt;br&gt;是时候学习一下了，这里我使用的是&lt;strong&gt;《C#图解教程》&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;第一章-C-和-NET框架&quot;&gt;&lt;a href=&quot;#第一章-C-和-NET框架&quot; class=&quot;headerlink&quot; title=&quot;第一章 C#和.NET框架&quot;&gt;&lt;/a&gt;第一章 C#和.NET框架&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;C#&lt;/strong&gt;是为在微软的&lt;strong&gt;.NET Framework&lt;/strong&gt;上开发程序设计的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C#" scheme="https://zypsola.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法学习</title>
    <link href="https://zypsola.com/2018/05/03/Markdown/"/>
    <id>https://zypsola.com/2018/05/03/Markdown/</id>
    <published>2018-05-03T10:07:17.000Z</published>
    <updated>2018-10-22T14:18:56.813Z</updated>
    
    <content type="html"><![CDATA[<p>既然要写博客，首先就要学习一下Markdown语法<a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="noopener">Markdown语法说明(简体中文版)</a></p><a id="more"></a><h2 id="1-标题语法"><a href="#1-标题语法" class="headerlink" title="1.标题语法"></a>1.标题语法</h2><p>Markdown支持两种标题语法：类Setext和类atx形式</p><h3 id="a-类Setext："><a href="#a-类Setext：" class="headerlink" title="a.类Setext："></a>a.类Setext：</h3><p>任意数量的’=’或’-‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H1 //最高阶标题</span><br><span class="line">===</span><br><span class="line">H2 //第二阶标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="b-类Atx："><a href="#b-类Atx：" class="headerlink" title="b.类Atx："></a>b.类Atx：</h3><p>行首插入1到6个’#’，对应1到6阶，注意’#’ 与标题间要有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line"></span><br><span class="line">## H2</span><br><span class="line"></span><br><span class="line">### H3</span><br></pre></td></tr></table></figure></p><p>也可以选择性地闭合类Atx标题：在行尾加上’#’，且数量无需和行首相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># H1 ###</span><br><span class="line"></span><br><span class="line">## H2 ##</span><br><span class="line"></span><br><span class="line">### H3 #</span><br></pre></td></tr></table></figure></p><h2 id="2-区块引用Blockquote"><a href="#2-区块引用Blockquote" class="headerlink" title="2.区块引用Blockquote"></a>2.区块引用Blockquote</h2><blockquote><p>我该说些什么好呢，ZYP，加油吧！<br>                                                                   ——ZYP</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 我该说些什么好呢，ZYP，加油吧！</span><br><span class="line">&gt;                               ——ZYP</span><br></pre></td></tr></table></figure><p>也可以嵌套</p><blockquote><p>Level1</p><blockquote><p>Level2</p><blockquote><p>Level3</p></blockquote><p>Level2</p></blockquote><p>Level1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Level1</span><br><span class="line">&gt; &gt; Level2</span><br><span class="line">&gt; &gt; &gt; Level3</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt; &gt; Level2</span><br><span class="line">&gt;</span><br><span class="line">&gt; Level1</span><br></pre></td></tr></table></figure><p>引用的区块内也可以使用其他的Markdown语法</p><blockquote><h2 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h2><ol><li>First</li><li>Second</li></ol></blockquote><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><p>Markdown支持有序列表和无序列表  </p><p>无序列表使用星号、加号或减号作为列表标记</p><ul><li>1</li><li>2</li><li>3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 1</span><br><span class="line">* 2</span><br><span class="line">* 3</span><br></pre></td></tr></table></figure><ul><li>1</li><li>2</li><li>3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 1</span><br><span class="line">+ 2</span><br><span class="line">+ 3</span><br></pre></td></tr></table></figure><ul><li>1</li><li>2</li><li>3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line">- 3</span><br></pre></td></tr></table></figure><p>有序列表</p><ol><li>a</li><li>b</li><li>c</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. a</span><br><span class="line">2. b</span><br><span class="line">3. c</span><br></pre></td></tr></table></figure><h2 id="4-代码区块"><a href="#4-代码区块" class="headerlink" title="4.代码区块"></a>4.代码区块</h2><pre><code>for (int i = 0; i &lt; 4; i++){    double MobiTem = 0.0;    x = PosX[0][i];    y = PosY[0][i];    vst[x][y]++;    queenmove[x][y][0] = 1;    for (int j = 0; j &lt; 8; j++)    {        x = PosX[0][i];        y = PosY[0][i];        for (int s = 1;; s++)        {            x += Dx[j];            y += Dy[j];            if (Map[x][y] != BLANK)break;            vst[x][y]++;            queenmove[x][y][0] = 1;            double mobi = 0.0;            for (int k = 0; k &lt; 8; k++)            {                if (Map[x + Dx[k]][y + Dy[k]] == BLANK)                {                    mobi += 1.0;                }            }            MobiTem = MobiTem + mobi / s;        }    }    MobilityW += MobiTem;    if (MobiTem &lt; MobiMin)    {        MobiMin = MobiTem;    }}</code></pre><h2 id="5-分隔线"><a href="#5-分隔线" class="headerlink" title="5.分隔线"></a>5.分隔线</h2><hr><p>在一行中用三个以上星号、减号或底线来建立一个分隔线</p><hr><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------</span><br><span class="line">* * * * *</span><br><span class="line">_________</span><br></pre></td></tr></table></figure><h2 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h2><h3 id="a-行内式"><a href="#a-行内式" class="headerlink" title="a.行内式"></a>a.行内式</h3><p>This is <a href="http://www.baidu.com" title="百度一下" target="_blank" rel="noopener">baidu</a>.</p><p>This is <a href="/2018/05/02/Hello-ZYP/">my first blog</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [baidu](http://www.baidu.com &quot;百度一下&quot;).</span><br><span class="line"></span><br><span class="line">This is [my first blog](/2018/05/02/Hello-ZYP/).</span><br></pre></td></tr></table></figure><h3 id="b-参考式"><a href="#b-参考式" class="headerlink" title="b.参考式"></a>b.参考式</h3><p>链接标签不区分大小写</p><p>This is <a href="http://www.baidu.com" target="_blank" rel="noopener">baidu</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [baidu][baidu_id].</span><br><span class="line"></span><br><span class="line">[baidu_id]: http://www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="7-强调"><a href="#7-强调" class="headerlink" title="7.强调"></a>7.强调</h2><p>0123<br>0<em>123</em>4<br>0<strong>123</strong>45<br>0_123_456<br><strong>123</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0123</span><br><span class="line">0*123*4</span><br><span class="line">0**123**45</span><br><span class="line">0_123_456</span><br><span class="line">__123__</span><br></pre></td></tr></table></figure><h2 id="8-代码"><a href="#8-代码" class="headerlink" title="8.代码"></a>8.代码</h2><p>use <code>printf()</code> function<br><code>`</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use `printf()` function</span><br><span class="line">`` ` ``</span><br></pre></td></tr></table></figure><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9.图片"></a>9.图片</h2><p><img src="http://p87366ttr.bkt.clouddn.com/%E9%AD%94%E6%B3%95%E4%BD%BF%E4%B9%8B%E5%A4%9C01.jpg" alt="——魔法使之夜"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text]()</span><br></pre></td></tr></table></figure><h2 id="10-lt-gt"><a href="#10-lt-gt" class="headerlink" title="10.&lt;&gt;"></a>10.&lt;&gt;</h2><p>在MarkDown中，使用尖括号”&lt;”和”&gt;”，会被文本默认为HTML语句。这将导致尖括号本身及尖括号中的内容都不会被显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决方法：使用转义字符。使用 &quot;&amp;lt;&quot; 代替 “&lt;” , 使用 &quot;&amp;gt;&quot; 代替 &quot;&gt;&quot;。 例如要输出&lt;a&gt;，则需要写为&amp;lt;a&amp;gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然要写博客，首先就要学习一下Markdown语法&lt;a href=&quot;http://wowubuntu.com/markdown/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Markdown语法说明(简体中文版)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://zypsola.com/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Hello ZYP!</title>
    <link href="https://zypsola.com/2018/05/02/Hello-ZYP/"/>
    <id>https://zypsola.com/2018/05/02/Hello-ZYP/</id>
    <published>2018-05-02T08:31:38.000Z</published>
    <updated>2018-10-22T09:33:49.580Z</updated>
    
    <content type="html"><![CDATA[<p>经过了两天的努力总算搭好了这个博客，这将是一个新的起点，不再<strong>随波逐流</strong>，而是明确前进的方向，为了自己的梦想努力！<br>无论有没有他人观看，<strong>自己都始终是自己人生的观众</strong>，那么就不能让自己失望！这个博客并不是为了展示，而是记录，是为了让自己看的更加清楚，未来是靠自己创造的！</p><a id="more"></a><p>这个博客是使用 Hexo + Github Page 搭建的，使用modernist主题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过了两天的努力总算搭好了这个博客，这将是一个新的起点，不再&lt;strong&gt;随波逐流&lt;/strong&gt;，而是明确前进的方向，为了自己的梦想努力！&lt;br&gt;无论有没有他人观看，&lt;strong&gt;自己都始终是自己人生的观众&lt;/strong&gt;，那么就不能让自己失望！这个博客并不是为了展示，而是记录，是为了让自己看的更加清楚，未来是靠自己创造的！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Others" scheme="https://zypsola.com/tags/Others/"/>
    
  </entry>
  
</feed>
